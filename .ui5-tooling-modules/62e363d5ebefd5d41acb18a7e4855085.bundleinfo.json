{
  "_entries": [
    {
      "name": "@datagrok/dendrogram/detectors",
      "path": "/home/user/projects/project1/node_modules/@datagrok/dendrogram/detectors.js",
      "lastModified": 1733394545990,
      "type": "module",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n\tclass DendrogramPackageDetectors extends DG.Package {}\n\n\tconst __esModule = true;\n\n\texports.__esModule = __esModule;\n\n}));\n"
    },
    {
      "name": "chart.js/auto",
      "path": "/home/user/projects/project1/node_modules/chart.js/auto/auto.js",
      "lastModified": 1733394545126,
      "type": "module",
      "code": "sap.ui.define((function () { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tvar chart = {exports: {}};\n\n\t/*!\n\t * Chart.js v3.7.1\n\t * https://www.chartjs.org\n\t * (c) 2022 Chart.js Contributors\n\t * Released under the MIT License\n\t */\n\n\t(function (module, exports) {\n\t\t(function (global, factory) {\n\t\tmodule.exports = factory() ;\n\t\t})(commonjsGlobal, (function () {\n\t\tfunction fontString(pixelSize, fontStyle, fontFamily) {\n\t\t  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t\t}\n\t\tconst requestAnimFrame = (function() {\n\t\t  if (typeof window === 'undefined') {\n\t\t    return function(callback) {\n\t\t      return callback();\n\t\t    };\n\t\t  }\n\t\t  return window.requestAnimationFrame;\n\t\t}());\n\t\tfunction throttled(fn, thisArg, updateFn) {\n\t\t  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n\t\t  let ticking = false;\n\t\t  let args = [];\n\t\t  return function(...rest) {\n\t\t    args = updateArgs(rest);\n\t\t    if (!ticking) {\n\t\t      ticking = true;\n\t\t      requestAnimFrame.call(window, () => {\n\t\t        ticking = false;\n\t\t        fn.apply(thisArg, args);\n\t\t      });\n\t\t    }\n\t\t  };\n\t\t}\n\t\tfunction debounce(fn, delay) {\n\t\t  let timeout;\n\t\t  return function(...args) {\n\t\t    if (delay) {\n\t\t      clearTimeout(timeout);\n\t\t      timeout = setTimeout(fn, delay, args);\n\t\t    } else {\n\t\t      fn.apply(this, args);\n\t\t    }\n\t\t    return delay;\n\t\t  };\n\t\t}\n\t\tconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\t\tconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\t\tconst _textX = (align, left, right, rtl) => {\n\t\t  const check = rtl ? 'left' : 'right';\n\t\t  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n\t\t};\n\n\t\tclass Animator {\n\t\t  constructor() {\n\t\t    this._request = null;\n\t\t    this._charts = new Map();\n\t\t    this._running = false;\n\t\t    this._lastDate = undefined;\n\t\t  }\n\t\t  _notify(chart, anims, date, type) {\n\t\t    const callbacks = anims.listeners[type];\n\t\t    const numSteps = anims.duration;\n\t\t    callbacks.forEach(fn => fn({\n\t\t      chart,\n\t\t      initial: anims.initial,\n\t\t      numSteps,\n\t\t      currentStep: Math.min(date - anims.start, numSteps)\n\t\t    }));\n\t\t  }\n\t\t  _refresh() {\n\t\t    if (this._request) {\n\t\t      return;\n\t\t    }\n\t\t    this._running = true;\n\t\t    this._request = requestAnimFrame.call(window, () => {\n\t\t      this._update();\n\t\t      this._request = null;\n\t\t      if (this._running) {\n\t\t        this._refresh();\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  _update(date = Date.now()) {\n\t\t    let remaining = 0;\n\t\t    this._charts.forEach((anims, chart) => {\n\t\t      if (!anims.running || !anims.items.length) {\n\t\t        return;\n\t\t      }\n\t\t      const items = anims.items;\n\t\t      let i = items.length - 1;\n\t\t      let draw = false;\n\t\t      let item;\n\t\t      for (; i >= 0; --i) {\n\t\t        item = items[i];\n\t\t        if (item._active) {\n\t\t          if (item._total > anims.duration) {\n\t\t            anims.duration = item._total;\n\t\t          }\n\t\t          item.tick(date);\n\t\t          draw = true;\n\t\t        } else {\n\t\t          items[i] = items[items.length - 1];\n\t\t          items.pop();\n\t\t        }\n\t\t      }\n\t\t      if (draw) {\n\t\t        chart.draw();\n\t\t        this._notify(chart, anims, date, 'progress');\n\t\t      }\n\t\t      if (!items.length) {\n\t\t        anims.running = false;\n\t\t        this._notify(chart, anims, date, 'complete');\n\t\t        anims.initial = false;\n\t\t      }\n\t\t      remaining += items.length;\n\t\t    });\n\t\t    this._lastDate = date;\n\t\t    if (remaining === 0) {\n\t\t      this._running = false;\n\t\t    }\n\t\t  }\n\t\t  _getAnims(chart) {\n\t\t    const charts = this._charts;\n\t\t    let anims = charts.get(chart);\n\t\t    if (!anims) {\n\t\t      anims = {\n\t\t        running: false,\n\t\t        initial: true,\n\t\t        items: [],\n\t\t        listeners: {\n\t\t          complete: [],\n\t\t          progress: []\n\t\t        }\n\t\t      };\n\t\t      charts.set(chart, anims);\n\t\t    }\n\t\t    return anims;\n\t\t  }\n\t\t  listen(chart, event, cb) {\n\t\t    this._getAnims(chart).listeners[event].push(cb);\n\t\t  }\n\t\t  add(chart, items) {\n\t\t    if (!items || !items.length) {\n\t\t      return;\n\t\t    }\n\t\t    this._getAnims(chart).items.push(...items);\n\t\t  }\n\t\t  has(chart) {\n\t\t    return this._getAnims(chart).items.length > 0;\n\t\t  }\n\t\t  start(chart) {\n\t\t    const anims = this._charts.get(chart);\n\t\t    if (!anims) {\n\t\t      return;\n\t\t    }\n\t\t    anims.running = true;\n\t\t    anims.start = Date.now();\n\t\t    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n\t\t    this._refresh();\n\t\t  }\n\t\t  running(chart) {\n\t\t    if (!this._running) {\n\t\t      return false;\n\t\t    }\n\t\t    const anims = this._charts.get(chart);\n\t\t    if (!anims || !anims.running || !anims.items.length) {\n\t\t      return false;\n\t\t    }\n\t\t    return true;\n\t\t  }\n\t\t  stop(chart) {\n\t\t    const anims = this._charts.get(chart);\n\t\t    if (!anims || !anims.items.length) {\n\t\t      return;\n\t\t    }\n\t\t    const items = anims.items;\n\t\t    let i = items.length - 1;\n\t\t    for (; i >= 0; --i) {\n\t\t      items[i].cancel();\n\t\t    }\n\t\t    anims.items = [];\n\t\t    this._notify(chart, anims, Date.now(), 'complete');\n\t\t  }\n\t\t  remove(chart) {\n\t\t    return this._charts.delete(chart);\n\t\t  }\n\t\t}\n\t\tvar animator = new Animator();\n\n\t\t/*!\n\t\t * @kurkle/color v0.1.9\n\t\t * https://github.com/kurkle/color#readme\n\t\t * (c) 2020 Jukka Kurkela\n\t\t * Released under the MIT License\n\t\t */\n\t\tconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\n\t\tconst hex = '0123456789ABCDEF';\n\t\tconst h1 = (b) => hex[b & 0xF];\n\t\tconst h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\n\t\tconst eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));\n\t\tfunction isShort(v) {\n\t\t\treturn eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\n\t\t}\n\t\tfunction hexParse(str) {\n\t\t\tvar len = str.length;\n\t\t\tvar ret;\n\t\t\tif (str[0] === '#') {\n\t\t\t\tif (len === 4 || len === 5) {\n\t\t\t\t\tret = {\n\t\t\t\t\t\tr: 255 & map$1[str[1]] * 17,\n\t\t\t\t\t\tg: 255 & map$1[str[2]] * 17,\n\t\t\t\t\t\tb: 255 & map$1[str[3]] * 17,\n\t\t\t\t\t\ta: len === 5 ? map$1[str[4]] * 17 : 255\n\t\t\t\t\t};\n\t\t\t\t} else if (len === 7 || len === 9) {\n\t\t\t\t\tret = {\n\t\t\t\t\t\tr: map$1[str[1]] << 4 | map$1[str[2]],\n\t\t\t\t\t\tg: map$1[str[3]] << 4 | map$1[str[4]],\n\t\t\t\t\t\tb: map$1[str[5]] << 4 | map$1[str[6]],\n\t\t\t\t\t\ta: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfunction hexString(v) {\n\t\t\tvar f = isShort(v) ? h1 : h2;\n\t\t\treturn v\n\t\t\t\t? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')\n\t\t\t\t: v;\n\t\t}\n\t\tfunction round(v) {\n\t\t\treturn v + 0.5 | 0;\n\t\t}\n\t\tconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\n\t\tfunction p2b(v) {\n\t\t\treturn lim(round(v * 2.55), 0, 255);\n\t\t}\n\t\tfunction n2b(v) {\n\t\t\treturn lim(round(v * 255), 0, 255);\n\t\t}\n\t\tfunction b2n(v) {\n\t\t\treturn lim(round(v / 2.55) / 100, 0, 1);\n\t\t}\n\t\tfunction n2p(v) {\n\t\t\treturn lim(round(v * 100), 0, 100);\n\t\t}\n\t\tconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n\t\tfunction rgbParse(str) {\n\t\t\tconst m = RGB_RE.exec(str);\n\t\t\tlet a = 255;\n\t\t\tlet r, g, b;\n\t\t\tif (!m) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (m[7] !== r) {\n\t\t\t\tconst v = +m[7];\n\t\t\t\ta = 255 & (m[8] ? p2b(v) : v * 255);\n\t\t\t}\n\t\t\tr = +m[1];\n\t\t\tg = +m[3];\n\t\t\tb = +m[5];\n\t\t\tr = 255 & (m[2] ? p2b(r) : r);\n\t\t\tg = 255 & (m[4] ? p2b(g) : g);\n\t\t\tb = 255 & (m[6] ? p2b(b) : b);\n\t\t\treturn {\n\t\t\t\tr: r,\n\t\t\t\tg: g,\n\t\t\t\tb: b,\n\t\t\t\ta: a\n\t\t\t};\n\t\t}\n\t\tfunction rgbString(v) {\n\t\t\treturn v && (\n\t\t\t\tv.a < 255\n\t\t\t\t\t? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n\t\t\t\t\t: `rgb(${v.r}, ${v.g}, ${v.b})`\n\t\t\t);\n\t\t}\n\t\tconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n\t\tfunction hsl2rgbn(h, s, l) {\n\t\t\tconst a = s * Math.min(l, 1 - l);\n\t\t\tconst f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n\t\t\treturn [f(0), f(8), f(4)];\n\t\t}\n\t\tfunction hsv2rgbn(h, s, v) {\n\t\t\tconst f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n\t\t\treturn [f(5), f(3), f(1)];\n\t\t}\n\t\tfunction hwb2rgbn(h, w, b) {\n\t\t\tconst rgb = hsl2rgbn(h, 1, 0.5);\n\t\t\tlet i;\n\t\t\tif (w + b > 1) {\n\t\t\t\ti = 1 / (w + b);\n\t\t\t\tw *= i;\n\t\t\t\tb *= i;\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\trgb[i] *= 1 - w - b;\n\t\t\t\trgb[i] += w;\n\t\t\t}\n\t\t\treturn rgb;\n\t\t}\n\t\tfunction rgb2hsl(v) {\n\t\t\tconst range = 255;\n\t\t\tconst r = v.r / range;\n\t\t\tconst g = v.g / range;\n\t\t\tconst b = v.b / range;\n\t\t\tconst max = Math.max(r, g, b);\n\t\t\tconst min = Math.min(r, g, b);\n\t\t\tconst l = (max + min) / 2;\n\t\t\tlet h, s, d;\n\t\t\tif (max !== min) {\n\t\t\t\td = max - min;\n\t\t\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\t\t\th = max === r\n\t\t\t\t\t? ((g - b) / d) + (g < b ? 6 : 0)\n\t\t\t\t\t: max === g\n\t\t\t\t\t\t? (b - r) / d + 2\n\t\t\t\t\t\t: (r - g) / d + 4;\n\t\t\t\th = h * 60 + 0.5;\n\t\t\t}\n\t\t\treturn [h | 0, s || 0, l];\n\t\t}\n\t\tfunction calln(f, a, b, c) {\n\t\t\treturn (\n\t\t\t\tArray.isArray(a)\n\t\t\t\t\t? f(a[0], a[1], a[2])\n\t\t\t\t\t: f(a, b, c)\n\t\t\t).map(n2b);\n\t\t}\n\t\tfunction hsl2rgb(h, s, l) {\n\t\t\treturn calln(hsl2rgbn, h, s, l);\n\t\t}\n\t\tfunction hwb2rgb(h, w, b) {\n\t\t\treturn calln(hwb2rgbn, h, w, b);\n\t\t}\n\t\tfunction hsv2rgb(h, s, v) {\n\t\t\treturn calln(hsv2rgbn, h, s, v);\n\t\t}\n\t\tfunction hue(h) {\n\t\t\treturn (h % 360 + 360) % 360;\n\t\t}\n\t\tfunction hueParse(str) {\n\t\t\tconst m = HUE_RE.exec(str);\n\t\t\tlet a = 255;\n\t\t\tlet v;\n\t\t\tif (!m) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (m[5] !== v) {\n\t\t\t\ta = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n\t\t\t}\n\t\t\tconst h = hue(+m[2]);\n\t\t\tconst p1 = +m[3] / 100;\n\t\t\tconst p2 = +m[4] / 100;\n\t\t\tif (m[1] === 'hwb') {\n\t\t\t\tv = hwb2rgb(h, p1, p2);\n\t\t\t} else if (m[1] === 'hsv') {\n\t\t\t\tv = hsv2rgb(h, p1, p2);\n\t\t\t} else {\n\t\t\t\tv = hsl2rgb(h, p1, p2);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tr: v[0],\n\t\t\t\tg: v[1],\n\t\t\t\tb: v[2],\n\t\t\t\ta: a\n\t\t\t};\n\t\t}\n\t\tfunction rotate(v, deg) {\n\t\t\tvar h = rgb2hsl(v);\n\t\t\th[0] = hue(h[0] + deg);\n\t\t\th = hsl2rgb(h);\n\t\t\tv.r = h[0];\n\t\t\tv.g = h[1];\n\t\t\tv.b = h[2];\n\t\t}\n\t\tfunction hslString(v) {\n\t\t\tif (!v) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst a = rgb2hsl(v);\n\t\t\tconst h = a[0];\n\t\t\tconst s = n2p(a[1]);\n\t\t\tconst l = n2p(a[2]);\n\t\t\treturn v.a < 255\n\t\t\t\t? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n\t\t\t\t: `hsl(${h}, ${s}%, ${l}%)`;\n\t\t}\n\t\tconst map$1$1 = {\n\t\t\tx: 'dark',\n\t\t\tZ: 'light',\n\t\t\tY: 're',\n\t\t\tX: 'blu',\n\t\t\tW: 'gr',\n\t\t\tV: 'medium',\n\t\t\tU: 'slate',\n\t\t\tA: 'ee',\n\t\t\tT: 'ol',\n\t\t\tS: 'or',\n\t\t\tB: 'ra',\n\t\t\tC: 'lateg',\n\t\t\tD: 'ights',\n\t\t\tR: 'in',\n\t\t\tQ: 'turquois',\n\t\t\tE: 'hi',\n\t\t\tP: 'ro',\n\t\t\tO: 'al',\n\t\t\tN: 'le',\n\t\t\tM: 'de',\n\t\t\tL: 'yello',\n\t\t\tF: 'en',\n\t\t\tK: 'ch',\n\t\t\tG: 'arks',\n\t\t\tH: 'ea',\n\t\t\tI: 'ightg',\n\t\t\tJ: 'wh'\n\t\t};\n\t\tconst names = {\n\t\t\tOiceXe: 'f0f8ff',\n\t\t\tantiquewEte: 'faebd7',\n\t\t\taqua: 'ffff',\n\t\t\taquamarRe: '7fffd4',\n\t\t\tazuY: 'f0ffff',\n\t\t\tbeige: 'f5f5dc',\n\t\t\tbisque: 'ffe4c4',\n\t\t\tblack: '0',\n\t\t\tblanKedOmond: 'ffebcd',\n\t\t\tXe: 'ff',\n\t\t\tXeviTet: '8a2be2',\n\t\t\tbPwn: 'a52a2a',\n\t\t\tburlywood: 'deb887',\n\t\t\tcaMtXe: '5f9ea0',\n\t\t\tKartYuse: '7fff00',\n\t\t\tKocTate: 'd2691e',\n\t\t\tcSO: 'ff7f50',\n\t\t\tcSnflowerXe: '6495ed',\n\t\t\tcSnsilk: 'fff8dc',\n\t\t\tcrimson: 'dc143c',\n\t\t\tcyan: 'ffff',\n\t\t\txXe: '8b',\n\t\t\txcyan: '8b8b',\n\t\t\txgTMnPd: 'b8860b',\n\t\t\txWay: 'a9a9a9',\n\t\t\txgYF: '6400',\n\t\t\txgYy: 'a9a9a9',\n\t\t\txkhaki: 'bdb76b',\n\t\t\txmagFta: '8b008b',\n\t\t\txTivegYF: '556b2f',\n\t\t\txSange: 'ff8c00',\n\t\t\txScEd: '9932cc',\n\t\t\txYd: '8b0000',\n\t\t\txsOmon: 'e9967a',\n\t\t\txsHgYF: '8fbc8f',\n\t\t\txUXe: '483d8b',\n\t\t\txUWay: '2f4f4f',\n\t\t\txUgYy: '2f4f4f',\n\t\t\txQe: 'ced1',\n\t\t\txviTet: '9400d3',\n\t\t\tdAppRk: 'ff1493',\n\t\t\tdApskyXe: 'bfff',\n\t\t\tdimWay: '696969',\n\t\t\tdimgYy: '696969',\n\t\t\tdodgerXe: '1e90ff',\n\t\t\tfiYbrick: 'b22222',\n\t\t\tflSOwEte: 'fffaf0',\n\t\t\tfoYstWAn: '228b22',\n\t\t\tfuKsia: 'ff00ff',\n\t\t\tgaRsbSo: 'dcdcdc',\n\t\t\tghostwEte: 'f8f8ff',\n\t\t\tgTd: 'ffd700',\n\t\t\tgTMnPd: 'daa520',\n\t\t\tWay: '808080',\n\t\t\tgYF: '8000',\n\t\t\tgYFLw: 'adff2f',\n\t\t\tgYy: '808080',\n\t\t\thoneyMw: 'f0fff0',\n\t\t\thotpRk: 'ff69b4',\n\t\t\tRdianYd: 'cd5c5c',\n\t\t\tRdigo: '4b0082',\n\t\t\tivSy: 'fffff0',\n\t\t\tkhaki: 'f0e68c',\n\t\t\tlavFMr: 'e6e6fa',\n\t\t\tlavFMrXsh: 'fff0f5',\n\t\t\tlawngYF: '7cfc00',\n\t\t\tNmoncEffon: 'fffacd',\n\t\t\tZXe: 'add8e6',\n\t\t\tZcSO: 'f08080',\n\t\t\tZcyan: 'e0ffff',\n\t\t\tZgTMnPdLw: 'fafad2',\n\t\t\tZWay: 'd3d3d3',\n\t\t\tZgYF: '90ee90',\n\t\t\tZgYy: 'd3d3d3',\n\t\t\tZpRk: 'ffb6c1',\n\t\t\tZsOmon: 'ffa07a',\n\t\t\tZsHgYF: '20b2aa',\n\t\t\tZskyXe: '87cefa',\n\t\t\tZUWay: '778899',\n\t\t\tZUgYy: '778899',\n\t\t\tZstAlXe: 'b0c4de',\n\t\t\tZLw: 'ffffe0',\n\t\t\tlime: 'ff00',\n\t\t\tlimegYF: '32cd32',\n\t\t\tlRF: 'faf0e6',\n\t\t\tmagFta: 'ff00ff',\n\t\t\tmaPon: '800000',\n\t\t\tVaquamarRe: '66cdaa',\n\t\t\tVXe: 'cd',\n\t\t\tVScEd: 'ba55d3',\n\t\t\tVpurpN: '9370db',\n\t\t\tVsHgYF: '3cb371',\n\t\t\tVUXe: '7b68ee',\n\t\t\tVsprRggYF: 'fa9a',\n\t\t\tVQe: '48d1cc',\n\t\t\tVviTetYd: 'c71585',\n\t\t\tmidnightXe: '191970',\n\t\t\tmRtcYam: 'f5fffa',\n\t\t\tmistyPse: 'ffe4e1',\n\t\t\tmoccasR: 'ffe4b5',\n\t\t\tnavajowEte: 'ffdead',\n\t\t\tnavy: '80',\n\t\t\tTdlace: 'fdf5e6',\n\t\t\tTive: '808000',\n\t\t\tTivedBb: '6b8e23',\n\t\t\tSange: 'ffa500',\n\t\t\tSangeYd: 'ff4500',\n\t\t\tScEd: 'da70d6',\n\t\t\tpOegTMnPd: 'eee8aa',\n\t\t\tpOegYF: '98fb98',\n\t\t\tpOeQe: 'afeeee',\n\t\t\tpOeviTetYd: 'db7093',\n\t\t\tpapayawEp: 'ffefd5',\n\t\t\tpHKpuff: 'ffdab9',\n\t\t\tperu: 'cd853f',\n\t\t\tpRk: 'ffc0cb',\n\t\t\tplum: 'dda0dd',\n\t\t\tpowMrXe: 'b0e0e6',\n\t\t\tpurpN: '800080',\n\t\t\tYbeccapurpN: '663399',\n\t\t\tYd: 'ff0000',\n\t\t\tPsybrown: 'bc8f8f',\n\t\t\tPyOXe: '4169e1',\n\t\t\tsaddNbPwn: '8b4513',\n\t\t\tsOmon: 'fa8072',\n\t\t\tsandybPwn: 'f4a460',\n\t\t\tsHgYF: '2e8b57',\n\t\t\tsHshell: 'fff5ee',\n\t\t\tsiFna: 'a0522d',\n\t\t\tsilver: 'c0c0c0',\n\t\t\tskyXe: '87ceeb',\n\t\t\tUXe: '6a5acd',\n\t\t\tUWay: '708090',\n\t\t\tUgYy: '708090',\n\t\t\tsnow: 'fffafa',\n\t\t\tsprRggYF: 'ff7f',\n\t\t\tstAlXe: '4682b4',\n\t\t\ttan: 'd2b48c',\n\t\t\tteO: '8080',\n\t\t\ttEstN: 'd8bfd8',\n\t\t\ttomato: 'ff6347',\n\t\t\tQe: '40e0d0',\n\t\t\tviTet: 'ee82ee',\n\t\t\tJHt: 'f5deb3',\n\t\t\twEte: 'ffffff',\n\t\t\twEtesmoke: 'f5f5f5',\n\t\t\tLw: 'ffff00',\n\t\t\tLwgYF: '9acd32'\n\t\t};\n\t\tfunction unpack() {\n\t\t\tconst unpacked = {};\n\t\t\tconst keys = Object.keys(names);\n\t\t\tconst tkeys = Object.keys(map$1$1);\n\t\t\tlet i, j, k, ok, nk;\n\t\t\tfor (i = 0; i < keys.length; i++) {\n\t\t\t\tok = nk = keys[i];\n\t\t\t\tfor (j = 0; j < tkeys.length; j++) {\n\t\t\t\t\tk = tkeys[j];\n\t\t\t\t\tnk = nk.replace(k, map$1$1[k]);\n\t\t\t\t}\n\t\t\t\tk = parseInt(names[ok], 16);\n\t\t\t\tunpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n\t\t\t}\n\t\t\treturn unpacked;\n\t\t}\n\t\tlet names$1;\n\t\tfunction nameParse(str) {\n\t\t\tif (!names$1) {\n\t\t\t\tnames$1 = unpack();\n\t\t\t\tnames$1.transparent = [0, 0, 0, 0];\n\t\t\t}\n\t\t\tconst a = names$1[str.toLowerCase()];\n\t\t\treturn a && {\n\t\t\t\tr: a[0],\n\t\t\t\tg: a[1],\n\t\t\t\tb: a[2],\n\t\t\t\ta: a.length === 4 ? a[3] : 255\n\t\t\t};\n\t\t}\n\t\tfunction modHSL(v, i, ratio) {\n\t\t\tif (v) {\n\t\t\t\tlet tmp = rgb2hsl(v);\n\t\t\t\ttmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n\t\t\t\ttmp = hsl2rgb(tmp);\n\t\t\t\tv.r = tmp[0];\n\t\t\t\tv.g = tmp[1];\n\t\t\t\tv.b = tmp[2];\n\t\t\t}\n\t\t}\n\t\tfunction clone$1(v, proto) {\n\t\t\treturn v ? Object.assign(proto || {}, v) : v;\n\t\t}\n\t\tfunction fromObject(input) {\n\t\t\tvar v = {r: 0, g: 0, b: 0, a: 255};\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tif (input.length >= 3) {\n\t\t\t\t\tv = {r: input[0], g: input[1], b: input[2], a: 255};\n\t\t\t\t\tif (input.length > 3) {\n\t\t\t\t\t\tv.a = n2b(input[3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tv = clone$1(input, {r: 0, g: 0, b: 0, a: 1});\n\t\t\t\tv.a = n2b(v.a);\n\t\t\t}\n\t\t\treturn v;\n\t\t}\n\t\tfunction functionParse(str) {\n\t\t\tif (str.charAt(0) === 'r') {\n\t\t\t\treturn rgbParse(str);\n\t\t\t}\n\t\t\treturn hueParse(str);\n\t\t}\n\t\tclass Color {\n\t\t\tconstructor(input) {\n\t\t\t\tif (input instanceof Color) {\n\t\t\t\t\treturn input;\n\t\t\t\t}\n\t\t\t\tconst type = typeof input;\n\t\t\t\tlet v;\n\t\t\t\tif (type === 'object') {\n\t\t\t\t\tv = fromObject(input);\n\t\t\t\t} else if (type === 'string') {\n\t\t\t\t\tv = hexParse(input) || nameParse(input) || functionParse(input);\n\t\t\t\t}\n\t\t\t\tthis._rgb = v;\n\t\t\t\tthis._valid = !!v;\n\t\t\t}\n\t\t\tget valid() {\n\t\t\t\treturn this._valid;\n\t\t\t}\n\t\t\tget rgb() {\n\t\t\t\tvar v = clone$1(this._rgb);\n\t\t\t\tif (v) {\n\t\t\t\t\tv.a = b2n(v.a);\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tset rgb(obj) {\n\t\t\t\tthis._rgb = fromObject(obj);\n\t\t\t}\n\t\t\trgbString() {\n\t\t\t\treturn this._valid ? rgbString(this._rgb) : this._rgb;\n\t\t\t}\n\t\t\thexString() {\n\t\t\t\treturn this._valid ? hexString(this._rgb) : this._rgb;\n\t\t\t}\n\t\t\thslString() {\n\t\t\t\treturn this._valid ? hslString(this._rgb) : this._rgb;\n\t\t\t}\n\t\t\tmix(color, weight) {\n\t\t\t\tconst me = this;\n\t\t\t\tif (color) {\n\t\t\t\t\tconst c1 = me.rgb;\n\t\t\t\t\tconst c2 = color.rgb;\n\t\t\t\t\tlet w2;\n\t\t\t\t\tconst p = weight === w2 ? 0.5 : weight;\n\t\t\t\t\tconst w = 2 * p - 1;\n\t\t\t\t\tconst a = c1.a - c2.a;\n\t\t\t\t\tconst w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\t\t\t\tw2 = 1 - w1;\n\t\t\t\t\tc1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n\t\t\t\t\tc1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n\t\t\t\t\tc1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n\t\t\t\t\tc1.a = p * c1.a + (1 - p) * c2.a;\n\t\t\t\t\tme.rgb = c1;\n\t\t\t\t}\n\t\t\t\treturn me;\n\t\t\t}\n\t\t\tclone() {\n\t\t\t\treturn new Color(this.rgb);\n\t\t\t}\n\t\t\talpha(a) {\n\t\t\t\tthis._rgb.a = n2b(a);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tclearer(ratio) {\n\t\t\t\tconst rgb = this._rgb;\n\t\t\t\trgb.a *= 1 - ratio;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tgreyscale() {\n\t\t\t\tconst rgb = this._rgb;\n\t\t\t\tconst val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n\t\t\t\trgb.r = rgb.g = rgb.b = val;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\topaquer(ratio) {\n\t\t\t\tconst rgb = this._rgb;\n\t\t\t\trgb.a *= 1 + ratio;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tnegate() {\n\t\t\t\tconst v = this._rgb;\n\t\t\t\tv.r = 255 - v.r;\n\t\t\t\tv.g = 255 - v.g;\n\t\t\t\tv.b = 255 - v.b;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tlighten(ratio) {\n\t\t\t\tmodHSL(this._rgb, 2, ratio);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tdarken(ratio) {\n\t\t\t\tmodHSL(this._rgb, 2, -ratio);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tsaturate(ratio) {\n\t\t\t\tmodHSL(this._rgb, 1, ratio);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tdesaturate(ratio) {\n\t\t\t\tmodHSL(this._rgb, 1, -ratio);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\trotate(deg) {\n\t\t\t\trotate(this._rgb, deg);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tfunction index_esm(input) {\n\t\t\treturn new Color(input);\n\t\t}\n\n\t\tconst isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;\n\t\tfunction color(value) {\n\t\t  return isPatternOrGradient(value) ? value : index_esm(value);\n\t\t}\n\t\tfunction getHoverColor(value) {\n\t\t  return isPatternOrGradient(value)\n\t\t    ? value\n\t\t    : index_esm(value).saturate(0.5).darken(0.1).hexString();\n\t\t}\n\n\t\tfunction noop() {}\n\t\tconst uid = (function() {\n\t\t  let id = 0;\n\t\t  return function() {\n\t\t    return id++;\n\t\t  };\n\t\t}());\n\t\tfunction isNullOrUndef(value) {\n\t\t  return value === null || typeof value === 'undefined';\n\t\t}\n\t\tfunction isArray(value) {\n\t\t  if (Array.isArray && Array.isArray(value)) {\n\t\t    return true;\n\t\t  }\n\t\t  const type = Object.prototype.toString.call(value);\n\t\t  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n\t\t    return true;\n\t\t  }\n\t\t  return false;\n\t\t}\n\t\tfunction isObject(value) {\n\t\t  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n\t\t}\n\t\tconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n\t\tfunction finiteOrDefault(value, defaultValue) {\n\t\t  return isNumberFinite(value) ? value : defaultValue;\n\t\t}\n\t\tfunction valueOrDefault(value, defaultValue) {\n\t\t  return typeof value === 'undefined' ? defaultValue : value;\n\t\t}\n\t\tconst toPercentage = (value, dimension) =>\n\t\t  typeof value === 'string' && value.endsWith('%') ?\n\t\t    parseFloat(value) / 100\n\t\t    : value / dimension;\n\t\tconst toDimension = (value, dimension) =>\n\t\t  typeof value === 'string' && value.endsWith('%') ?\n\t\t    parseFloat(value) / 100 * dimension\n\t\t    : +value;\n\t\tfunction callback(fn, args, thisArg) {\n\t\t  if (fn && typeof fn.call === 'function') {\n\t\t    return fn.apply(thisArg, args);\n\t\t  }\n\t\t}\n\t\tfunction each(loopable, fn, thisArg, reverse) {\n\t\t  let i, len, keys;\n\t\t  if (isArray(loopable)) {\n\t\t    len = loopable.length;\n\t\t    if (reverse) {\n\t\t      for (i = len - 1; i >= 0; i--) {\n\t\t        fn.call(thisArg, loopable[i], i);\n\t\t      }\n\t\t    } else {\n\t\t      for (i = 0; i < len; i++) {\n\t\t        fn.call(thisArg, loopable[i], i);\n\t\t      }\n\t\t    }\n\t\t  } else if (isObject(loopable)) {\n\t\t    keys = Object.keys(loopable);\n\t\t    len = keys.length;\n\t\t    for (i = 0; i < len; i++) {\n\t\t      fn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction _elementsEqual(a0, a1) {\n\t\t  let i, ilen, v0, v1;\n\t\t  if (!a0 || !a1 || a0.length !== a1.length) {\n\t\t    return false;\n\t\t  }\n\t\t  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t    v0 = a0[i];\n\t\t    v1 = a1[i];\n\t\t    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n\t\t      return false;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\tfunction clone(source) {\n\t\t  if (isArray(source)) {\n\t\t    return source.map(clone);\n\t\t  }\n\t\t  if (isObject(source)) {\n\t\t    const target = Object.create(null);\n\t\t    const keys = Object.keys(source);\n\t\t    const klen = keys.length;\n\t\t    let k = 0;\n\t\t    for (; k < klen; ++k) {\n\t\t      target[keys[k]] = clone(source[keys[k]]);\n\t\t    }\n\t\t    return target;\n\t\t  }\n\t\t  return source;\n\t\t}\n\t\tfunction isValidKey(key) {\n\t\t  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n\t\t}\n\t\tfunction _merger(key, target, source, options) {\n\t\t  if (!isValidKey(key)) {\n\t\t    return;\n\t\t  }\n\t\t  const tval = target[key];\n\t\t  const sval = source[key];\n\t\t  if (isObject(tval) && isObject(sval)) {\n\t\t    merge(tval, sval, options);\n\t\t  } else {\n\t\t    target[key] = clone(sval);\n\t\t  }\n\t\t}\n\t\tfunction merge(target, source, options) {\n\t\t  const sources = isArray(source) ? source : [source];\n\t\t  const ilen = sources.length;\n\t\t  if (!isObject(target)) {\n\t\t    return target;\n\t\t  }\n\t\t  options = options || {};\n\t\t  const merger = options.merger || _merger;\n\t\t  for (let i = 0; i < ilen; ++i) {\n\t\t    source = sources[i];\n\t\t    if (!isObject(source)) {\n\t\t      continue;\n\t\t    }\n\t\t    const keys = Object.keys(source);\n\t\t    for (let k = 0, klen = keys.length; k < klen; ++k) {\n\t\t      merger(keys[k], target, source, options);\n\t\t    }\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\tfunction mergeIf(target, source) {\n\t\t  return merge(target, source, {merger: _mergerIf});\n\t\t}\n\t\tfunction _mergerIf(key, target, source) {\n\t\t  if (!isValidKey(key)) {\n\t\t    return;\n\t\t  }\n\t\t  const tval = target[key];\n\t\t  const sval = source[key];\n\t\t  if (isObject(tval) && isObject(sval)) {\n\t\t    mergeIf(tval, sval);\n\t\t  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t    target[key] = clone(sval);\n\t\t  }\n\t\t}\n\t\tfunction _deprecated(scope, value, previous, current) {\n\t\t  if (value !== undefined) {\n\t\t    console.warn(scope + ': \"' + previous +\n\t\t\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n\t\t  }\n\t\t}\n\t\tconst emptyString = '';\n\t\tconst dot = '.';\n\t\tfunction indexOfDotOrLength(key, start) {\n\t\t  const idx = key.indexOf(dot, start);\n\t\t  return idx === -1 ? key.length : idx;\n\t\t}\n\t\tfunction resolveObjectKey(obj, key) {\n\t\t  if (key === emptyString) {\n\t\t    return obj;\n\t\t  }\n\t\t  let pos = 0;\n\t\t  let idx = indexOfDotOrLength(key, pos);\n\t\t  while (obj && idx > pos) {\n\t\t    obj = obj[key.substr(pos, idx - pos)];\n\t\t    pos = idx + 1;\n\t\t    idx = indexOfDotOrLength(key, pos);\n\t\t  }\n\t\t  return obj;\n\t\t}\n\t\tfunction _capitalize(str) {\n\t\t  return str.charAt(0).toUpperCase() + str.slice(1);\n\t\t}\n\t\tconst defined = (value) => typeof value !== 'undefined';\n\t\tconst isFunction = (value) => typeof value === 'function';\n\t\tconst setsEqual = (a, b) => {\n\t\t  if (a.size !== b.size) {\n\t\t    return false;\n\t\t  }\n\t\t  for (const item of a) {\n\t\t    if (!b.has(item)) {\n\t\t      return false;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t};\n\t\tfunction _isClickEvent(e) {\n\t\t  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n\t\t}\n\n\t\tconst overrides = Object.create(null);\n\t\tconst descriptors = Object.create(null);\n\t\tfunction getScope$1(node, key) {\n\t\t  if (!key) {\n\t\t    return node;\n\t\t  }\n\t\t  const keys = key.split('.');\n\t\t  for (let i = 0, n = keys.length; i < n; ++i) {\n\t\t    const k = keys[i];\n\t\t    node = node[k] || (node[k] = Object.create(null));\n\t\t  }\n\t\t  return node;\n\t\t}\n\t\tfunction set(root, scope, values) {\n\t\t  if (typeof scope === 'string') {\n\t\t    return merge(getScope$1(root, scope), values);\n\t\t  }\n\t\t  return merge(getScope$1(root, ''), scope);\n\t\t}\n\t\tclass Defaults {\n\t\t  constructor(_descriptors) {\n\t\t    this.animation = undefined;\n\t\t    this.backgroundColor = 'rgba(0,0,0,0.1)';\n\t\t    this.borderColor = 'rgba(0,0,0,0.1)';\n\t\t    this.color = '#666';\n\t\t    this.datasets = {};\n\t\t    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n\t\t    this.elements = {};\n\t\t    this.events = [\n\t\t      'mousemove',\n\t\t      'mouseout',\n\t\t      'click',\n\t\t      'touchstart',\n\t\t      'touchmove'\n\t\t    ];\n\t\t    this.font = {\n\t\t      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\t      size: 12,\n\t\t      style: 'normal',\n\t\t      lineHeight: 1.2,\n\t\t      weight: null\n\t\t    };\n\t\t    this.hover = {};\n\t\t    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n\t\t    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n\t\t    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n\t\t    this.indexAxis = 'x';\n\t\t    this.interaction = {\n\t\t      mode: 'nearest',\n\t\t      intersect: true\n\t\t    };\n\t\t    this.maintainAspectRatio = true;\n\t\t    this.onHover = null;\n\t\t    this.onClick = null;\n\t\t    this.parsing = true;\n\t\t    this.plugins = {};\n\t\t    this.responsive = true;\n\t\t    this.scale = undefined;\n\t\t    this.scales = {};\n\t\t    this.showLine = true;\n\t\t    this.drawActiveElementsOnTop = true;\n\t\t    this.describe(_descriptors);\n\t\t  }\n\t\t  set(scope, values) {\n\t\t    return set(this, scope, values);\n\t\t  }\n\t\t  get(scope) {\n\t\t    return getScope$1(this, scope);\n\t\t  }\n\t\t  describe(scope, values) {\n\t\t    return set(descriptors, scope, values);\n\t\t  }\n\t\t  override(scope, values) {\n\t\t    return set(overrides, scope, values);\n\t\t  }\n\t\t  route(scope, name, targetScope, targetName) {\n\t\t    const scopeObject = getScope$1(this, scope);\n\t\t    const targetScopeObject = getScope$1(this, targetScope);\n\t\t    const privateName = '_' + name;\n\t\t    Object.defineProperties(scopeObject, {\n\t\t      [privateName]: {\n\t\t        value: scopeObject[name],\n\t\t        writable: true\n\t\t      },\n\t\t      [name]: {\n\t\t        enumerable: true,\n\t\t        get() {\n\t\t          const local = this[privateName];\n\t\t          const target = targetScopeObject[targetName];\n\t\t          if (isObject(local)) {\n\t\t            return Object.assign({}, target, local);\n\t\t          }\n\t\t          return valueOrDefault(local, target);\n\t\t        },\n\t\t        set(value) {\n\t\t          this[privateName] = value;\n\t\t        }\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t}\n\t\tvar defaults = new Defaults({\n\t\t  _scriptable: (name) => !name.startsWith('on'),\n\t\t  _indexable: (name) => name !== 'events',\n\t\t  hover: {\n\t\t    _fallback: 'interaction'\n\t\t  },\n\t\t  interaction: {\n\t\t    _scriptable: false,\n\t\t    _indexable: false,\n\t\t  }\n\t\t});\n\n\t\tconst PI = Math.PI;\n\t\tconst TAU = 2 * PI;\n\t\tconst PITAU = TAU + PI;\n\t\tconst INFINITY = Number.POSITIVE_INFINITY;\n\t\tconst RAD_PER_DEG = PI / 180;\n\t\tconst HALF_PI = PI / 2;\n\t\tconst QUARTER_PI = PI / 4;\n\t\tconst TWO_THIRDS_PI = PI * 2 / 3;\n\t\tconst log10 = Math.log10;\n\t\tconst sign = Math.sign;\n\t\tfunction niceNum(range) {\n\t\t  const roundedRange = Math.round(range);\n\t\t  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n\t\t  const niceRange = Math.pow(10, Math.floor(log10(range)));\n\t\t  const fraction = range / niceRange;\n\t\t  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n\t\t  return niceFraction * niceRange;\n\t\t}\n\t\tfunction _factorize(value) {\n\t\t  const result = [];\n\t\t  const sqrt = Math.sqrt(value);\n\t\t  let i;\n\t\t  for (i = 1; i < sqrt; i++) {\n\t\t    if (value % i === 0) {\n\t\t      result.push(i);\n\t\t      result.push(value / i);\n\t\t    }\n\t\t  }\n\t\t  if (sqrt === (sqrt | 0)) {\n\t\t    result.push(sqrt);\n\t\t  }\n\t\t  result.sort((a, b) => a - b).pop();\n\t\t  return result;\n\t\t}\n\t\tfunction isNumber(n) {\n\t\t  return !isNaN(parseFloat(n)) && isFinite(n);\n\t\t}\n\t\tfunction almostEquals(x, y, epsilon) {\n\t\t  return Math.abs(x - y) < epsilon;\n\t\t}\n\t\tfunction almostWhole(x, epsilon) {\n\t\t  const rounded = Math.round(x);\n\t\t  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n\t\t}\n\t\tfunction _setMinAndMaxByKey(array, target, property) {\n\t\t  let i, ilen, value;\n\t\t  for (i = 0, ilen = array.length; i < ilen; i++) {\n\t\t    value = array[i][property];\n\t\t    if (!isNaN(value)) {\n\t\t      target.min = Math.min(target.min, value);\n\t\t      target.max = Math.max(target.max, value);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction toRadians(degrees) {\n\t\t  return degrees * (PI / 180);\n\t\t}\n\t\tfunction toDegrees(radians) {\n\t\t  return radians * (180 / PI);\n\t\t}\n\t\tfunction _decimalPlaces(x) {\n\t\t  if (!isNumberFinite(x)) {\n\t\t    return;\n\t\t  }\n\t\t  let e = 1;\n\t\t  let p = 0;\n\t\t  while (Math.round(x * e) / e !== x) {\n\t\t    e *= 10;\n\t\t    p++;\n\t\t  }\n\t\t  return p;\n\t\t}\n\t\tfunction getAngleFromPoint(centrePoint, anglePoint) {\n\t\t  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n\t\t  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n\t\t  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\t\t  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\t\t  if (angle < (-0.5 * PI)) {\n\t\t    angle += TAU;\n\t\t  }\n\t\t  return {\n\t\t    angle,\n\t\t    distance: radialDistanceFromCenter\n\t\t  };\n\t\t}\n\t\tfunction distanceBetweenPoints(pt1, pt2) {\n\t\t  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t\t}\n\t\tfunction _angleDiff(a, b) {\n\t\t  return (a - b + PITAU) % TAU - PI;\n\t\t}\n\t\tfunction _normalizeAngle(a) {\n\t\t  return (a % TAU + TAU) % TAU;\n\t\t}\n\t\tfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n\t\t  const a = _normalizeAngle(angle);\n\t\t  const s = _normalizeAngle(start);\n\t\t  const e = _normalizeAngle(end);\n\t\t  const angleToStart = _normalizeAngle(s - a);\n\t\t  const angleToEnd = _normalizeAngle(e - a);\n\t\t  const startToAngle = _normalizeAngle(a - s);\n\t\t  const endToAngle = _normalizeAngle(a - e);\n\t\t  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n\t\t    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n\t\t}\n\t\tfunction _limitValue(value, min, max) {\n\t\t  return Math.max(min, Math.min(max, value));\n\t\t}\n\t\tfunction _int16Range(value) {\n\t\t  return _limitValue(value, -32768, 32767);\n\t\t}\n\t\tfunction _isBetween(value, start, end, epsilon = 1e-6) {\n\t\t  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n\t\t}\n\n\t\tfunction toFontString(font) {\n\t\t  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n\t\t    return null;\n\t\t  }\n\t\t  return (font.style ? font.style + ' ' : '')\n\t\t\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t\t\t+ font.size + 'px '\n\t\t\t\t+ font.family;\n\t\t}\n\t\tfunction _measureText(ctx, data, gc, longest, string) {\n\t\t  let textWidth = data[string];\n\t\t  if (!textWidth) {\n\t\t    textWidth = data[string] = ctx.measureText(string).width;\n\t\t    gc.push(string);\n\t\t  }\n\t\t  if (textWidth > longest) {\n\t\t    longest = textWidth;\n\t\t  }\n\t\t  return longest;\n\t\t}\n\t\tfunction _longestText(ctx, font, arrayOfThings, cache) {\n\t\t  cache = cache || {};\n\t\t  let data = cache.data = cache.data || {};\n\t\t  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\t\t  if (cache.font !== font) {\n\t\t    data = cache.data = {};\n\t\t    gc = cache.garbageCollect = [];\n\t\t    cache.font = font;\n\t\t  }\n\t\t  ctx.save();\n\t\t  ctx.font = font;\n\t\t  let longest = 0;\n\t\t  const ilen = arrayOfThings.length;\n\t\t  let i, j, jlen, thing, nestedThing;\n\t\t  for (i = 0; i < ilen; i++) {\n\t\t    thing = arrayOfThings[i];\n\t\t    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n\t\t      longest = _measureText(ctx, data, gc, longest, thing);\n\t\t    } else if (isArray(thing)) {\n\t\t      for (j = 0, jlen = thing.length; j < jlen; j++) {\n\t\t        nestedThing = thing[j];\n\t\t        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n\t\t          longest = _measureText(ctx, data, gc, longest, nestedThing);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  ctx.restore();\n\t\t  const gcLen = gc.length / 2;\n\t\t  if (gcLen > arrayOfThings.length) {\n\t\t    for (i = 0; i < gcLen; i++) {\n\t\t      delete data[gc[i]];\n\t\t    }\n\t\t    gc.splice(0, gcLen);\n\t\t  }\n\t\t  return longest;\n\t\t}\n\t\tfunction _alignPixel(chart, pixel, width) {\n\t\t  const devicePixelRatio = chart.currentDevicePixelRatio;\n\t\t  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n\t\t  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n\t\t}\n\t\tfunction clearCanvas(canvas, ctx) {\n\t\t  ctx = ctx || canvas.getContext('2d');\n\t\t  ctx.save();\n\t\t  ctx.resetTransform();\n\t\t  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t  ctx.restore();\n\t\t}\n\t\tfunction drawPoint(ctx, options, x, y) {\n\t\t  let type, xOffset, yOffset, size, cornerRadius;\n\t\t  const style = options.pointStyle;\n\t\t  const rotation = options.rotation;\n\t\t  const radius = options.radius;\n\t\t  let rad = (rotation || 0) * RAD_PER_DEG;\n\t\t  if (style && typeof style === 'object') {\n\t\t    type = style.toString();\n\t\t    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t      ctx.save();\n\t\t      ctx.translate(x, y);\n\t\t      ctx.rotate(rad);\n\t\t      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n\t\t      ctx.restore();\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t  if (isNaN(radius) || radius <= 0) {\n\t\t    return;\n\t\t  }\n\t\t  ctx.beginPath();\n\t\t  switch (style) {\n\t\t  default:\n\t\t    ctx.arc(x, y, radius, 0, TAU);\n\t\t    ctx.closePath();\n\t\t    break;\n\t\t  case 'triangle':\n\t\t    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t    rad += TWO_THIRDS_PI;\n\t\t    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t    rad += TWO_THIRDS_PI;\n\t\t    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t    ctx.closePath();\n\t\t    break;\n\t\t  case 'rectRounded':\n\t\t    cornerRadius = radius * 0.516;\n\t\t    size = radius - cornerRadius;\n\t\t    xOffset = Math.cos(rad + QUARTER_PI) * size;\n\t\t    yOffset = Math.sin(rad + QUARTER_PI) * size;\n\t\t    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n\t\t    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n\t\t    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n\t\t    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n\t\t    ctx.closePath();\n\t\t    break;\n\t\t  case 'rect':\n\t\t    if (!rotation) {\n\t\t      size = Math.SQRT1_2 * radius;\n\t\t      ctx.rect(x - size, y - size, 2 * size, 2 * size);\n\t\t      break;\n\t\t    }\n\t\t    rad += QUARTER_PI;\n\t\t  case 'rectRot':\n\t\t    xOffset = Math.cos(rad) * radius;\n\t\t    yOffset = Math.sin(rad) * radius;\n\t\t    ctx.moveTo(x - xOffset, y - yOffset);\n\t\t    ctx.lineTo(x + yOffset, y - xOffset);\n\t\t    ctx.lineTo(x + xOffset, y + yOffset);\n\t\t    ctx.lineTo(x - yOffset, y + xOffset);\n\t\t    ctx.closePath();\n\t\t    break;\n\t\t  case 'crossRot':\n\t\t    rad += QUARTER_PI;\n\t\t  case 'cross':\n\t\t    xOffset = Math.cos(rad) * radius;\n\t\t    yOffset = Math.sin(rad) * radius;\n\t\t    ctx.moveTo(x - xOffset, y - yOffset);\n\t\t    ctx.lineTo(x + xOffset, y + yOffset);\n\t\t    ctx.moveTo(x + yOffset, y - xOffset);\n\t\t    ctx.lineTo(x - yOffset, y + xOffset);\n\t\t    break;\n\t\t  case 'star':\n\t\t    xOffset = Math.cos(rad) * radius;\n\t\t    yOffset = Math.sin(rad) * radius;\n\t\t    ctx.moveTo(x - xOffset, y - yOffset);\n\t\t    ctx.lineTo(x + xOffset, y + yOffset);\n\t\t    ctx.moveTo(x + yOffset, y - xOffset);\n\t\t    ctx.lineTo(x - yOffset, y + xOffset);\n\t\t    rad += QUARTER_PI;\n\t\t    xOffset = Math.cos(rad) * radius;\n\t\t    yOffset = Math.sin(rad) * radius;\n\t\t    ctx.moveTo(x - xOffset, y - yOffset);\n\t\t    ctx.lineTo(x + xOffset, y + yOffset);\n\t\t    ctx.moveTo(x + yOffset, y - xOffset);\n\t\t    ctx.lineTo(x - yOffset, y + xOffset);\n\t\t    break;\n\t\t  case 'line':\n\t\t    xOffset = Math.cos(rad) * radius;\n\t\t    yOffset = Math.sin(rad) * radius;\n\t\t    ctx.moveTo(x - xOffset, y - yOffset);\n\t\t    ctx.lineTo(x + xOffset, y + yOffset);\n\t\t    break;\n\t\t  case 'dash':\n\t\t    ctx.moveTo(x, y);\n\t\t    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n\t\t    break;\n\t\t  }\n\t\t  ctx.fill();\n\t\t  if (options.borderWidth > 0) {\n\t\t    ctx.stroke();\n\t\t  }\n\t\t}\n\t\tfunction _isPointInArea(point, area, margin) {\n\t\t  margin = margin || 0.5;\n\t\t  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\t\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n\t\t}\n\t\tfunction clipArea(ctx, area) {\n\t\t  ctx.save();\n\t\t  ctx.beginPath();\n\t\t  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\t\t  ctx.clip();\n\t\t}\n\t\tfunction unclipArea(ctx) {\n\t\t  ctx.restore();\n\t\t}\n\t\tfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n\t\t  if (!previous) {\n\t\t    return ctx.lineTo(target.x, target.y);\n\t\t  }\n\t\t  if (mode === 'middle') {\n\t\t    const midpoint = (previous.x + target.x) / 2.0;\n\t\t    ctx.lineTo(midpoint, previous.y);\n\t\t    ctx.lineTo(midpoint, target.y);\n\t\t  } else if (mode === 'after' !== !!flip) {\n\t\t    ctx.lineTo(previous.x, target.y);\n\t\t  } else {\n\t\t    ctx.lineTo(target.x, previous.y);\n\t\t  }\n\t\t  ctx.lineTo(target.x, target.y);\n\t\t}\n\t\tfunction _bezierCurveTo(ctx, previous, target, flip) {\n\t\t  if (!previous) {\n\t\t    return ctx.lineTo(target.x, target.y);\n\t\t  }\n\t\t  ctx.bezierCurveTo(\n\t\t    flip ? previous.cp1x : previous.cp2x,\n\t\t    flip ? previous.cp1y : previous.cp2y,\n\t\t    flip ? target.cp2x : target.cp1x,\n\t\t    flip ? target.cp2y : target.cp1y,\n\t\t    target.x,\n\t\t    target.y);\n\t\t}\n\t\tfunction renderText(ctx, text, x, y, font, opts = {}) {\n\t\t  const lines = isArray(text) ? text : [text];\n\t\t  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n\t\t  let i, line;\n\t\t  ctx.save();\n\t\t  ctx.font = font.string;\n\t\t  setRenderOpts(ctx, opts);\n\t\t  for (i = 0; i < lines.length; ++i) {\n\t\t    line = lines[i];\n\t\t    if (stroke) {\n\t\t      if (opts.strokeColor) {\n\t\t        ctx.strokeStyle = opts.strokeColor;\n\t\t      }\n\t\t      if (!isNullOrUndef(opts.strokeWidth)) {\n\t\t        ctx.lineWidth = opts.strokeWidth;\n\t\t      }\n\t\t      ctx.strokeText(line, x, y, opts.maxWidth);\n\t\t    }\n\t\t    ctx.fillText(line, x, y, opts.maxWidth);\n\t\t    decorateText(ctx, x, y, line, opts);\n\t\t    y += font.lineHeight;\n\t\t  }\n\t\t  ctx.restore();\n\t\t}\n\t\tfunction setRenderOpts(ctx, opts) {\n\t\t  if (opts.translation) {\n\t\t    ctx.translate(opts.translation[0], opts.translation[1]);\n\t\t  }\n\t\t  if (!isNullOrUndef(opts.rotation)) {\n\t\t    ctx.rotate(opts.rotation);\n\t\t  }\n\t\t  if (opts.color) {\n\t\t    ctx.fillStyle = opts.color;\n\t\t  }\n\t\t  if (opts.textAlign) {\n\t\t    ctx.textAlign = opts.textAlign;\n\t\t  }\n\t\t  if (opts.textBaseline) {\n\t\t    ctx.textBaseline = opts.textBaseline;\n\t\t  }\n\t\t}\n\t\tfunction decorateText(ctx, x, y, line, opts) {\n\t\t  if (opts.strikethrough || opts.underline) {\n\t\t    const metrics = ctx.measureText(line);\n\t\t    const left = x - metrics.actualBoundingBoxLeft;\n\t\t    const right = x + metrics.actualBoundingBoxRight;\n\t\t    const top = y - metrics.actualBoundingBoxAscent;\n\t\t    const bottom = y + metrics.actualBoundingBoxDescent;\n\t\t    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\t\t    ctx.strokeStyle = ctx.fillStyle;\n\t\t    ctx.beginPath();\n\t\t    ctx.lineWidth = opts.decorationWidth || 2;\n\t\t    ctx.moveTo(left, yDecoration);\n\t\t    ctx.lineTo(right, yDecoration);\n\t\t    ctx.stroke();\n\t\t  }\n\t\t}\n\t\tfunction addRoundedRectPath(ctx, rect) {\n\t\t  const {x, y, w, h, radius} = rect;\n\t\t  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n\t\t  ctx.lineTo(x, y + h - radius.bottomLeft);\n\t\t  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\t\t  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\t\t  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\t\t  ctx.lineTo(x + w, y + radius.topRight);\n\t\t  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\t\t  ctx.lineTo(x + radius.topLeft, y);\n\t\t}\n\n\t\tfunction _lookup(table, value, cmp) {\n\t\t  cmp = cmp || ((index) => table[index] < value);\n\t\t  let hi = table.length - 1;\n\t\t  let lo = 0;\n\t\t  let mid;\n\t\t  while (hi - lo > 1) {\n\t\t    mid = (lo + hi) >> 1;\n\t\t    if (cmp(mid)) {\n\t\t      lo = mid;\n\t\t    } else {\n\t\t      hi = mid;\n\t\t    }\n\t\t  }\n\t\t  return {lo, hi};\n\t\t}\n\t\tconst _lookupByKey = (table, key, value) =>\n\t\t  _lookup(table, value, index => table[index][key] < value);\n\t\tconst _rlookupByKey = (table, key, value) =>\n\t\t  _lookup(table, value, index => table[index][key] >= value);\n\t\tfunction _filterBetween(values, min, max) {\n\t\t  let start = 0;\n\t\t  let end = values.length;\n\t\t  while (start < end && values[start] < min) {\n\t\t    start++;\n\t\t  }\n\t\t  while (end > start && values[end - 1] > max) {\n\t\t    end--;\n\t\t  }\n\t\t  return start > 0 || end < values.length\n\t\t    ? values.slice(start, end)\n\t\t    : values;\n\t\t}\n\t\tconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\t\tfunction listenArrayEvents(array, listener) {\n\t\t  if (array._chartjs) {\n\t\t    array._chartjs.listeners.push(listener);\n\t\t    return;\n\t\t  }\n\t\t  Object.defineProperty(array, '_chartjs', {\n\t\t    configurable: true,\n\t\t    enumerable: false,\n\t\t    value: {\n\t\t      listeners: [listener]\n\t\t    }\n\t\t  });\n\t\t  arrayEvents.forEach((key) => {\n\t\t    const method = '_onData' + _capitalize(key);\n\t\t    const base = array[key];\n\t\t    Object.defineProperty(array, key, {\n\t\t      configurable: true,\n\t\t      enumerable: false,\n\t\t      value(...args) {\n\t\t        const res = base.apply(this, args);\n\t\t        array._chartjs.listeners.forEach((object) => {\n\t\t          if (typeof object[method] === 'function') {\n\t\t            object[method](...args);\n\t\t          }\n\t\t        });\n\t\t        return res;\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t}\n\t\tfunction unlistenArrayEvents(array, listener) {\n\t\t  const stub = array._chartjs;\n\t\t  if (!stub) {\n\t\t    return;\n\t\t  }\n\t\t  const listeners = stub.listeners;\n\t\t  const index = listeners.indexOf(listener);\n\t\t  if (index !== -1) {\n\t\t    listeners.splice(index, 1);\n\t\t  }\n\t\t  if (listeners.length > 0) {\n\t\t    return;\n\t\t  }\n\t\t  arrayEvents.forEach((key) => {\n\t\t    delete array[key];\n\t\t  });\n\t\t  delete array._chartjs;\n\t\t}\n\t\tfunction _arrayUnique(items) {\n\t\t  const set = new Set();\n\t\t  let i, ilen;\n\t\t  for (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t    set.add(items[i]);\n\t\t  }\n\t\t  if (set.size === ilen) {\n\t\t    return items;\n\t\t  }\n\t\t  return Array.from(set);\n\t\t}\n\n\t\tfunction _isDomSupported() {\n\t\t  return typeof window !== 'undefined' && typeof document !== 'undefined';\n\t\t}\n\t\tfunction _getParentNode(domNode) {\n\t\t  let parent = domNode.parentNode;\n\t\t  if (parent && parent.toString() === '[object ShadowRoot]') {\n\t\t    parent = parent.host;\n\t\t  }\n\t\t  return parent;\n\t\t}\n\t\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\t  let valueInPixels;\n\t\t  if (typeof styleValue === 'string') {\n\t\t    valueInPixels = parseInt(styleValue, 10);\n\t\t    if (styleValue.indexOf('%') !== -1) {\n\t\t      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t    }\n\t\t  } else {\n\t\t    valueInPixels = styleValue;\n\t\t  }\n\t\t  return valueInPixels;\n\t\t}\n\t\tconst getComputedStyle = (element) => window.getComputedStyle(element, null);\n\t\tfunction getStyle(el, property) {\n\t\t  return getComputedStyle(el).getPropertyValue(property);\n\t\t}\n\t\tconst positions = ['top', 'right', 'bottom', 'left'];\n\t\tfunction getPositionedStyle(styles, style, suffix) {\n\t\t  const result = {};\n\t\t  suffix = suffix ? '-' + suffix : '';\n\t\t  for (let i = 0; i < 4; i++) {\n\t\t    const pos = positions[i];\n\t\t    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n\t\t  }\n\t\t  result.width = result.left + result.right;\n\t\t  result.height = result.top + result.bottom;\n\t\t  return result;\n\t\t}\n\t\tconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\n\t\tfunction getCanvasPosition(evt, canvas) {\n\t\t  const e = evt.native || evt;\n\t\t  const touches = e.touches;\n\t\t  const source = touches && touches.length ? touches[0] : e;\n\t\t  const {offsetX, offsetY} = source;\n\t\t  let box = false;\n\t\t  let x, y;\n\t\t  if (useOffsetPos(offsetX, offsetY, e.target)) {\n\t\t    x = offsetX;\n\t\t    y = offsetY;\n\t\t  } else {\n\t\t    const rect = canvas.getBoundingClientRect();\n\t\t    x = source.clientX - rect.left;\n\t\t    y = source.clientY - rect.top;\n\t\t    box = true;\n\t\t  }\n\t\t  return {x, y, box};\n\t\t}\n\t\tfunction getRelativePosition$1(evt, chart) {\n\t\t  const {canvas, currentDevicePixelRatio} = chart;\n\t\t  const style = getComputedStyle(canvas);\n\t\t  const borderBox = style.boxSizing === 'border-box';\n\t\t  const paddings = getPositionedStyle(style, 'padding');\n\t\t  const borders = getPositionedStyle(style, 'border', 'width');\n\t\t  const {x, y, box} = getCanvasPosition(evt, canvas);\n\t\t  const xOffset = paddings.left + (box && borders.left);\n\t\t  const yOffset = paddings.top + (box && borders.top);\n\t\t  let {width, height} = chart;\n\t\t  if (borderBox) {\n\t\t    width -= paddings.width + borders.width;\n\t\t    height -= paddings.height + borders.height;\n\t\t  }\n\t\t  return {\n\t\t    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n\t\t    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n\t\t  };\n\t\t}\n\t\tfunction getContainerSize(canvas, width, height) {\n\t\t  let maxWidth, maxHeight;\n\t\t  if (width === undefined || height === undefined) {\n\t\t    const container = _getParentNode(canvas);\n\t\t    if (!container) {\n\t\t      width = canvas.clientWidth;\n\t\t      height = canvas.clientHeight;\n\t\t    } else {\n\t\t      const rect = container.getBoundingClientRect();\n\t\t      const containerStyle = getComputedStyle(container);\n\t\t      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n\t\t      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n\t\t      width = rect.width - containerPadding.width - containerBorder.width;\n\t\t      height = rect.height - containerPadding.height - containerBorder.height;\n\t\t      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n\t\t      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n\t\t    }\n\t\t  }\n\t\t  return {\n\t\t    width,\n\t\t    height,\n\t\t    maxWidth: maxWidth || INFINITY,\n\t\t    maxHeight: maxHeight || INFINITY\n\t\t  };\n\t\t}\n\t\tconst round1 = v => Math.round(v * 10) / 10;\n\t\tfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n\t\t  const style = getComputedStyle(canvas);\n\t\t  const margins = getPositionedStyle(style, 'margin');\n\t\t  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n\t\t  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n\t\t  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n\t\t  let {width, height} = containerSize;\n\t\t  if (style.boxSizing === 'content-box') {\n\t\t    const borders = getPositionedStyle(style, 'border', 'width');\n\t\t    const paddings = getPositionedStyle(style, 'padding');\n\t\t    width -= paddings.width + borders.width;\n\t\t    height -= paddings.height + borders.height;\n\t\t  }\n\t\t  width = Math.max(0, width - margins.width);\n\t\t  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n\t\t  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n\t\t  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n\t\t  if (width && !height) {\n\t\t    height = round1(width / 2);\n\t\t  }\n\t\t  return {\n\t\t    width,\n\t\t    height\n\t\t  };\n\t\t}\n\t\tfunction retinaScale(chart, forceRatio, forceStyle) {\n\t\t  const pixelRatio = forceRatio || 1;\n\t\t  const deviceHeight = Math.floor(chart.height * pixelRatio);\n\t\t  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\t\t  chart.height = deviceHeight / pixelRatio;\n\t\t  chart.width = deviceWidth / pixelRatio;\n\t\t  const canvas = chart.canvas;\n\t\t  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n\t\t    canvas.style.height = `${chart.height}px`;\n\t\t    canvas.style.width = `${chart.width}px`;\n\t\t  }\n\t\t  if (chart.currentDevicePixelRatio !== pixelRatio\n\t\t      || canvas.height !== deviceHeight\n\t\t      || canvas.width !== deviceWidth) {\n\t\t    chart.currentDevicePixelRatio = pixelRatio;\n\t\t    canvas.height = deviceHeight;\n\t\t    canvas.width = deviceWidth;\n\t\t    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t    return true;\n\t\t  }\n\t\t  return false;\n\t\t}\n\t\tconst supportsEventListenerOptions = (function() {\n\t\t  let passiveSupported = false;\n\t\t  try {\n\t\t    const options = {\n\t\t      get passive() {\n\t\t        passiveSupported = true;\n\t\t        return false;\n\t\t      }\n\t\t    };\n\t\t    window.addEventListener('test', null, options);\n\t\t    window.removeEventListener('test', null, options);\n\t\t  } catch (e) {\n\t\t  }\n\t\t  return passiveSupported;\n\t\t}());\n\t\tfunction readUsedSize(element, property) {\n\t\t  const value = getStyle(element, property);\n\t\t  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\t\t  return matches ? +matches[1] : undefined;\n\t\t}\n\n\t\tfunction getRelativePosition(e, chart) {\n\t\t  if ('native' in e) {\n\t\t    return {\n\t\t      x: e.x,\n\t\t      y: e.y\n\t\t    };\n\t\t  }\n\t\t  return getRelativePosition$1(e, chart);\n\t\t}\n\t\tfunction evaluateAllVisibleItems(chart, handler) {\n\t\t  const metasets = chart.getSortedVisibleDatasetMetas();\n\t\t  let index, data, element;\n\t\t  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\t    ({index, data} = metasets[i]);\n\t\t    for (let j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t      element = data[j];\n\t\t      if (!element.skip) {\n\t\t        handler(element, index, j);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction binarySearch(metaset, axis, value, intersect) {\n\t\t  const {controller, data, _sorted} = metaset;\n\t\t  const iScale = controller._cachedMeta.iScale;\n\t\t  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n\t\t    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n\t\t    if (!intersect) {\n\t\t      return lookupMethod(data, axis, value);\n\t\t    } else if (controller._sharedOptions) {\n\t\t      const el = data[0];\n\t\t      const range = typeof el.getRange === 'function' && el.getRange(axis);\n\t\t      if (range) {\n\t\t        const start = lookupMethod(data, axis, value - range);\n\t\t        const end = lookupMethod(data, axis, value + range);\n\t\t        return {lo: start.lo, hi: end.hi};\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return {lo: 0, hi: data.length - 1};\n\t\t}\n\t\tfunction optimizedEvaluateItems(chart, axis, position, handler, intersect) {\n\t\t  const metasets = chart.getSortedVisibleDatasetMetas();\n\t\t  const value = position[axis];\n\t\t  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\t    const {index, data} = metasets[i];\n\t\t    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n\t\t    for (let j = lo; j <= hi; ++j) {\n\t\t      const element = data[j];\n\t\t      if (!element.skip) {\n\t\t        handler(element, index, j);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction getDistanceMetricForAxis(axis) {\n\t\t  const useX = axis.indexOf('x') !== -1;\n\t\t  const useY = axis.indexOf('y') !== -1;\n\t\t  return function(pt1, pt2) {\n\t\t    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\t    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\t    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t\t  };\n\t\t}\n\t\tfunction getIntersectItems(chart, position, axis, useFinalPosition) {\n\t\t  const items = [];\n\t\t  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n\t\t    return items;\n\t\t  }\n\t\t  const evaluationFunc = function(element, datasetIndex, index) {\n\t\t    if (element.inRange(position.x, position.y, useFinalPosition)) {\n\t\t      items.push({element, datasetIndex, index});\n\t\t    }\n\t\t  };\n\t\t  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\n\t\t  return items;\n\t\t}\n\t\tfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n\t\t  let items = [];\n\t\t  function evaluationFunc(element, datasetIndex, index) {\n\t\t    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n\t\t    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\t\t    if (_angleBetween(angle, startAngle, endAngle)) {\n\t\t      items.push({element, datasetIndex, index});\n\t\t    }\n\t\t  }\n\t\t  optimizedEvaluateItems(chart, axis, position, evaluationFunc);\n\t\t  return items;\n\t\t}\n\t\tfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {\n\t\t  let items = [];\n\t\t  const distanceMetric = getDistanceMetricForAxis(axis);\n\t\t  let minDistance = Number.POSITIVE_INFINITY;\n\t\t  function evaluationFunc(element, datasetIndex, index) {\n\t\t    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n\t\t    if (intersect && !inRange) {\n\t\t      return;\n\t\t    }\n\t\t    const center = element.getCenterPoint(useFinalPosition);\n\t\t    const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);\n\t\t    if (!pointInArea && !inRange) {\n\t\t      return;\n\t\t    }\n\t\t    const distance = distanceMetric(position, center);\n\t\t    if (distance < minDistance) {\n\t\t      items = [{element, datasetIndex, index}];\n\t\t      minDistance = distance;\n\t\t    } else if (distance === minDistance) {\n\t\t      items.push({element, datasetIndex, index});\n\t\t    }\n\t\t  }\n\t\t  optimizedEvaluateItems(chart, axis, position, evaluationFunc);\n\t\t  return items;\n\t\t}\n\t\tfunction getNearestItems(chart, position, axis, intersect, useFinalPosition) {\n\t\t  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n\t\t    return [];\n\t\t  }\n\t\t  return axis === 'r' && !intersect\n\t\t    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n\t\t    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);\n\t\t}\n\t\tfunction getAxisItems(chart, e, options, useFinalPosition) {\n\t\t  const position = getRelativePosition(e, chart);\n\t\t  const items = [];\n\t\t  const axis = options.axis;\n\t\t  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n\t\t  let intersectsItem = false;\n\t\t  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\n\t\t    if (element[rangeMethod](position[axis], useFinalPosition)) {\n\t\t      items.push({element, datasetIndex, index});\n\t\t    }\n\t\t    if (element.inRange(position.x, position.y, useFinalPosition)) {\n\t\t      intersectsItem = true;\n\t\t    }\n\t\t  });\n\t\t  if (options.intersect && !intersectsItem) {\n\t\t    return [];\n\t\t  }\n\t\t  return items;\n\t\t}\n\t\tvar Interaction = {\n\t\t  modes: {\n\t\t    index(chart, e, options, useFinalPosition) {\n\t\t      const position = getRelativePosition(e, chart);\n\t\t      const axis = options.axis || 'x';\n\t\t      const items = options.intersect\n\t\t        ? getIntersectItems(chart, position, axis, useFinalPosition)\n\t\t        : getNearestItems(chart, position, axis, false, useFinalPosition);\n\t\t      const elements = [];\n\t\t      if (!items.length) {\n\t\t        return [];\n\t\t      }\n\t\t      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n\t\t        const index = items[0].index;\n\t\t        const element = meta.data[index];\n\t\t        if (element && !element.skip) {\n\t\t          elements.push({element, datasetIndex: meta.index, index});\n\t\t        }\n\t\t      });\n\t\t      return elements;\n\t\t    },\n\t\t    dataset(chart, e, options, useFinalPosition) {\n\t\t      const position = getRelativePosition(e, chart);\n\t\t      const axis = options.axis || 'xy';\n\t\t      let items = options.intersect\n\t\t        ? getIntersectItems(chart, position, axis, useFinalPosition) :\n\t\t        getNearestItems(chart, position, axis, false, useFinalPosition);\n\t\t      if (items.length > 0) {\n\t\t        const datasetIndex = items[0].datasetIndex;\n\t\t        const data = chart.getDatasetMeta(datasetIndex).data;\n\t\t        items = [];\n\t\t        for (let i = 0; i < data.length; ++i) {\n\t\t          items.push({element: data[i], datasetIndex, index: i});\n\t\t        }\n\t\t      }\n\t\t      return items;\n\t\t    },\n\t\t    point(chart, e, options, useFinalPosition) {\n\t\t      const position = getRelativePosition(e, chart);\n\t\t      const axis = options.axis || 'xy';\n\t\t      return getIntersectItems(chart, position, axis, useFinalPosition);\n\t\t    },\n\t\t    nearest(chart, e, options, useFinalPosition) {\n\t\t      const position = getRelativePosition(e, chart);\n\t\t      const axis = options.axis || 'xy';\n\t\t      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\n\t\t    },\n\t\t    x(chart, e, options, useFinalPosition) {\n\t\t      return getAxisItems(chart, e, {axis: 'x', intersect: options.intersect}, useFinalPosition);\n\t\t    },\n\t\t    y(chart, e, options, useFinalPosition) {\n\t\t      return getAxisItems(chart, e, {axis: 'y', intersect: options.intersect}, useFinalPosition);\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\t\tconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\n\t\tfunction toLineHeight(value, size) {\n\t\t  const matches = ('' + value).match(LINE_HEIGHT);\n\t\t  if (!matches || matches[1] === 'normal') {\n\t\t    return size * 1.2;\n\t\t  }\n\t\t  value = +matches[2];\n\t\t  switch (matches[3]) {\n\t\t  case 'px':\n\t\t    return value;\n\t\t  case '%':\n\t\t    value /= 100;\n\t\t    break;\n\t\t  }\n\t\t  return size * value;\n\t\t}\n\t\tconst numberOrZero = v => +v || 0;\n\t\tfunction _readValueToProps(value, props) {\n\t\t  const ret = {};\n\t\t  const objProps = isObject(props);\n\t\t  const keys = objProps ? Object.keys(props) : props;\n\t\t  const read = isObject(value)\n\t\t    ? objProps\n\t\t      ? prop => valueOrDefault(value[prop], value[props[prop]])\n\t\t      : prop => value[prop]\n\t\t    : () => value;\n\t\t  for (const prop of keys) {\n\t\t    ret[prop] = numberOrZero(read(prop));\n\t\t  }\n\t\t  return ret;\n\t\t}\n\t\tfunction toTRBL(value) {\n\t\t  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n\t\t}\n\t\tfunction toTRBLCorners(value) {\n\t\t  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n\t\t}\n\t\tfunction toPadding(value) {\n\t\t  const obj = toTRBL(value);\n\t\t  obj.width = obj.left + obj.right;\n\t\t  obj.height = obj.top + obj.bottom;\n\t\t  return obj;\n\t\t}\n\t\tfunction toFont(options, fallback) {\n\t\t  options = options || {};\n\t\t  fallback = fallback || defaults.font;\n\t\t  let size = valueOrDefault(options.size, fallback.size);\n\t\t  if (typeof size === 'string') {\n\t\t    size = parseInt(size, 10);\n\t\t  }\n\t\t  let style = valueOrDefault(options.style, fallback.style);\n\t\t  if (style && !('' + style).match(FONT_STYLE)) {\n\t\t    console.warn('Invalid font style specified: \"' + style + '\"');\n\t\t    style = '';\n\t\t  }\n\t\t  const font = {\n\t\t    family: valueOrDefault(options.family, fallback.family),\n\t\t    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n\t\t    size,\n\t\t    style,\n\t\t    weight: valueOrDefault(options.weight, fallback.weight),\n\t\t    string: ''\n\t\t  };\n\t\t  font.string = toFontString(font);\n\t\t  return font;\n\t\t}\n\t\tfunction resolve(inputs, context, index, info) {\n\t\t  let cacheable = true;\n\t\t  let i, ilen, value;\n\t\t  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\t    value = inputs[i];\n\t\t    if (value === undefined) {\n\t\t      continue;\n\t\t    }\n\t\t    if (context !== undefined && typeof value === 'function') {\n\t\t      value = value(context);\n\t\t      cacheable = false;\n\t\t    }\n\t\t    if (index !== undefined && isArray(value)) {\n\t\t      value = value[index % value.length];\n\t\t      cacheable = false;\n\t\t    }\n\t\t    if (value !== undefined) {\n\t\t      if (info && !cacheable) {\n\t\t        info.cacheable = false;\n\t\t      }\n\t\t      return value;\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction _addGrace(minmax, grace, beginAtZero) {\n\t\t  const {min, max} = minmax;\n\t\t  const change = toDimension(grace, (max - min) / 2);\n\t\t  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n\t\t  return {\n\t\t    min: keepZero(min, -Math.abs(change)),\n\t\t    max: keepZero(max, change)\n\t\t  };\n\t\t}\n\t\tfunction createContext(parentContext, context) {\n\t\t  return Object.assign(Object.create(parentContext), context);\n\t\t}\n\n\t\tconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\t\tfunction filterByPosition(array, position) {\n\t\t  return array.filter(v => v.pos === position);\n\t\t}\n\t\tfunction filterDynamicPositionByAxis(array, axis) {\n\t\t  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n\t\t}\n\t\tfunction sortByWeight(array, reverse) {\n\t\t  return array.sort((a, b) => {\n\t\t    const v0 = reverse ? b : a;\n\t\t    const v1 = reverse ? a : b;\n\t\t    return v0.weight === v1.weight ?\n\t\t      v0.index - v1.index :\n\t\t      v0.weight - v1.weight;\n\t\t  });\n\t\t}\n\t\tfunction wrapBoxes(boxes) {\n\t\t  const layoutBoxes = [];\n\t\t  let i, ilen, box, pos, stack, stackWeight;\n\t\t  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n\t\t    box = boxes[i];\n\t\t    ({position: pos, options: {stack, stackWeight = 1}} = box);\n\t\t    layoutBoxes.push({\n\t\t      index: i,\n\t\t      box,\n\t\t      pos,\n\t\t      horizontal: box.isHorizontal(),\n\t\t      weight: box.weight,\n\t\t      stack: stack && (pos + stack),\n\t\t      stackWeight\n\t\t    });\n\t\t  }\n\t\t  return layoutBoxes;\n\t\t}\n\t\tfunction buildStacks(layouts) {\n\t\t  const stacks = {};\n\t\t  for (const wrap of layouts) {\n\t\t    const {stack, pos, stackWeight} = wrap;\n\t\t    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n\t\t      continue;\n\t\t    }\n\t\t    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n\t\t    _stack.count++;\n\t\t    _stack.weight += stackWeight;\n\t\t  }\n\t\t  return stacks;\n\t\t}\n\t\tfunction setLayoutDims(layouts, params) {\n\t\t  const stacks = buildStacks(layouts);\n\t\t  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n\t\t  let i, ilen, layout;\n\t\t  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n\t\t    layout = layouts[i];\n\t\t    const {fullSize} = layout.box;\n\t\t    const stack = stacks[layout.stack];\n\t\t    const factor = stack && layout.stackWeight / stack.weight;\n\t\t    if (layout.horizontal) {\n\t\t      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n\t\t      layout.height = hBoxMaxHeight;\n\t\t    } else {\n\t\t      layout.width = vBoxMaxWidth;\n\t\t      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n\t\t    }\n\t\t  }\n\t\t  return stacks;\n\t\t}\n\t\tfunction buildLayoutBoxes(boxes) {\n\t\t  const layoutBoxes = wrapBoxes(boxes);\n\t\t  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n\t\t  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n\t\t  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n\t\t  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n\t\t  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n\t\t  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n\t\t  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\t\t  return {\n\t\t    fullSize,\n\t\t    leftAndTop: left.concat(top),\n\t\t    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n\t\t    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n\t\t    vertical: left.concat(right).concat(centerVertical),\n\t\t    horizontal: top.concat(bottom).concat(centerHorizontal)\n\t\t  };\n\t\t}\n\t\tfunction getCombinedMax(maxPadding, chartArea, a, b) {\n\t\t  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n\t\t}\n\t\tfunction updateMaxPadding(maxPadding, boxPadding) {\n\t\t  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n\t\t  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n\t\t  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n\t\t  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n\t\t}\n\t\tfunction updateDims(chartArea, params, layout, stacks) {\n\t\t  const {pos, box} = layout;\n\t\t  const maxPadding = chartArea.maxPadding;\n\t\t  if (!isObject(pos)) {\n\t\t    if (layout.size) {\n\t\t      chartArea[pos] -= layout.size;\n\t\t    }\n\t\t    const stack = stacks[layout.stack] || {size: 0, count: 1};\n\t\t    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n\t\t    layout.size = stack.size / stack.count;\n\t\t    chartArea[pos] += layout.size;\n\t\t  }\n\t\t  if (box.getPadding) {\n\t\t    updateMaxPadding(maxPadding, box.getPadding());\n\t\t  }\n\t\t  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n\t\t  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n\t\t  const widthChanged = newWidth !== chartArea.w;\n\t\t  const heightChanged = newHeight !== chartArea.h;\n\t\t  chartArea.w = newWidth;\n\t\t  chartArea.h = newHeight;\n\t\t  return layout.horizontal\n\t\t    ? {same: widthChanged, other: heightChanged}\n\t\t    : {same: heightChanged, other: widthChanged};\n\t\t}\n\t\tfunction handleMaxPadding(chartArea) {\n\t\t  const maxPadding = chartArea.maxPadding;\n\t\t  function updatePos(pos) {\n\t\t    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n\t\t    chartArea[pos] += change;\n\t\t    return change;\n\t\t  }\n\t\t  chartArea.y += updatePos('top');\n\t\t  chartArea.x += updatePos('left');\n\t\t  updatePos('right');\n\t\t  updatePos('bottom');\n\t\t}\n\t\tfunction getMargins(horizontal, chartArea) {\n\t\t  const maxPadding = chartArea.maxPadding;\n\t\t  function marginForPositions(positions) {\n\t\t    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n\t\t    positions.forEach((pos) => {\n\t\t      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n\t\t    });\n\t\t    return margin;\n\t\t  }\n\t\t  return horizontal\n\t\t    ? marginForPositions(['left', 'right'])\n\t\t    : marginForPositions(['top', 'bottom']);\n\t\t}\n\t\tfunction fitBoxes(boxes, chartArea, params, stacks) {\n\t\t  const refitBoxes = [];\n\t\t  let i, ilen, layout, box, refit, changed;\n\t\t  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n\t\t    layout = boxes[i];\n\t\t    box = layout.box;\n\t\t    box.update(\n\t\t      layout.width || chartArea.w,\n\t\t      layout.height || chartArea.h,\n\t\t      getMargins(layout.horizontal, chartArea)\n\t\t    );\n\t\t    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\t\t    refit |= same && refitBoxes.length;\n\t\t    changed = changed || other;\n\t\t    if (!box.fullSize) {\n\t\t      refitBoxes.push(layout);\n\t\t    }\n\t\t  }\n\t\t  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n\t\t}\n\t\tfunction setBoxDims(box, left, top, width, height) {\n\t\t  box.top = top;\n\t\t  box.left = left;\n\t\t  box.right = left + width;\n\t\t  box.bottom = top + height;\n\t\t  box.width = width;\n\t\t  box.height = height;\n\t\t}\n\t\tfunction placeBoxes(boxes, chartArea, params, stacks) {\n\t\t  const userPadding = params.padding;\n\t\t  let {x, y} = chartArea;\n\t\t  for (const layout of boxes) {\n\t\t    const box = layout.box;\n\t\t    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n\t\t    const weight = (layout.stackWeight / stack.weight) || 1;\n\t\t    if (layout.horizontal) {\n\t\t      const width = chartArea.w * weight;\n\t\t      const height = stack.size || box.height;\n\t\t      if (defined(stack.start)) {\n\t\t        y = stack.start;\n\t\t      }\n\t\t      if (box.fullSize) {\n\t\t        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n\t\t      } else {\n\t\t        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n\t\t      }\n\t\t      stack.start = y;\n\t\t      stack.placed += width;\n\t\t      y = box.bottom;\n\t\t    } else {\n\t\t      const height = chartArea.h * weight;\n\t\t      const width = stack.size || box.width;\n\t\t      if (defined(stack.start)) {\n\t\t        x = stack.start;\n\t\t      }\n\t\t      if (box.fullSize) {\n\t\t        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n\t\t      } else {\n\t\t        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n\t\t      }\n\t\t      stack.start = x;\n\t\t      stack.placed += height;\n\t\t      x = box.right;\n\t\t    }\n\t\t  }\n\t\t  chartArea.x = x;\n\t\t  chartArea.y = y;\n\t\t}\n\t\tdefaults.set('layout', {\n\t\t  autoPadding: true,\n\t\t  padding: {\n\t\t    top: 0,\n\t\t    right: 0,\n\t\t    bottom: 0,\n\t\t    left: 0\n\t\t  }\n\t\t});\n\t\tvar layouts = {\n\t\t  addBox(chart, item) {\n\t\t    if (!chart.boxes) {\n\t\t      chart.boxes = [];\n\t\t    }\n\t\t    item.fullSize = item.fullSize || false;\n\t\t    item.position = item.position || 'top';\n\t\t    item.weight = item.weight || 0;\n\t\t    item._layers = item._layers || function() {\n\t\t      return [{\n\t\t        z: 0,\n\t\t        draw(chartArea) {\n\t\t          item.draw(chartArea);\n\t\t        }\n\t\t      }];\n\t\t    };\n\t\t    chart.boxes.push(item);\n\t\t  },\n\t\t  removeBox(chart, layoutItem) {\n\t\t    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\t    if (index !== -1) {\n\t\t      chart.boxes.splice(index, 1);\n\t\t    }\n\t\t  },\n\t\t  configure(chart, item, options) {\n\t\t    item.fullSize = options.fullSize;\n\t\t    item.position = options.position;\n\t\t    item.weight = options.weight;\n\t\t  },\n\t\t  update(chart, width, height, minPadding) {\n\t\t    if (!chart) {\n\t\t      return;\n\t\t    }\n\t\t    const padding = toPadding(chart.options.layout.padding);\n\t\t    const availableWidth = Math.max(width - padding.width, 0);\n\t\t    const availableHeight = Math.max(height - padding.height, 0);\n\t\t    const boxes = buildLayoutBoxes(chart.boxes);\n\t\t    const verticalBoxes = boxes.vertical;\n\t\t    const horizontalBoxes = boxes.horizontal;\n\t\t    each(chart.boxes, box => {\n\t\t      if (typeof box.beforeLayout === 'function') {\n\t\t        box.beforeLayout();\n\t\t      }\n\t\t    });\n\t\t    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n\t\t      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\t\t    const params = Object.freeze({\n\t\t      outerWidth: width,\n\t\t      outerHeight: height,\n\t\t      padding,\n\t\t      availableWidth,\n\t\t      availableHeight,\n\t\t      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n\t\t      hBoxMaxHeight: availableHeight / 2\n\t\t    });\n\t\t    const maxPadding = Object.assign({}, padding);\n\t\t    updateMaxPadding(maxPadding, toPadding(minPadding));\n\t\t    const chartArea = Object.assign({\n\t\t      maxPadding,\n\t\t      w: availableWidth,\n\t\t      h: availableHeight,\n\t\t      x: padding.left,\n\t\t      y: padding.top\n\t\t    }, padding);\n\t\t    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\t\t    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\t\t    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\t\t    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n\t\t      fitBoxes(verticalBoxes, chartArea, params, stacks);\n\t\t    }\n\t\t    handleMaxPadding(chartArea);\n\t\t    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\t\t    chartArea.x += chartArea.w;\n\t\t    chartArea.y += chartArea.h;\n\t\t    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\t\t    chart.chartArea = {\n\t\t      left: chartArea.left,\n\t\t      top: chartArea.top,\n\t\t      right: chartArea.left + chartArea.w,\n\t\t      bottom: chartArea.top + chartArea.h,\n\t\t      height: chartArea.h,\n\t\t      width: chartArea.w,\n\t\t    };\n\t\t    each(boxes.chartArea, (layout) => {\n\t\t      const box = layout.box;\n\t\t      Object.assign(box, chart.chartArea);\n\t\t      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n\t\t    });\n\t\t  }\n\t\t};\n\n\t\tfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n\t\t  if (!defined(fallback)) {\n\t\t    fallback = _resolve('_fallback', scopes);\n\t\t  }\n\t\t  const cache = {\n\t\t    [Symbol.toStringTag]: 'Object',\n\t\t    _cacheable: true,\n\t\t    _scopes: scopes,\n\t\t    _rootScopes: rootScopes,\n\t\t    _fallback: fallback,\n\t\t    _getTarget: getTarget,\n\t\t    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n\t\t  };\n\t\t  return new Proxy(cache, {\n\t\t    deleteProperty(target, prop) {\n\t\t      delete target[prop];\n\t\t      delete target._keys;\n\t\t      delete scopes[0][prop];\n\t\t      return true;\n\t\t    },\n\t\t    get(target, prop) {\n\t\t      return _cached(target, prop,\n\t\t        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n\t\t    },\n\t\t    getOwnPropertyDescriptor(target, prop) {\n\t\t      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n\t\t    },\n\t\t    getPrototypeOf() {\n\t\t      return Reflect.getPrototypeOf(scopes[0]);\n\t\t    },\n\t\t    has(target, prop) {\n\t\t      return getKeysFromAllScopes(target).includes(prop);\n\t\t    },\n\t\t    ownKeys(target) {\n\t\t      return getKeysFromAllScopes(target);\n\t\t    },\n\t\t    set(target, prop, value) {\n\t\t      const storage = target._storage || (target._storage = getTarget());\n\t\t      target[prop] = storage[prop] = value;\n\t\t      delete target._keys;\n\t\t      return true;\n\t\t    }\n\t\t  });\n\t\t}\n\t\tfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n\t\t  const cache = {\n\t\t    _cacheable: false,\n\t\t    _proxy: proxy,\n\t\t    _context: context,\n\t\t    _subProxy: subProxy,\n\t\t    _stack: new Set(),\n\t\t    _descriptors: _descriptors(proxy, descriptorDefaults),\n\t\t    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n\t\t    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n\t\t  };\n\t\t  return new Proxy(cache, {\n\t\t    deleteProperty(target, prop) {\n\t\t      delete target[prop];\n\t\t      delete proxy[prop];\n\t\t      return true;\n\t\t    },\n\t\t    get(target, prop, receiver) {\n\t\t      return _cached(target, prop,\n\t\t        () => _resolveWithContext(target, prop, receiver));\n\t\t    },\n\t\t    getOwnPropertyDescriptor(target, prop) {\n\t\t      return target._descriptors.allKeys\n\t\t        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n\t\t        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n\t\t    },\n\t\t    getPrototypeOf() {\n\t\t      return Reflect.getPrototypeOf(proxy);\n\t\t    },\n\t\t    has(target, prop) {\n\t\t      return Reflect.has(proxy, prop);\n\t\t    },\n\t\t    ownKeys() {\n\t\t      return Reflect.ownKeys(proxy);\n\t\t    },\n\t\t    set(target, prop, value) {\n\t\t      proxy[prop] = value;\n\t\t      delete target[prop];\n\t\t      return true;\n\t\t    }\n\t\t  });\n\t\t}\n\t\tfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n\t\t  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n\t\t  return {\n\t\t    allKeys: _allKeys,\n\t\t    scriptable: _scriptable,\n\t\t    indexable: _indexable,\n\t\t    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n\t\t    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n\t\t  };\n\t\t}\n\t\tconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\n\t\tconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n\t\t  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\t\tfunction _cached(target, prop, resolve) {\n\t\t  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n\t\t    return target[prop];\n\t\t  }\n\t\t  const value = resolve();\n\t\t  target[prop] = value;\n\t\t  return value;\n\t\t}\n\t\tfunction _resolveWithContext(target, prop, receiver) {\n\t\t  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\t\t  let value = _proxy[prop];\n\t\t  if (isFunction(value) && descriptors.isScriptable(prop)) {\n\t\t    value = _resolveScriptable(prop, value, target, receiver);\n\t\t  }\n\t\t  if (isArray(value) && value.length) {\n\t\t    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n\t\t  }\n\t\t  if (needsSubResolver(prop, value)) {\n\t\t    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n\t\t  }\n\t\t  return value;\n\t\t}\n\t\tfunction _resolveScriptable(prop, value, target, receiver) {\n\t\t  const {_proxy, _context, _subProxy, _stack} = target;\n\t\t  if (_stack.has(prop)) {\n\t\t    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n\t\t  }\n\t\t  _stack.add(prop);\n\t\t  value = value(_context, _subProxy || receiver);\n\t\t  _stack.delete(prop);\n\t\t  if (needsSubResolver(prop, value)) {\n\t\t    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n\t\t  }\n\t\t  return value;\n\t\t}\n\t\tfunction _resolveArray(prop, value, target, isIndexable) {\n\t\t  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\t\t  if (defined(_context.index) && isIndexable(prop)) {\n\t\t    value = value[_context.index % value.length];\n\t\t  } else if (isObject(value[0])) {\n\t\t    const arr = value;\n\t\t    const scopes = _proxy._scopes.filter(s => s !== arr);\n\t\t    value = [];\n\t\t    for (const item of arr) {\n\t\t      const resolver = createSubResolver(scopes, _proxy, prop, item);\n\t\t      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n\t\t    }\n\t\t  }\n\t\t  return value;\n\t\t}\n\t\tfunction resolveFallback(fallback, prop, value) {\n\t\t  return isFunction(fallback) ? fallback(prop, value) : fallback;\n\t\t}\n\t\tconst getScope = (key, parent) => key === true ? parent\n\t\t  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\t\tfunction addScopes(set, parentScopes, key, parentFallback, value) {\n\t\t  for (const parent of parentScopes) {\n\t\t    const scope = getScope(key, parent);\n\t\t    if (scope) {\n\t\t      set.add(scope);\n\t\t      const fallback = resolveFallback(scope._fallback, key, value);\n\t\t      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n\t\t        return fallback;\n\t\t      }\n\t\t    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n\t\t      return null;\n\t\t    }\n\t\t  }\n\t\t  return false;\n\t\t}\n\t\tfunction createSubResolver(parentScopes, resolver, prop, value) {\n\t\t  const rootScopes = resolver._rootScopes;\n\t\t  const fallback = resolveFallback(resolver._fallback, prop, value);\n\t\t  const allScopes = [...parentScopes, ...rootScopes];\n\t\t  const set = new Set();\n\t\t  set.add(value);\n\t\t  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n\t\t  if (key === null) {\n\t\t    return false;\n\t\t  }\n\t\t  if (defined(fallback) && fallback !== prop) {\n\t\t    key = addScopesFromKey(set, allScopes, fallback, key, value);\n\t\t    if (key === null) {\n\t\t      return false;\n\t\t    }\n\t\t  }\n\t\t  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n\t\t    () => subGetTarget(resolver, prop, value));\n\t\t}\n\t\tfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n\t\t  while (key) {\n\t\t    key = addScopes(set, allScopes, key, fallback, item);\n\t\t  }\n\t\t  return key;\n\t\t}\n\t\tfunction subGetTarget(resolver, prop, value) {\n\t\t  const parent = resolver._getTarget();\n\t\t  if (!(prop in parent)) {\n\t\t    parent[prop] = {};\n\t\t  }\n\t\t  const target = parent[prop];\n\t\t  if (isArray(target) && isObject(value)) {\n\t\t    return value;\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\tfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n\t\t  let value;\n\t\t  for (const prefix of prefixes) {\n\t\t    value = _resolve(readKey(prefix, prop), scopes);\n\t\t    if (defined(value)) {\n\t\t      return needsSubResolver(prop, value)\n\t\t        ? createSubResolver(scopes, proxy, prop, value)\n\t\t        : value;\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction _resolve(key, scopes) {\n\t\t  for (const scope of scopes) {\n\t\t    if (!scope) {\n\t\t      continue;\n\t\t    }\n\t\t    const value = scope[key];\n\t\t    if (defined(value)) {\n\t\t      return value;\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction getKeysFromAllScopes(target) {\n\t\t  let keys = target._keys;\n\t\t  if (!keys) {\n\t\t    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n\t\t  }\n\t\t  return keys;\n\t\t}\n\t\tfunction resolveKeysFromAllScopes(scopes) {\n\t\t  const set = new Set();\n\t\t  for (const scope of scopes) {\n\t\t    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n\t\t      set.add(key);\n\t\t    }\n\t\t  }\n\t\t  return Array.from(set);\n\t\t}\n\n\t\tconst EPSILON = Number.EPSILON || 1e-14;\n\t\tconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\n\t\tconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\n\t\tfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n\t\t  const previous = firstPoint.skip ? middlePoint : firstPoint;\n\t\t  const current = middlePoint;\n\t\t  const next = afterPoint.skip ? middlePoint : afterPoint;\n\t\t  const d01 = distanceBetweenPoints(current, previous);\n\t\t  const d12 = distanceBetweenPoints(next, current);\n\t\t  let s01 = d01 / (d01 + d12);\n\t\t  let s12 = d12 / (d01 + d12);\n\t\t  s01 = isNaN(s01) ? 0 : s01;\n\t\t  s12 = isNaN(s12) ? 0 : s12;\n\t\t  const fa = t * s01;\n\t\t  const fb = t * s12;\n\t\t  return {\n\t\t    previous: {\n\t\t      x: current.x - fa * (next.x - previous.x),\n\t\t      y: current.y - fa * (next.y - previous.y)\n\t\t    },\n\t\t    next: {\n\t\t      x: current.x + fb * (next.x - previous.x),\n\t\t      y: current.y + fb * (next.y - previous.y)\n\t\t    }\n\t\t  };\n\t\t}\n\t\tfunction monotoneAdjust(points, deltaK, mK) {\n\t\t  const pointsLen = points.length;\n\t\t  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n\t\t  let pointAfter = getPoint(points, 0);\n\t\t  for (let i = 0; i < pointsLen - 1; ++i) {\n\t\t    pointCurrent = pointAfter;\n\t\t    pointAfter = getPoint(points, i + 1);\n\t\t    if (!pointCurrent || !pointAfter) {\n\t\t      continue;\n\t\t    }\n\t\t    if (almostEquals(deltaK[i], 0, EPSILON)) {\n\t\t      mK[i] = mK[i + 1] = 0;\n\t\t      continue;\n\t\t    }\n\t\t    alphaK = mK[i] / deltaK[i];\n\t\t    betaK = mK[i + 1] / deltaK[i];\n\t\t    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t    if (squaredMagnitude <= 9) {\n\t\t      continue;\n\t\t    }\n\t\t    tauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t    mK[i] = alphaK * tauK * deltaK[i];\n\t\t    mK[i + 1] = betaK * tauK * deltaK[i];\n\t\t  }\n\t\t}\n\t\tfunction monotoneCompute(points, mK, indexAxis = 'x') {\n\t\t  const valueAxis = getValueAxis(indexAxis);\n\t\t  const pointsLen = points.length;\n\t\t  let delta, pointBefore, pointCurrent;\n\t\t  let pointAfter = getPoint(points, 0);\n\t\t  for (let i = 0; i < pointsLen; ++i) {\n\t\t    pointBefore = pointCurrent;\n\t\t    pointCurrent = pointAfter;\n\t\t    pointAfter = getPoint(points, i + 1);\n\t\t    if (!pointCurrent) {\n\t\t      continue;\n\t\t    }\n\t\t    const iPixel = pointCurrent[indexAxis];\n\t\t    const vPixel = pointCurrent[valueAxis];\n\t\t    if (pointBefore) {\n\t\t      delta = (iPixel - pointBefore[indexAxis]) / 3;\n\t\t      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n\t\t      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n\t\t    }\n\t\t    if (pointAfter) {\n\t\t      delta = (pointAfter[indexAxis] - iPixel) / 3;\n\t\t      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n\t\t      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction splineCurveMonotone(points, indexAxis = 'x') {\n\t\t  const valueAxis = getValueAxis(indexAxis);\n\t\t  const pointsLen = points.length;\n\t\t  const deltaK = Array(pointsLen).fill(0);\n\t\t  const mK = Array(pointsLen);\n\t\t  let i, pointBefore, pointCurrent;\n\t\t  let pointAfter = getPoint(points, 0);\n\t\t  for (i = 0; i < pointsLen; ++i) {\n\t\t    pointBefore = pointCurrent;\n\t\t    pointCurrent = pointAfter;\n\t\t    pointAfter = getPoint(points, i + 1);\n\t\t    if (!pointCurrent) {\n\t\t      continue;\n\t\t    }\n\t\t    if (pointAfter) {\n\t\t      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\t\t      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n\t\t    }\n\t\t    mK[i] = !pointBefore ? deltaK[i]\n\t\t      : !pointAfter ? deltaK[i - 1]\n\t\t      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n\t\t      : (deltaK[i - 1] + deltaK[i]) / 2;\n\t\t  }\n\t\t  monotoneAdjust(points, deltaK, mK);\n\t\t  monotoneCompute(points, mK, indexAxis);\n\t\t}\n\t\tfunction capControlPoint(pt, min, max) {\n\t\t  return Math.max(Math.min(pt, max), min);\n\t\t}\n\t\tfunction capBezierPoints(points, area) {\n\t\t  let i, ilen, point, inArea, inAreaPrev;\n\t\t  let inAreaNext = _isPointInArea(points[0], area);\n\t\t  for (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t    inAreaPrev = inArea;\n\t\t    inArea = inAreaNext;\n\t\t    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n\t\t    if (!inArea) {\n\t\t      continue;\n\t\t    }\n\t\t    point = points[i];\n\t\t    if (inAreaPrev) {\n\t\t      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n\t\t      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n\t\t    }\n\t\t    if (inAreaNext) {\n\t\t      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n\t\t      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n\t\t  let i, ilen, point, controlPoints;\n\t\t  if (options.spanGaps) {\n\t\t    points = points.filter((pt) => !pt.skip);\n\t\t  }\n\t\t  if (options.cubicInterpolationMode === 'monotone') {\n\t\t    splineCurveMonotone(points, indexAxis);\n\t\t  } else {\n\t\t    let prev = loop ? points[points.length - 1] : points[0];\n\t\t    for (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t      point = points[i];\n\t\t      controlPoints = splineCurve(\n\t\t        prev,\n\t\t        point,\n\t\t        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n\t\t        options.tension\n\t\t      );\n\t\t      point.cp1x = controlPoints.previous.x;\n\t\t      point.cp1y = controlPoints.previous.y;\n\t\t      point.cp2x = controlPoints.next.x;\n\t\t      point.cp2y = controlPoints.next.y;\n\t\t      prev = point;\n\t\t    }\n\t\t  }\n\t\t  if (options.capBezierPoints) {\n\t\t    capBezierPoints(points, area);\n\t\t  }\n\t\t}\n\n\t\tconst atEdge = (t) => t === 0 || t === 1;\n\t\tconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\n\t\tconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\t\tconst effects = {\n\t\t  linear: t => t,\n\t\t  easeInQuad: t => t * t,\n\t\t  easeOutQuad: t => -t * (t - 2),\n\t\t  easeInOutQuad: t => ((t /= 0.5) < 1)\n\t\t    ? 0.5 * t * t\n\t\t    : -0.5 * ((--t) * (t - 2) - 1),\n\t\t  easeInCubic: t => t * t * t,\n\t\t  easeOutCubic: t => (t -= 1) * t * t + 1,\n\t\t  easeInOutCubic: t => ((t /= 0.5) < 1)\n\t\t    ? 0.5 * t * t * t\n\t\t    : 0.5 * ((t -= 2) * t * t + 2),\n\t\t  easeInQuart: t => t * t * t * t,\n\t\t  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n\t\t  easeInOutQuart: t => ((t /= 0.5) < 1)\n\t\t    ? 0.5 * t * t * t * t\n\t\t    : -0.5 * ((t -= 2) * t * t * t - 2),\n\t\t  easeInQuint: t => t * t * t * t * t,\n\t\t  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n\t\t  easeInOutQuint: t => ((t /= 0.5) < 1)\n\t\t    ? 0.5 * t * t * t * t * t\n\t\t    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\t\t  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n\t\t  easeOutSine: t => Math.sin(t * HALF_PI),\n\t\t  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n\t\t  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\t\t  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\t\t  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\n\t\t    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n\t\t    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\t\t  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\t\t  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n\t\t  easeInOutCirc: t => ((t /= 0.5) < 1)\n\t\t    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n\t\t    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\t\t  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\t\t  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\t\t  easeInOutElastic(t) {\n\t\t    const s = 0.1125;\n\t\t    const p = 0.45;\n\t\t    return atEdge(t) ? t :\n\t\t      t < 0.5\n\t\t        ? 0.5 * elasticIn(t * 2, s, p)\n\t\t        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n\t\t  },\n\t\t  easeInBack(t) {\n\t\t    const s = 1.70158;\n\t\t    return t * t * ((s + 1) * t - s);\n\t\t  },\n\t\t  easeOutBack(t) {\n\t\t    const s = 1.70158;\n\t\t    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n\t\t  },\n\t\t  easeInOutBack(t) {\n\t\t    let s = 1.70158;\n\t\t    if ((t /= 0.5) < 1) {\n\t\t      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t    }\n\t\t    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t\t  },\n\t\t  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n\t\t  easeOutBounce(t) {\n\t\t    const m = 7.5625;\n\t\t    const d = 2.75;\n\t\t    if (t < (1 / d)) {\n\t\t      return m * t * t;\n\t\t    }\n\t\t    if (t < (2 / d)) {\n\t\t      return m * (t -= (1.5 / d)) * t + 0.75;\n\t\t    }\n\t\t    if (t < (2.5 / d)) {\n\t\t      return m * (t -= (2.25 / d)) * t + 0.9375;\n\t\t    }\n\t\t    return m * (t -= (2.625 / d)) * t + 0.984375;\n\t\t  },\n\t\t  easeInOutBounce: t => (t < 0.5)\n\t\t    ? effects.easeInBounce(t * 2) * 0.5\n\t\t    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n\t\t};\n\n\t\tfunction _pointInLine(p1, p2, t, mode) {\n\t\t  return {\n\t\t    x: p1.x + t * (p2.x - p1.x),\n\t\t    y: p1.y + t * (p2.y - p1.y)\n\t\t  };\n\t\t}\n\t\tfunction _steppedInterpolation(p1, p2, t, mode) {\n\t\t  return {\n\t\t    x: p1.x + t * (p2.x - p1.x),\n\t\t    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n\t\t    : mode === 'after' ? t < 1 ? p1.y : p2.y\n\t\t    : t > 0 ? p2.y : p1.y\n\t\t  };\n\t\t}\n\t\tfunction _bezierInterpolation(p1, p2, t, mode) {\n\t\t  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n\t\t  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n\t\t  const a = _pointInLine(p1, cp1, t);\n\t\t  const b = _pointInLine(cp1, cp2, t);\n\t\t  const c = _pointInLine(cp2, p2, t);\n\t\t  const d = _pointInLine(a, b, t);\n\t\t  const e = _pointInLine(b, c, t);\n\t\t  return _pointInLine(d, e, t);\n\t\t}\n\n\t\tconst intlCache = new Map();\n\t\tfunction getNumberFormat(locale, options) {\n\t\t  options = options || {};\n\t\t  const cacheKey = locale + JSON.stringify(options);\n\t\t  let formatter = intlCache.get(cacheKey);\n\t\t  if (!formatter) {\n\t\t    formatter = new Intl.NumberFormat(locale, options);\n\t\t    intlCache.set(cacheKey, formatter);\n\t\t  }\n\t\t  return formatter;\n\t\t}\n\t\tfunction formatNumber(num, locale, options) {\n\t\t  return getNumberFormat(locale, options).format(num);\n\t\t}\n\n\t\tconst getRightToLeftAdapter = function(rectX, width) {\n\t\t  return {\n\t\t    x(x) {\n\t\t      return rectX + rectX + width - x;\n\t\t    },\n\t\t    setWidth(w) {\n\t\t      width = w;\n\t\t    },\n\t\t    textAlign(align) {\n\t\t      if (align === 'center') {\n\t\t        return align;\n\t\t      }\n\t\t      return align === 'right' ? 'left' : 'right';\n\t\t    },\n\t\t    xPlus(x, value) {\n\t\t      return x - value;\n\t\t    },\n\t\t    leftForLtr(x, itemWidth) {\n\t\t      return x - itemWidth;\n\t\t    },\n\t\t  };\n\t\t};\n\t\tconst getLeftToRightAdapter = function() {\n\t\t  return {\n\t\t    x(x) {\n\t\t      return x;\n\t\t    },\n\t\t    setWidth(w) {\n\t\t    },\n\t\t    textAlign(align) {\n\t\t      return align;\n\t\t    },\n\t\t    xPlus(x, value) {\n\t\t      return x + value;\n\t\t    },\n\t\t    leftForLtr(x, _itemWidth) {\n\t\t      return x;\n\t\t    },\n\t\t  };\n\t\t};\n\t\tfunction getRtlAdapter(rtl, rectX, width) {\n\t\t  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n\t\t}\n\t\tfunction overrideTextDirection(ctx, direction) {\n\t\t  let style, original;\n\t\t  if (direction === 'ltr' || direction === 'rtl') {\n\t\t    style = ctx.canvas.style;\n\t\t    original = [\n\t\t      style.getPropertyValue('direction'),\n\t\t      style.getPropertyPriority('direction'),\n\t\t    ];\n\t\t    style.setProperty('direction', direction, 'important');\n\t\t    ctx.prevTextDirection = original;\n\t\t  }\n\t\t}\n\t\tfunction restoreTextDirection(ctx, original) {\n\t\t  if (original !== undefined) {\n\t\t    delete ctx.prevTextDirection;\n\t\t    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n\t\t  }\n\t\t}\n\n\t\tfunction propertyFn(property) {\n\t\t  if (property === 'angle') {\n\t\t    return {\n\t\t      between: _angleBetween,\n\t\t      compare: _angleDiff,\n\t\t      normalize: _normalizeAngle,\n\t\t    };\n\t\t  }\n\t\t  return {\n\t\t    between: _isBetween,\n\t\t    compare: (a, b) => a - b,\n\t\t    normalize: x => x\n\t\t  };\n\t\t}\n\t\tfunction normalizeSegment({start, end, count, loop, style}) {\n\t\t  return {\n\t\t    start: start % count,\n\t\t    end: end % count,\n\t\t    loop: loop && (end - start + 1) % count === 0,\n\t\t    style\n\t\t  };\n\t\t}\n\t\tfunction getSegment(segment, points, bounds) {\n\t\t  const {property, start: startBound, end: endBound} = bounds;\n\t\t  const {between, normalize} = propertyFn(property);\n\t\t  const count = points.length;\n\t\t  let {start, end, loop} = segment;\n\t\t  let i, ilen;\n\t\t  if (loop) {\n\t\t    start += count;\n\t\t    end += count;\n\t\t    for (i = 0, ilen = count; i < ilen; ++i) {\n\t\t      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n\t\t        break;\n\t\t      }\n\t\t      start--;\n\t\t      end--;\n\t\t    }\n\t\t    start %= count;\n\t\t    end %= count;\n\t\t  }\n\t\t  if (end < start) {\n\t\t    end += count;\n\t\t  }\n\t\t  return {start, end, loop, style: segment.style};\n\t\t}\n\t\tfunction _boundSegment(segment, points, bounds) {\n\t\t  if (!bounds) {\n\t\t    return [segment];\n\t\t  }\n\t\t  const {property, start: startBound, end: endBound} = bounds;\n\t\t  const count = points.length;\n\t\t  const {compare, between, normalize} = propertyFn(property);\n\t\t  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\t\t  const result = [];\n\t\t  let inside = false;\n\t\t  let subStart = null;\n\t\t  let value, point, prevValue;\n\t\t  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n\t\t  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n\t\t  const shouldStart = () => inside || startIsBefore();\n\t\t  const shouldStop = () => !inside || endIsBefore();\n\t\t  for (let i = start, prev = start; i <= end; ++i) {\n\t\t    point = points[i % count];\n\t\t    if (point.skip) {\n\t\t      continue;\n\t\t    }\n\t\t    value = normalize(point[property]);\n\t\t    if (value === prevValue) {\n\t\t      continue;\n\t\t    }\n\t\t    inside = between(value, startBound, endBound);\n\t\t    if (subStart === null && shouldStart()) {\n\t\t      subStart = compare(value, startBound) === 0 ? i : prev;\n\t\t    }\n\t\t    if (subStart !== null && shouldStop()) {\n\t\t      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n\t\t      subStart = null;\n\t\t    }\n\t\t    prev = i;\n\t\t    prevValue = value;\n\t\t  }\n\t\t  if (subStart !== null) {\n\t\t    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n\t\t  }\n\t\t  return result;\n\t\t}\n\t\tfunction _boundSegments(line, bounds) {\n\t\t  const result = [];\n\t\t  const segments = line.segments;\n\t\t  for (let i = 0; i < segments.length; i++) {\n\t\t    const sub = _boundSegment(segments[i], line.points, bounds);\n\t\t    if (sub.length) {\n\t\t      result.push(...sub);\n\t\t    }\n\t\t  }\n\t\t  return result;\n\t\t}\n\t\tfunction findStartAndEnd(points, count, loop, spanGaps) {\n\t\t  let start = 0;\n\t\t  let end = count - 1;\n\t\t  if (loop && !spanGaps) {\n\t\t    while (start < count && !points[start].skip) {\n\t\t      start++;\n\t\t    }\n\t\t  }\n\t\t  while (start < count && points[start].skip) {\n\t\t    start++;\n\t\t  }\n\t\t  start %= count;\n\t\t  if (loop) {\n\t\t    end += start;\n\t\t  }\n\t\t  while (end > start && points[end % count].skip) {\n\t\t    end--;\n\t\t  }\n\t\t  end %= count;\n\t\t  return {start, end};\n\t\t}\n\t\tfunction solidSegments(points, start, max, loop) {\n\t\t  const count = points.length;\n\t\t  const result = [];\n\t\t  let last = start;\n\t\t  let prev = points[start];\n\t\t  let end;\n\t\t  for (end = start + 1; end <= max; ++end) {\n\t\t    const cur = points[end % count];\n\t\t    if (cur.skip || cur.stop) {\n\t\t      if (!prev.skip) {\n\t\t        loop = false;\n\t\t        result.push({start: start % count, end: (end - 1) % count, loop});\n\t\t        start = last = cur.stop ? end : null;\n\t\t      }\n\t\t    } else {\n\t\t      last = end;\n\t\t      if (prev.skip) {\n\t\t        start = end;\n\t\t      }\n\t\t    }\n\t\t    prev = cur;\n\t\t  }\n\t\t  if (last !== null) {\n\t\t    result.push({start: start % count, end: last % count, loop});\n\t\t  }\n\t\t  return result;\n\t\t}\n\t\tfunction _computeSegments(line, segmentOptions) {\n\t\t  const points = line.points;\n\t\t  const spanGaps = line.options.spanGaps;\n\t\t  const count = points.length;\n\t\t  if (!count) {\n\t\t    return [];\n\t\t  }\n\t\t  const loop = !!line._loop;\n\t\t  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\t\t  if (spanGaps === true) {\n\t\t    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n\t\t  }\n\t\t  const max = end < start ? end + count : end;\n\t\t  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n\t\t  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n\t\t}\n\t\tfunction splitByStyles(line, segments, points, segmentOptions) {\n\t\t  if (!segmentOptions || !segmentOptions.setContext || !points) {\n\t\t    return segments;\n\t\t  }\n\t\t  return doSplitByStyles(line, segments, points, segmentOptions);\n\t\t}\n\t\tfunction doSplitByStyles(line, segments, points, segmentOptions) {\n\t\t  const chartContext = line._chart.getContext();\n\t\t  const baseStyle = readStyle(line.options);\n\t\t  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n\t\t  const count = points.length;\n\t\t  const result = [];\n\t\t  let prevStyle = baseStyle;\n\t\t  let start = segments[0].start;\n\t\t  let i = start;\n\t\t  function addStyle(s, e, l, st) {\n\t\t    const dir = spanGaps ? -1 : 1;\n\t\t    if (s === e) {\n\t\t      return;\n\t\t    }\n\t\t    s += count;\n\t\t    while (points[s % count].skip) {\n\t\t      s -= dir;\n\t\t    }\n\t\t    while (points[e % count].skip) {\n\t\t      e += dir;\n\t\t    }\n\t\t    if (s % count !== e % count) {\n\t\t      result.push({start: s % count, end: e % count, loop: l, style: st});\n\t\t      prevStyle = st;\n\t\t      start = e % count;\n\t\t    }\n\t\t  }\n\t\t  for (const segment of segments) {\n\t\t    start = spanGaps ? start : segment.start;\n\t\t    let prev = points[start % count];\n\t\t    let style;\n\t\t    for (i = start + 1; i <= segment.end; i++) {\n\t\t      const pt = points[i % count];\n\t\t      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n\t\t        type: 'segment',\n\t\t        p0: prev,\n\t\t        p1: pt,\n\t\t        p0DataIndex: (i - 1) % count,\n\t\t        p1DataIndex: i % count,\n\t\t        datasetIndex\n\t\t      })));\n\t\t      if (styleChanged(style, prevStyle)) {\n\t\t        addStyle(start, i - 1, segment.loop, prevStyle);\n\t\t      }\n\t\t      prev = pt;\n\t\t      prevStyle = style;\n\t\t    }\n\t\t    if (start < i - 1) {\n\t\t      addStyle(start, i - 1, segment.loop, prevStyle);\n\t\t    }\n\t\t  }\n\t\t  return result;\n\t\t}\n\t\tfunction readStyle(options) {\n\t\t  return {\n\t\t    backgroundColor: options.backgroundColor,\n\t\t    borderCapStyle: options.borderCapStyle,\n\t\t    borderDash: options.borderDash,\n\t\t    borderDashOffset: options.borderDashOffset,\n\t\t    borderJoinStyle: options.borderJoinStyle,\n\t\t    borderWidth: options.borderWidth,\n\t\t    borderColor: options.borderColor\n\t\t  };\n\t\t}\n\t\tfunction styleChanged(style, prevStyle) {\n\t\t  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n\t\t}\n\n\t\tvar helpers = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\teasingEffects: effects,\n\t\tcolor: color,\n\t\tgetHoverColor: getHoverColor,\n\t\tnoop: noop,\n\t\tuid: uid,\n\t\tisNullOrUndef: isNullOrUndef,\n\t\tisArray: isArray,\n\t\tisObject: isObject,\n\t\tisFinite: isNumberFinite,\n\t\tfiniteOrDefault: finiteOrDefault,\n\t\tvalueOrDefault: valueOrDefault,\n\t\ttoPercentage: toPercentage,\n\t\ttoDimension: toDimension,\n\t\tcallback: callback,\n\t\teach: each,\n\t\t_elementsEqual: _elementsEqual,\n\t\tclone: clone,\n\t\t_merger: _merger,\n\t\tmerge: merge,\n\t\tmergeIf: mergeIf,\n\t\t_mergerIf: _mergerIf,\n\t\t_deprecated: _deprecated,\n\t\tresolveObjectKey: resolveObjectKey,\n\t\t_capitalize: _capitalize,\n\t\tdefined: defined,\n\t\tisFunction: isFunction,\n\t\tsetsEqual: setsEqual,\n\t\t_isClickEvent: _isClickEvent,\n\t\ttoFontString: toFontString,\n\t\t_measureText: _measureText,\n\t\t_longestText: _longestText,\n\t\t_alignPixel: _alignPixel,\n\t\tclearCanvas: clearCanvas,\n\t\tdrawPoint: drawPoint,\n\t\t_isPointInArea: _isPointInArea,\n\t\tclipArea: clipArea,\n\t\tunclipArea: unclipArea,\n\t\t_steppedLineTo: _steppedLineTo,\n\t\t_bezierCurveTo: _bezierCurveTo,\n\t\trenderText: renderText,\n\t\taddRoundedRectPath: addRoundedRectPath,\n\t\t_lookup: _lookup,\n\t\t_lookupByKey: _lookupByKey,\n\t\t_rlookupByKey: _rlookupByKey,\n\t\t_filterBetween: _filterBetween,\n\t\tlistenArrayEvents: listenArrayEvents,\n\t\tunlistenArrayEvents: unlistenArrayEvents,\n\t\t_arrayUnique: _arrayUnique,\n\t\t_createResolver: _createResolver,\n\t\t_attachContext: _attachContext,\n\t\t_descriptors: _descriptors,\n\t\tsplineCurve: splineCurve,\n\t\tsplineCurveMonotone: splineCurveMonotone,\n\t\t_updateBezierControlPoints: _updateBezierControlPoints,\n\t\t_isDomSupported: _isDomSupported,\n\t\t_getParentNode: _getParentNode,\n\t\tgetStyle: getStyle,\n\t\tgetRelativePosition: getRelativePosition$1,\n\t\tgetMaximumSize: getMaximumSize,\n\t\tretinaScale: retinaScale,\n\t\tsupportsEventListenerOptions: supportsEventListenerOptions,\n\t\treadUsedSize: readUsedSize,\n\t\tfontString: fontString,\n\t\trequestAnimFrame: requestAnimFrame,\n\t\tthrottled: throttled,\n\t\tdebounce: debounce,\n\t\t_toLeftRightCenter: _toLeftRightCenter,\n\t\t_alignStartEnd: _alignStartEnd,\n\t\t_textX: _textX,\n\t\t_pointInLine: _pointInLine,\n\t\t_steppedInterpolation: _steppedInterpolation,\n\t\t_bezierInterpolation: _bezierInterpolation,\n\t\tformatNumber: formatNumber,\n\t\ttoLineHeight: toLineHeight,\n\t\t_readValueToProps: _readValueToProps,\n\t\ttoTRBL: toTRBL,\n\t\ttoTRBLCorners: toTRBLCorners,\n\t\ttoPadding: toPadding,\n\t\ttoFont: toFont,\n\t\tresolve: resolve,\n\t\t_addGrace: _addGrace,\n\t\tcreateContext: createContext,\n\t\tPI: PI,\n\t\tTAU: TAU,\n\t\tPITAU: PITAU,\n\t\tINFINITY: INFINITY,\n\t\tRAD_PER_DEG: RAD_PER_DEG,\n\t\tHALF_PI: HALF_PI,\n\t\tQUARTER_PI: QUARTER_PI,\n\t\tTWO_THIRDS_PI: TWO_THIRDS_PI,\n\t\tlog10: log10,\n\t\tsign: sign,\n\t\tniceNum: niceNum,\n\t\t_factorize: _factorize,\n\t\tisNumber: isNumber,\n\t\talmostEquals: almostEquals,\n\t\talmostWhole: almostWhole,\n\t\t_setMinAndMaxByKey: _setMinAndMaxByKey,\n\t\ttoRadians: toRadians,\n\t\ttoDegrees: toDegrees,\n\t\t_decimalPlaces: _decimalPlaces,\n\t\tgetAngleFromPoint: getAngleFromPoint,\n\t\tdistanceBetweenPoints: distanceBetweenPoints,\n\t\t_angleDiff: _angleDiff,\n\t\t_normalizeAngle: _normalizeAngle,\n\t\t_angleBetween: _angleBetween,\n\t\t_limitValue: _limitValue,\n\t\t_int16Range: _int16Range,\n\t\t_isBetween: _isBetween,\n\t\tgetRtlAdapter: getRtlAdapter,\n\t\toverrideTextDirection: overrideTextDirection,\n\t\trestoreTextDirection: restoreTextDirection,\n\t\t_boundSegment: _boundSegment,\n\t\t_boundSegments: _boundSegments,\n\t\t_computeSegments: _computeSegments\n\t\t});\n\n\t\tclass BasePlatform {\n\t\t  acquireContext(canvas, aspectRatio) {}\n\t\t  releaseContext(context) {\n\t\t    return false;\n\t\t  }\n\t\t  addEventListener(chart, type, listener) {}\n\t\t  removeEventListener(chart, type, listener) {}\n\t\t  getDevicePixelRatio() {\n\t\t    return 1;\n\t\t  }\n\t\t  getMaximumSize(element, width, height, aspectRatio) {\n\t\t    width = Math.max(0, width || element.width);\n\t\t    height = height || element.height;\n\t\t    return {\n\t\t      width,\n\t\t      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n\t\t    };\n\t\t  }\n\t\t  isAttached(canvas) {\n\t\t    return true;\n\t\t  }\n\t\t  updateConfig(config) {\n\t\t  }\n\t\t}\n\n\t\tclass BasicPlatform extends BasePlatform {\n\t\t  acquireContext(item) {\n\t\t    return item && item.getContext && item.getContext('2d') || null;\n\t\t  }\n\t\t  updateConfig(config) {\n\t\t    config.options.animation = false;\n\t\t  }\n\t\t}\n\n\t\tconst EXPANDO_KEY = '$chartjs';\n\t\tconst EVENT_TYPES = {\n\t\t  touchstart: 'mousedown',\n\t\t  touchmove: 'mousemove',\n\t\t  touchend: 'mouseup',\n\t\t  pointerenter: 'mouseenter',\n\t\t  pointerdown: 'mousedown',\n\t\t  pointermove: 'mousemove',\n\t\t  pointerup: 'mouseup',\n\t\t  pointerleave: 'mouseout',\n\t\t  pointerout: 'mouseout'\n\t\t};\n\t\tconst isNullOrEmpty = value => value === null || value === '';\n\t\tfunction initCanvas(canvas, aspectRatio) {\n\t\t  const style = canvas.style;\n\t\t  const renderHeight = canvas.getAttribute('height');\n\t\t  const renderWidth = canvas.getAttribute('width');\n\t\t  canvas[EXPANDO_KEY] = {\n\t\t    initial: {\n\t\t      height: renderHeight,\n\t\t      width: renderWidth,\n\t\t      style: {\n\t\t        display: style.display,\n\t\t        height: style.height,\n\t\t        width: style.width\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t  style.display = style.display || 'block';\n\t\t  style.boxSizing = style.boxSizing || 'border-box';\n\t\t  if (isNullOrEmpty(renderWidth)) {\n\t\t    const displayWidth = readUsedSize(canvas, 'width');\n\t\t    if (displayWidth !== undefined) {\n\t\t      canvas.width = displayWidth;\n\t\t    }\n\t\t  }\n\t\t  if (isNullOrEmpty(renderHeight)) {\n\t\t    if (canvas.style.height === '') {\n\t\t      canvas.height = canvas.width / (aspectRatio || 2);\n\t\t    } else {\n\t\t      const displayHeight = readUsedSize(canvas, 'height');\n\t\t      if (displayHeight !== undefined) {\n\t\t        canvas.height = displayHeight;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return canvas;\n\t\t}\n\t\tconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\t\tfunction addListener(node, type, listener) {\n\t\t  node.addEventListener(type, listener, eventListenerOptions);\n\t\t}\n\t\tfunction removeListener(chart, type, listener) {\n\t\t  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n\t\t}\n\t\tfunction fromNativeEvent(event, chart) {\n\t\t  const type = EVENT_TYPES[event.type] || event.type;\n\t\t  const {x, y} = getRelativePosition$1(event, chart);\n\t\t  return {\n\t\t    type,\n\t\t    chart,\n\t\t    native: event,\n\t\t    x: x !== undefined ? x : null,\n\t\t    y: y !== undefined ? y : null,\n\t\t  };\n\t\t}\n\t\tfunction nodeListContains(nodeList, canvas) {\n\t\t  for (const node of nodeList) {\n\t\t    if (node === canvas || node.contains(canvas)) {\n\t\t      return true;\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction createAttachObserver(chart, type, listener) {\n\t\t  const canvas = chart.canvas;\n\t\t  const observer = new MutationObserver(entries => {\n\t\t    let trigger = false;\n\t\t    for (const entry of entries) {\n\t\t      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n\t\t      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n\t\t    }\n\t\t    if (trigger) {\n\t\t      listener();\n\t\t    }\n\t\t  });\n\t\t  observer.observe(document, {childList: true, subtree: true});\n\t\t  return observer;\n\t\t}\n\t\tfunction createDetachObserver(chart, type, listener) {\n\t\t  const canvas = chart.canvas;\n\t\t  const observer = new MutationObserver(entries => {\n\t\t    let trigger = false;\n\t\t    for (const entry of entries) {\n\t\t      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n\t\t      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n\t\t    }\n\t\t    if (trigger) {\n\t\t      listener();\n\t\t    }\n\t\t  });\n\t\t  observer.observe(document, {childList: true, subtree: true});\n\t\t  return observer;\n\t\t}\n\t\tconst drpListeningCharts = new Map();\n\t\tlet oldDevicePixelRatio = 0;\n\t\tfunction onWindowResize() {\n\t\t  const dpr = window.devicePixelRatio;\n\t\t  if (dpr === oldDevicePixelRatio) {\n\t\t    return;\n\t\t  }\n\t\t  oldDevicePixelRatio = dpr;\n\t\t  drpListeningCharts.forEach((resize, chart) => {\n\t\t    if (chart.currentDevicePixelRatio !== dpr) {\n\t\t      resize();\n\t\t    }\n\t\t  });\n\t\t}\n\t\tfunction listenDevicePixelRatioChanges(chart, resize) {\n\t\t  if (!drpListeningCharts.size) {\n\t\t    window.addEventListener('resize', onWindowResize);\n\t\t  }\n\t\t  drpListeningCharts.set(chart, resize);\n\t\t}\n\t\tfunction unlistenDevicePixelRatioChanges(chart) {\n\t\t  drpListeningCharts.delete(chart);\n\t\t  if (!drpListeningCharts.size) {\n\t\t    window.removeEventListener('resize', onWindowResize);\n\t\t  }\n\t\t}\n\t\tfunction createResizeObserver(chart, type, listener) {\n\t\t  const canvas = chart.canvas;\n\t\t  const container = canvas && _getParentNode(canvas);\n\t\t  if (!container) {\n\t\t    return;\n\t\t  }\n\t\t  const resize = throttled((width, height) => {\n\t\t    const w = container.clientWidth;\n\t\t    listener(width, height);\n\t\t    if (w < container.clientWidth) {\n\t\t      listener();\n\t\t    }\n\t\t  }, window);\n\t\t  const observer = new ResizeObserver(entries => {\n\t\t    const entry = entries[0];\n\t\t    const width = entry.contentRect.width;\n\t\t    const height = entry.contentRect.height;\n\t\t    if (width === 0 && height === 0) {\n\t\t      return;\n\t\t    }\n\t\t    resize(width, height);\n\t\t  });\n\t\t  observer.observe(container);\n\t\t  listenDevicePixelRatioChanges(chart, resize);\n\t\t  return observer;\n\t\t}\n\t\tfunction releaseObserver(chart, type, observer) {\n\t\t  if (observer) {\n\t\t    observer.disconnect();\n\t\t  }\n\t\t  if (type === 'resize') {\n\t\t    unlistenDevicePixelRatioChanges(chart);\n\t\t  }\n\t\t}\n\t\tfunction createProxyAndListen(chart, type, listener) {\n\t\t  const canvas = chart.canvas;\n\t\t  const proxy = throttled((event) => {\n\t\t    if (chart.ctx !== null) {\n\t\t      listener(fromNativeEvent(event, chart));\n\t\t    }\n\t\t  }, chart, (args) => {\n\t\t    const event = args[0];\n\t\t    return [event, event.offsetX, event.offsetY];\n\t\t  });\n\t\t  addListener(canvas, type, proxy);\n\t\t  return proxy;\n\t\t}\n\t\tclass DomPlatform extends BasePlatform {\n\t\t  acquireContext(canvas, aspectRatio) {\n\t\t    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\t\t    if (context && context.canvas === canvas) {\n\t\t      initCanvas(canvas, aspectRatio);\n\t\t      return context;\n\t\t    }\n\t\t    return null;\n\t\t  }\n\t\t  releaseContext(context) {\n\t\t    const canvas = context.canvas;\n\t\t    if (!canvas[EXPANDO_KEY]) {\n\t\t      return false;\n\t\t    }\n\t\t    const initial = canvas[EXPANDO_KEY].initial;\n\t\t    ['height', 'width'].forEach((prop) => {\n\t\t      const value = initial[prop];\n\t\t      if (isNullOrUndef(value)) {\n\t\t        canvas.removeAttribute(prop);\n\t\t      } else {\n\t\t        canvas.setAttribute(prop, value);\n\t\t      }\n\t\t    });\n\t\t    const style = initial.style || {};\n\t\t    Object.keys(style).forEach((key) => {\n\t\t      canvas.style[key] = style[key];\n\t\t    });\n\t\t    canvas.width = canvas.width;\n\t\t    delete canvas[EXPANDO_KEY];\n\t\t    return true;\n\t\t  }\n\t\t  addEventListener(chart, type, listener) {\n\t\t    this.removeEventListener(chart, type);\n\t\t    const proxies = chart.$proxies || (chart.$proxies = {});\n\t\t    const handlers = {\n\t\t      attach: createAttachObserver,\n\t\t      detach: createDetachObserver,\n\t\t      resize: createResizeObserver\n\t\t    };\n\t\t    const handler = handlers[type] || createProxyAndListen;\n\t\t    proxies[type] = handler(chart, type, listener);\n\t\t  }\n\t\t  removeEventListener(chart, type) {\n\t\t    const proxies = chart.$proxies || (chart.$proxies = {});\n\t\t    const proxy = proxies[type];\n\t\t    if (!proxy) {\n\t\t      return;\n\t\t    }\n\t\t    const handlers = {\n\t\t      attach: releaseObserver,\n\t\t      detach: releaseObserver,\n\t\t      resize: releaseObserver\n\t\t    };\n\t\t    const handler = handlers[type] || removeListener;\n\t\t    handler(chart, type, proxy);\n\t\t    proxies[type] = undefined;\n\t\t  }\n\t\t  getDevicePixelRatio() {\n\t\t    return window.devicePixelRatio;\n\t\t  }\n\t\t  getMaximumSize(canvas, width, height, aspectRatio) {\n\t\t    return getMaximumSize(canvas, width, height, aspectRatio);\n\t\t  }\n\t\t  isAttached(canvas) {\n\t\t    const container = _getParentNode(canvas);\n\t\t    return !!(container && container.isConnected);\n\t\t  }\n\t\t}\n\n\t\tfunction _detectPlatform(canvas) {\n\t\t  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n\t\t    return BasicPlatform;\n\t\t  }\n\t\t  return DomPlatform;\n\t\t}\n\n\t\tvar platforms = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\t_detectPlatform: _detectPlatform,\n\t\tBasePlatform: BasePlatform,\n\t\tBasicPlatform: BasicPlatform,\n\t\tDomPlatform: DomPlatform\n\t\t});\n\n\t\tconst transparent = 'transparent';\n\t\tconst interpolators = {\n\t\t  boolean(from, to, factor) {\n\t\t    return factor > 0.5 ? to : from;\n\t\t  },\n\t\t  color(from, to, factor) {\n\t\t    const c0 = color(from || transparent);\n\t\t    const c1 = c0.valid && color(to || transparent);\n\t\t    return c1 && c1.valid\n\t\t      ? c1.mix(c0, factor).hexString()\n\t\t      : to;\n\t\t  },\n\t\t  number(from, to, factor) {\n\t\t    return from + (to - from) * factor;\n\t\t  }\n\t\t};\n\t\tclass Animation {\n\t\t  constructor(cfg, target, prop, to) {\n\t\t    const currentValue = target[prop];\n\t\t    to = resolve([cfg.to, to, currentValue, cfg.from]);\n\t\t    const from = resolve([cfg.from, currentValue, to]);\n\t\t    this._active = true;\n\t\t    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n\t\t    this._easing = effects[cfg.easing] || effects.linear;\n\t\t    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n\t\t    this._duration = this._total = Math.floor(cfg.duration);\n\t\t    this._loop = !!cfg.loop;\n\t\t    this._target = target;\n\t\t    this._prop = prop;\n\t\t    this._from = from;\n\t\t    this._to = to;\n\t\t    this._promises = undefined;\n\t\t  }\n\t\t  active() {\n\t\t    return this._active;\n\t\t  }\n\t\t  update(cfg, to, date) {\n\t\t    if (this._active) {\n\t\t      this._notify(false);\n\t\t      const currentValue = this._target[this._prop];\n\t\t      const elapsed = date - this._start;\n\t\t      const remain = this._duration - elapsed;\n\t\t      this._start = date;\n\t\t      this._duration = Math.floor(Math.max(remain, cfg.duration));\n\t\t      this._total += elapsed;\n\t\t      this._loop = !!cfg.loop;\n\t\t      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n\t\t      this._from = resolve([cfg.from, currentValue, to]);\n\t\t    }\n\t\t  }\n\t\t  cancel() {\n\t\t    if (this._active) {\n\t\t      this.tick(Date.now());\n\t\t      this._active = false;\n\t\t      this._notify(false);\n\t\t    }\n\t\t  }\n\t\t  tick(date) {\n\t\t    const elapsed = date - this._start;\n\t\t    const duration = this._duration;\n\t\t    const prop = this._prop;\n\t\t    const from = this._from;\n\t\t    const loop = this._loop;\n\t\t    const to = this._to;\n\t\t    let factor;\n\t\t    this._active = from !== to && (loop || (elapsed < duration));\n\t\t    if (!this._active) {\n\t\t      this._target[prop] = to;\n\t\t      this._notify(true);\n\t\t      return;\n\t\t    }\n\t\t    if (elapsed < 0) {\n\t\t      this._target[prop] = from;\n\t\t      return;\n\t\t    }\n\t\t    factor = (elapsed / duration) % 2;\n\t\t    factor = loop && factor > 1 ? 2 - factor : factor;\n\t\t    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\t\t    this._target[prop] = this._fn(from, to, factor);\n\t\t  }\n\t\t  wait() {\n\t\t    const promises = this._promises || (this._promises = []);\n\t\t    return new Promise((res, rej) => {\n\t\t      promises.push({res, rej});\n\t\t    });\n\t\t  }\n\t\t  _notify(resolved) {\n\t\t    const method = resolved ? 'res' : 'rej';\n\t\t    const promises = this._promises || [];\n\t\t    for (let i = 0; i < promises.length; i++) {\n\t\t      promises[i][method]();\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\n\t\tconst colors = ['color', 'borderColor', 'backgroundColor'];\n\t\tdefaults.set('animation', {\n\t\t  delay: undefined,\n\t\t  duration: 1000,\n\t\t  easing: 'easeOutQuart',\n\t\t  fn: undefined,\n\t\t  from: undefined,\n\t\t  loop: undefined,\n\t\t  to: undefined,\n\t\t  type: undefined,\n\t\t});\n\t\tconst animationOptions = Object.keys(defaults.animation);\n\t\tdefaults.describe('animation', {\n\t\t  _fallback: false,\n\t\t  _indexable: false,\n\t\t  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n\t\t});\n\t\tdefaults.set('animations', {\n\t\t  colors: {\n\t\t    type: 'color',\n\t\t    properties: colors\n\t\t  },\n\t\t  numbers: {\n\t\t    type: 'number',\n\t\t    properties: numbers\n\t\t  },\n\t\t});\n\t\tdefaults.describe('animations', {\n\t\t  _fallback: 'animation',\n\t\t});\n\t\tdefaults.set('transitions', {\n\t\t  active: {\n\t\t    animation: {\n\t\t      duration: 400\n\t\t    }\n\t\t  },\n\t\t  resize: {\n\t\t    animation: {\n\t\t      duration: 0\n\t\t    }\n\t\t  },\n\t\t  show: {\n\t\t    animations: {\n\t\t      colors: {\n\t\t        from: 'transparent'\n\t\t      },\n\t\t      visible: {\n\t\t        type: 'boolean',\n\t\t        duration: 0\n\t\t      },\n\t\t    }\n\t\t  },\n\t\t  hide: {\n\t\t    animations: {\n\t\t      colors: {\n\t\t        to: 'transparent'\n\t\t      },\n\t\t      visible: {\n\t\t        type: 'boolean',\n\t\t        easing: 'linear',\n\t\t        fn: v => v | 0\n\t\t      },\n\t\t    }\n\t\t  }\n\t\t});\n\t\tclass Animations {\n\t\t  constructor(chart, config) {\n\t\t    this._chart = chart;\n\t\t    this._properties = new Map();\n\t\t    this.configure(config);\n\t\t  }\n\t\t  configure(config) {\n\t\t    if (!isObject(config)) {\n\t\t      return;\n\t\t    }\n\t\t    const animatedProps = this._properties;\n\t\t    Object.getOwnPropertyNames(config).forEach(key => {\n\t\t      const cfg = config[key];\n\t\t      if (!isObject(cfg)) {\n\t\t        return;\n\t\t      }\n\t\t      const resolved = {};\n\t\t      for (const option of animationOptions) {\n\t\t        resolved[option] = cfg[option];\n\t\t      }\n\t\t      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n\t\t        if (prop === key || !animatedProps.has(prop)) {\n\t\t          animatedProps.set(prop, resolved);\n\t\t        }\n\t\t      });\n\t\t    });\n\t\t  }\n\t\t  _animateOptions(target, values) {\n\t\t    const newOptions = values.options;\n\t\t    const options = resolveTargetOptions(target, newOptions);\n\t\t    if (!options) {\n\t\t      return [];\n\t\t    }\n\t\t    const animations = this._createAnimations(options, newOptions);\n\t\t    if (newOptions.$shared) {\n\t\t      awaitAll(target.options.$animations, newOptions).then(() => {\n\t\t        target.options = newOptions;\n\t\t      }, () => {\n\t\t      });\n\t\t    }\n\t\t    return animations;\n\t\t  }\n\t\t  _createAnimations(target, values) {\n\t\t    const animatedProps = this._properties;\n\t\t    const animations = [];\n\t\t    const running = target.$animations || (target.$animations = {});\n\t\t    const props = Object.keys(values);\n\t\t    const date = Date.now();\n\t\t    let i;\n\t\t    for (i = props.length - 1; i >= 0; --i) {\n\t\t      const prop = props[i];\n\t\t      if (prop.charAt(0) === '$') {\n\t\t        continue;\n\t\t      }\n\t\t      if (prop === 'options') {\n\t\t        animations.push(...this._animateOptions(target, values));\n\t\t        continue;\n\t\t      }\n\t\t      const value = values[prop];\n\t\t      let animation = running[prop];\n\t\t      const cfg = animatedProps.get(prop);\n\t\t      if (animation) {\n\t\t        if (cfg && animation.active()) {\n\t\t          animation.update(cfg, value, date);\n\t\t          continue;\n\t\t        } else {\n\t\t          animation.cancel();\n\t\t        }\n\t\t      }\n\t\t      if (!cfg || !cfg.duration) {\n\t\t        target[prop] = value;\n\t\t        continue;\n\t\t      }\n\t\t      running[prop] = animation = new Animation(cfg, target, prop, value);\n\t\t      animations.push(animation);\n\t\t    }\n\t\t    return animations;\n\t\t  }\n\t\t  update(target, values) {\n\t\t    if (this._properties.size === 0) {\n\t\t      Object.assign(target, values);\n\t\t      return;\n\t\t    }\n\t\t    const animations = this._createAnimations(target, values);\n\t\t    if (animations.length) {\n\t\t      animator.add(this._chart, animations);\n\t\t      return true;\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction awaitAll(animations, properties) {\n\t\t  const running = [];\n\t\t  const keys = Object.keys(properties);\n\t\t  for (let i = 0; i < keys.length; i++) {\n\t\t    const anim = animations[keys[i]];\n\t\t    if (anim && anim.active()) {\n\t\t      running.push(anim.wait());\n\t\t    }\n\t\t  }\n\t\t  return Promise.all(running);\n\t\t}\n\t\tfunction resolveTargetOptions(target, newOptions) {\n\t\t  if (!newOptions) {\n\t\t    return;\n\t\t  }\n\t\t  let options = target.options;\n\t\t  if (!options) {\n\t\t    target.options = newOptions;\n\t\t    return;\n\t\t  }\n\t\t  if (options.$shared) {\n\t\t    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n\t\t  }\n\t\t  return options;\n\t\t}\n\n\t\tfunction scaleClip(scale, allowedOverflow) {\n\t\t  const opts = scale && scale.options || {};\n\t\t  const reverse = opts.reverse;\n\t\t  const min = opts.min === undefined ? allowedOverflow : 0;\n\t\t  const max = opts.max === undefined ? allowedOverflow : 0;\n\t\t  return {\n\t\t    start: reverse ? max : min,\n\t\t    end: reverse ? min : max\n\t\t  };\n\t\t}\n\t\tfunction defaultClip(xScale, yScale, allowedOverflow) {\n\t\t  if (allowedOverflow === false) {\n\t\t    return false;\n\t\t  }\n\t\t  const x = scaleClip(xScale, allowedOverflow);\n\t\t  const y = scaleClip(yScale, allowedOverflow);\n\t\t  return {\n\t\t    top: y.end,\n\t\t    right: x.end,\n\t\t    bottom: y.start,\n\t\t    left: x.start\n\t\t  };\n\t\t}\n\t\tfunction toClip(value) {\n\t\t  let t, r, b, l;\n\t\t  if (isObject(value)) {\n\t\t    t = value.top;\n\t\t    r = value.right;\n\t\t    b = value.bottom;\n\t\t    l = value.left;\n\t\t  } else {\n\t\t    t = r = b = l = value;\n\t\t  }\n\t\t  return {\n\t\t    top: t,\n\t\t    right: r,\n\t\t    bottom: b,\n\t\t    left: l,\n\t\t    disabled: value === false\n\t\t  };\n\t\t}\n\t\tfunction getSortedDatasetIndices(chart, filterVisible) {\n\t\t  const keys = [];\n\t\t  const metasets = chart._getSortedDatasetMetas(filterVisible);\n\t\t  let i, ilen;\n\t\t  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\t    keys.push(metasets[i].index);\n\t\t  }\n\t\t  return keys;\n\t\t}\n\t\tfunction applyStack(stack, value, dsIndex, options = {}) {\n\t\t  const keys = stack.keys;\n\t\t  const singleMode = options.mode === 'single';\n\t\t  let i, ilen, datasetIndex, otherValue;\n\t\t  if (value === null) {\n\t\t    return;\n\t\t  }\n\t\t  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t    datasetIndex = +keys[i];\n\t\t    if (datasetIndex === dsIndex) {\n\t\t      if (options.all) {\n\t\t        continue;\n\t\t      }\n\t\t      break;\n\t\t    }\n\t\t    otherValue = stack.values[datasetIndex];\n\t\t    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n\t\t      value += otherValue;\n\t\t    }\n\t\t  }\n\t\t  return value;\n\t\t}\n\t\tfunction convertObjectDataToArray(data) {\n\t\t  const keys = Object.keys(data);\n\t\t  const adata = new Array(keys.length);\n\t\t  let i, ilen, key;\n\t\t  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t    key = keys[i];\n\t\t    adata[i] = {\n\t\t      x: key,\n\t\t      y: data[key]\n\t\t    };\n\t\t  }\n\t\t  return adata;\n\t\t}\n\t\tfunction isStacked(scale, meta) {\n\t\t  const stacked = scale && scale.options.stacked;\n\t\t  return stacked || (stacked === undefined && meta.stack !== undefined);\n\t\t}\n\t\tfunction getStackKey(indexScale, valueScale, meta) {\n\t\t  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n\t\t}\n\t\tfunction getUserBounds(scale) {\n\t\t  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n\t\t  return {\n\t\t    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n\t\t    max: maxDefined ? max : Number.POSITIVE_INFINITY\n\t\t  };\n\t\t}\n\t\tfunction getOrCreateStack(stacks, stackKey, indexValue) {\n\t\t  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n\t\t  return subStack[indexValue] || (subStack[indexValue] = {});\n\t\t}\n\t\tfunction getLastIndexInStack(stack, vScale, positive, type) {\n\t\t  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n\t\t    const value = stack[meta.index];\n\t\t    if ((positive && value > 0) || (!positive && value < 0)) {\n\t\t      return meta.index;\n\t\t    }\n\t\t  }\n\t\t  return null;\n\t\t}\n\t\tfunction updateStacks(controller, parsed) {\n\t\t  const {chart, _cachedMeta: meta} = controller;\n\t\t  const stacks = chart._stacks || (chart._stacks = {});\n\t\t  const {iScale, vScale, index: datasetIndex} = meta;\n\t\t  const iAxis = iScale.axis;\n\t\t  const vAxis = vScale.axis;\n\t\t  const key = getStackKey(iScale, vScale, meta);\n\t\t  const ilen = parsed.length;\n\t\t  let stack;\n\t\t  for (let i = 0; i < ilen; ++i) {\n\t\t    const item = parsed[i];\n\t\t    const {[iAxis]: index, [vAxis]: value} = item;\n\t\t    const itemStacks = item._stacks || (item._stacks = {});\n\t\t    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n\t\t    stack[datasetIndex] = value;\n\t\t    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n\t\t    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\t\t  }\n\t\t}\n\t\tfunction getFirstScaleId(chart, axis) {\n\t\t  const scales = chart.scales;\n\t\t  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n\t\t}\n\t\tfunction createDatasetContext(parent, index) {\n\t\t  return createContext(parent,\n\t\t    {\n\t\t      active: false,\n\t\t      dataset: undefined,\n\t\t      datasetIndex: index,\n\t\t      index,\n\t\t      mode: 'default',\n\t\t      type: 'dataset'\n\t\t    }\n\t\t  );\n\t\t}\n\t\tfunction createDataContext(parent, index, element) {\n\t\t  return createContext(parent, {\n\t\t    active: false,\n\t\t    dataIndex: index,\n\t\t    parsed: undefined,\n\t\t    raw: undefined,\n\t\t    element,\n\t\t    index,\n\t\t    mode: 'default',\n\t\t    type: 'data'\n\t\t  });\n\t\t}\n\t\tfunction clearStacks(meta, items) {\n\t\t  const datasetIndex = meta.controller.index;\n\t\t  const axis = meta.vScale && meta.vScale.axis;\n\t\t  if (!axis) {\n\t\t    return;\n\t\t  }\n\t\t  items = items || meta._parsed;\n\t\t  for (const parsed of items) {\n\t\t    const stacks = parsed._stacks;\n\t\t    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n\t\t      return;\n\t\t    }\n\t\t    delete stacks[axis][datasetIndex];\n\t\t  }\n\t\t}\n\t\tconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\n\t\tconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\n\t\tconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n\t\t  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\t\tclass DatasetController {\n\t\t  constructor(chart, datasetIndex) {\n\t\t    this.chart = chart;\n\t\t    this._ctx = chart.ctx;\n\t\t    this.index = datasetIndex;\n\t\t    this._cachedDataOpts = {};\n\t\t    this._cachedMeta = this.getMeta();\n\t\t    this._type = this._cachedMeta.type;\n\t\t    this.options = undefined;\n\t\t    this._parsing = false;\n\t\t    this._data = undefined;\n\t\t    this._objectData = undefined;\n\t\t    this._sharedOptions = undefined;\n\t\t    this._drawStart = undefined;\n\t\t    this._drawCount = undefined;\n\t\t    this.enableOptionSharing = false;\n\t\t    this.$context = undefined;\n\t\t    this._syncList = [];\n\t\t    this.initialize();\n\t\t  }\n\t\t  initialize() {\n\t\t    const meta = this._cachedMeta;\n\t\t    this.configure();\n\t\t    this.linkScales();\n\t\t    meta._stacked = isStacked(meta.vScale, meta);\n\t\t    this.addElements();\n\t\t  }\n\t\t  updateIndex(datasetIndex) {\n\t\t    if (this.index !== datasetIndex) {\n\t\t      clearStacks(this._cachedMeta);\n\t\t    }\n\t\t    this.index = datasetIndex;\n\t\t  }\n\t\t  linkScales() {\n\t\t    const chart = this.chart;\n\t\t    const meta = this._cachedMeta;\n\t\t    const dataset = this.getDataset();\n\t\t    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\t\t    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n\t\t    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n\t\t    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n\t\t    const indexAxis = meta.indexAxis;\n\t\t    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n\t\t    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n\t\t    meta.xScale = this.getScaleForId(xid);\n\t\t    meta.yScale = this.getScaleForId(yid);\n\t\t    meta.rScale = this.getScaleForId(rid);\n\t\t    meta.iScale = this.getScaleForId(iid);\n\t\t    meta.vScale = this.getScaleForId(vid);\n\t\t  }\n\t\t  getDataset() {\n\t\t    return this.chart.data.datasets[this.index];\n\t\t  }\n\t\t  getMeta() {\n\t\t    return this.chart.getDatasetMeta(this.index);\n\t\t  }\n\t\t  getScaleForId(scaleID) {\n\t\t    return this.chart.scales[scaleID];\n\t\t  }\n\t\t  _getOtherScale(scale) {\n\t\t    const meta = this._cachedMeta;\n\t\t    return scale === meta.iScale\n\t\t      ? meta.vScale\n\t\t      : meta.iScale;\n\t\t  }\n\t\t  reset() {\n\t\t    this._update('reset');\n\t\t  }\n\t\t  _destroy() {\n\t\t    const meta = this._cachedMeta;\n\t\t    if (this._data) {\n\t\t      unlistenArrayEvents(this._data, this);\n\t\t    }\n\t\t    if (meta._stacked) {\n\t\t      clearStacks(meta);\n\t\t    }\n\t\t  }\n\t\t  _dataCheck() {\n\t\t    const dataset = this.getDataset();\n\t\t    const data = dataset.data || (dataset.data = []);\n\t\t    const _data = this._data;\n\t\t    if (isObject(data)) {\n\t\t      this._data = convertObjectDataToArray(data);\n\t\t    } else if (_data !== data) {\n\t\t      if (_data) {\n\t\t        unlistenArrayEvents(_data, this);\n\t\t        const meta = this._cachedMeta;\n\t\t        clearStacks(meta);\n\t\t        meta._parsed = [];\n\t\t      }\n\t\t      if (data && Object.isExtensible(data)) {\n\t\t        listenArrayEvents(data, this);\n\t\t      }\n\t\t      this._syncList = [];\n\t\t      this._data = data;\n\t\t    }\n\t\t  }\n\t\t  addElements() {\n\t\t    const meta = this._cachedMeta;\n\t\t    this._dataCheck();\n\t\t    if (this.datasetElementType) {\n\t\t      meta.dataset = new this.datasetElementType();\n\t\t    }\n\t\t  }\n\t\t  buildOrUpdateElements(resetNewElements) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const dataset = this.getDataset();\n\t\t    let stackChanged = false;\n\t\t    this._dataCheck();\n\t\t    const oldStacked = meta._stacked;\n\t\t    meta._stacked = isStacked(meta.vScale, meta);\n\t\t    if (meta.stack !== dataset.stack) {\n\t\t      stackChanged = true;\n\t\t      clearStacks(meta);\n\t\t      meta.stack = dataset.stack;\n\t\t    }\n\t\t    this._resyncElements(resetNewElements);\n\t\t    if (stackChanged || oldStacked !== meta._stacked) {\n\t\t      updateStacks(this, meta._parsed);\n\t\t    }\n\t\t  }\n\t\t  configure() {\n\t\t    const config = this.chart.config;\n\t\t    const scopeKeys = config.datasetScopeKeys(this._type);\n\t\t    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n\t\t    this.options = config.createResolver(scopes, this.getContext());\n\t\t    this._parsing = this.options.parsing;\n\t\t    this._cachedDataOpts = {};\n\t\t  }\n\t\t  parse(start, count) {\n\t\t    const {_cachedMeta: meta, _data: data} = this;\n\t\t    const {iScale, _stacked} = meta;\n\t\t    const iAxis = iScale.axis;\n\t\t    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n\t\t    let prev = start > 0 && meta._parsed[start - 1];\n\t\t    let i, cur, parsed;\n\t\t    if (this._parsing === false) {\n\t\t      meta._parsed = data;\n\t\t      meta._sorted = true;\n\t\t      parsed = data;\n\t\t    } else {\n\t\t      if (isArray(data[start])) {\n\t\t        parsed = this.parseArrayData(meta, data, start, count);\n\t\t      } else if (isObject(data[start])) {\n\t\t        parsed = this.parseObjectData(meta, data, start, count);\n\t\t      } else {\n\t\t        parsed = this.parsePrimitiveData(meta, data, start, count);\n\t\t      }\n\t\t      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n\t\t      for (i = 0; i < count; ++i) {\n\t\t        meta._parsed[i + start] = cur = parsed[i];\n\t\t        if (sorted) {\n\t\t          if (isNotInOrderComparedToPrev()) {\n\t\t            sorted = false;\n\t\t          }\n\t\t          prev = cur;\n\t\t        }\n\t\t      }\n\t\t      meta._sorted = sorted;\n\t\t    }\n\t\t    if (_stacked) {\n\t\t      updateStacks(this, parsed);\n\t\t    }\n\t\t  }\n\t\t  parsePrimitiveData(meta, data, start, count) {\n\t\t    const {iScale, vScale} = meta;\n\t\t    const iAxis = iScale.axis;\n\t\t    const vAxis = vScale.axis;\n\t\t    const labels = iScale.getLabels();\n\t\t    const singleScale = iScale === vScale;\n\t\t    const parsed = new Array(count);\n\t\t    let i, ilen, index;\n\t\t    for (i = 0, ilen = count; i < ilen; ++i) {\n\t\t      index = i + start;\n\t\t      parsed[i] = {\n\t\t        [iAxis]: singleScale || iScale.parse(labels[index], index),\n\t\t        [vAxis]: vScale.parse(data[index], index)\n\t\t      };\n\t\t    }\n\t\t    return parsed;\n\t\t  }\n\t\t  parseArrayData(meta, data, start, count) {\n\t\t    const {xScale, yScale} = meta;\n\t\t    const parsed = new Array(count);\n\t\t    let i, ilen, index, item;\n\t\t    for (i = 0, ilen = count; i < ilen; ++i) {\n\t\t      index = i + start;\n\t\t      item = data[index];\n\t\t      parsed[i] = {\n\t\t        x: xScale.parse(item[0], index),\n\t\t        y: yScale.parse(item[1], index)\n\t\t      };\n\t\t    }\n\t\t    return parsed;\n\t\t  }\n\t\t  parseObjectData(meta, data, start, count) {\n\t\t    const {xScale, yScale} = meta;\n\t\t    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n\t\t    const parsed = new Array(count);\n\t\t    let i, ilen, index, item;\n\t\t    for (i = 0, ilen = count; i < ilen; ++i) {\n\t\t      index = i + start;\n\t\t      item = data[index];\n\t\t      parsed[i] = {\n\t\t        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n\t\t        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n\t\t      };\n\t\t    }\n\t\t    return parsed;\n\t\t  }\n\t\t  getParsed(index) {\n\t\t    return this._cachedMeta._parsed[index];\n\t\t  }\n\t\t  getDataElement(index) {\n\t\t    return this._cachedMeta.data[index];\n\t\t  }\n\t\t  applyStack(scale, parsed, mode) {\n\t\t    const chart = this.chart;\n\t\t    const meta = this._cachedMeta;\n\t\t    const value = parsed[scale.axis];\n\t\t    const stack = {\n\t\t      keys: getSortedDatasetIndices(chart, true),\n\t\t      values: parsed._stacks[scale.axis]\n\t\t    };\n\t\t    return applyStack(stack, value, meta.index, {mode});\n\t\t  }\n\t\t  updateRangeFromParsed(range, scale, parsed, stack) {\n\t\t    const parsedValue = parsed[scale.axis];\n\t\t    let value = parsedValue === null ? NaN : parsedValue;\n\t\t    const values = stack && parsed._stacks[scale.axis];\n\t\t    if (stack && values) {\n\t\t      stack.values = values;\n\t\t      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n\t\t    }\n\t\t    range.min = Math.min(range.min, value);\n\t\t    range.max = Math.max(range.max, value);\n\t\t  }\n\t\t  getMinMax(scale, canStack) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const _parsed = meta._parsed;\n\t\t    const sorted = meta._sorted && scale === meta.iScale;\n\t\t    const ilen = _parsed.length;\n\t\t    const otherScale = this._getOtherScale(scale);\n\t\t    const stack = createStack(canStack, meta, this.chart);\n\t\t    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\t\t    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n\t\t    let i, parsed;\n\t\t    function _skip() {\n\t\t      parsed = _parsed[i];\n\t\t      const otherValue = parsed[otherScale.axis];\n\t\t      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n\t\t    }\n\t\t    for (i = 0; i < ilen; ++i) {\n\t\t      if (_skip()) {\n\t\t        continue;\n\t\t      }\n\t\t      this.updateRangeFromParsed(range, scale, parsed, stack);\n\t\t      if (sorted) {\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t    if (sorted) {\n\t\t      for (i = ilen - 1; i >= 0; --i) {\n\t\t        if (_skip()) {\n\t\t          continue;\n\t\t        }\n\t\t        this.updateRangeFromParsed(range, scale, parsed, stack);\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t    return range;\n\t\t  }\n\t\t  getAllParsedValues(scale) {\n\t\t    const parsed = this._cachedMeta._parsed;\n\t\t    const values = [];\n\t\t    let i, ilen, value;\n\t\t    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n\t\t      value = parsed[i][scale.axis];\n\t\t      if (isNumberFinite(value)) {\n\t\t        values.push(value);\n\t\t      }\n\t\t    }\n\t\t    return values;\n\t\t  }\n\t\t  getMaxOverflow() {\n\t\t    return false;\n\t\t  }\n\t\t  getLabelAndValue(index) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const iScale = meta.iScale;\n\t\t    const vScale = meta.vScale;\n\t\t    const parsed = this.getParsed(index);\n\t\t    return {\n\t\t      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n\t\t      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n\t\t    };\n\t\t  }\n\t\t  _update(mode) {\n\t\t    const meta = this._cachedMeta;\n\t\t    this.update(mode || 'default');\n\t\t    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n\t\t  }\n\t\t  update(mode) {}\n\t\t  draw() {\n\t\t    const ctx = this._ctx;\n\t\t    const chart = this.chart;\n\t\t    const meta = this._cachedMeta;\n\t\t    const elements = meta.data || [];\n\t\t    const area = chart.chartArea;\n\t\t    const active = [];\n\t\t    const start = this._drawStart || 0;\n\t\t    const count = this._drawCount || (elements.length - start);\n\t\t    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n\t\t    let i;\n\t\t    if (meta.dataset) {\n\t\t      meta.dataset.draw(ctx, area, start, count);\n\t\t    }\n\t\t    for (i = start; i < start + count; ++i) {\n\t\t      const element = elements[i];\n\t\t      if (element.hidden) {\n\t\t        continue;\n\t\t      }\n\t\t      if (element.active && drawActiveElementsOnTop) {\n\t\t        active.push(element);\n\t\t      } else {\n\t\t        element.draw(ctx, area);\n\t\t      }\n\t\t    }\n\t\t    for (i = 0; i < active.length; ++i) {\n\t\t      active[i].draw(ctx, area);\n\t\t    }\n\t\t  }\n\t\t  getStyle(index, active) {\n\t\t    const mode = active ? 'active' : 'default';\n\t\t    return index === undefined && this._cachedMeta.dataset\n\t\t      ? this.resolveDatasetElementOptions(mode)\n\t\t      : this.resolveDataElementOptions(index || 0, mode);\n\t\t  }\n\t\t  getContext(index, active, mode) {\n\t\t    const dataset = this.getDataset();\n\t\t    let context;\n\t\t    if (index >= 0 && index < this._cachedMeta.data.length) {\n\t\t      const element = this._cachedMeta.data[index];\n\t\t      context = element.$context ||\n\t\t        (element.$context = createDataContext(this.getContext(), index, element));\n\t\t      context.parsed = this.getParsed(index);\n\t\t      context.raw = dataset.data[index];\n\t\t      context.index = context.dataIndex = index;\n\t\t    } else {\n\t\t      context = this.$context ||\n\t\t        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n\t\t      context.dataset = dataset;\n\t\t      context.index = context.datasetIndex = this.index;\n\t\t    }\n\t\t    context.active = !!active;\n\t\t    context.mode = mode;\n\t\t    return context;\n\t\t  }\n\t\t  resolveDatasetElementOptions(mode) {\n\t\t    return this._resolveElementOptions(this.datasetElementType.id, mode);\n\t\t  }\n\t\t  resolveDataElementOptions(index, mode) {\n\t\t    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n\t\t  }\n\t\t  _resolveElementOptions(elementType, mode = 'default', index) {\n\t\t    const active = mode === 'active';\n\t\t    const cache = this._cachedDataOpts;\n\t\t    const cacheKey = elementType + '-' + mode;\n\t\t    const cached = cache[cacheKey];\n\t\t    const sharing = this.enableOptionSharing && defined(index);\n\t\t    if (cached) {\n\t\t      return cloneIfNotShared(cached, sharing);\n\t\t    }\n\t\t    const config = this.chart.config;\n\t\t    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n\t\t    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n\t\t    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n\t\t    const names = Object.keys(defaults.elements[elementType]);\n\t\t    const context = () => this.getContext(index, active);\n\t\t    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\t\t    if (values.$shared) {\n\t\t      values.$shared = sharing;\n\t\t      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n\t\t    }\n\t\t    return values;\n\t\t  }\n\t\t  _resolveAnimations(index, transition, active) {\n\t\t    const chart = this.chart;\n\t\t    const cache = this._cachedDataOpts;\n\t\t    const cacheKey = `animation-${transition}`;\n\t\t    const cached = cache[cacheKey];\n\t\t    if (cached) {\n\t\t      return cached;\n\t\t    }\n\t\t    let options;\n\t\t    if (chart.options.animation !== false) {\n\t\t      const config = this.chart.config;\n\t\t      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n\t\t      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n\t\t      options = config.createResolver(scopes, this.getContext(index, active, transition));\n\t\t    }\n\t\t    const animations = new Animations(chart, options && options.animations);\n\t\t    if (options && options._cacheable) {\n\t\t      cache[cacheKey] = Object.freeze(animations);\n\t\t    }\n\t\t    return animations;\n\t\t  }\n\t\t  getSharedOptions(options) {\n\t\t    if (!options.$shared) {\n\t\t      return;\n\t\t    }\n\t\t    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n\t\t  }\n\t\t  includeOptions(mode, sharedOptions) {\n\t\t    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n\t\t  }\n\t\t  updateElement(element, index, properties, mode) {\n\t\t    if (isDirectUpdateMode(mode)) {\n\t\t      Object.assign(element, properties);\n\t\t    } else {\n\t\t      this._resolveAnimations(index, mode).update(element, properties);\n\t\t    }\n\t\t  }\n\t\t  updateSharedOptions(sharedOptions, mode, newOptions) {\n\t\t    if (sharedOptions && !isDirectUpdateMode(mode)) {\n\t\t      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n\t\t    }\n\t\t  }\n\t\t  _setStyle(element, index, mode, active) {\n\t\t    element.active = active;\n\t\t    const options = this.getStyle(index, active);\n\t\t    this._resolveAnimations(index, mode, active).update(element, {\n\t\t      options: (!active && this.getSharedOptions(options)) || options\n\t\t    });\n\t\t  }\n\t\t  removeHoverStyle(element, datasetIndex, index) {\n\t\t    this._setStyle(element, index, 'active', false);\n\t\t  }\n\t\t  setHoverStyle(element, datasetIndex, index) {\n\t\t    this._setStyle(element, index, 'active', true);\n\t\t  }\n\t\t  _removeDatasetHoverStyle() {\n\t\t    const element = this._cachedMeta.dataset;\n\t\t    if (element) {\n\t\t      this._setStyle(element, undefined, 'active', false);\n\t\t    }\n\t\t  }\n\t\t  _setDatasetHoverStyle() {\n\t\t    const element = this._cachedMeta.dataset;\n\t\t    if (element) {\n\t\t      this._setStyle(element, undefined, 'active', true);\n\t\t    }\n\t\t  }\n\t\t  _resyncElements(resetNewElements) {\n\t\t    const data = this._data;\n\t\t    const elements = this._cachedMeta.data;\n\t\t    for (const [method, arg1, arg2] of this._syncList) {\n\t\t      this[method](arg1, arg2);\n\t\t    }\n\t\t    this._syncList = [];\n\t\t    const numMeta = elements.length;\n\t\t    const numData = data.length;\n\t\t    const count = Math.min(numData, numMeta);\n\t\t    if (count) {\n\t\t      this.parse(0, count);\n\t\t    }\n\t\t    if (numData > numMeta) {\n\t\t      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n\t\t    } else if (numData < numMeta) {\n\t\t      this._removeElements(numData, numMeta - numData);\n\t\t    }\n\t\t  }\n\t\t  _insertElements(start, count, resetNewElements = true) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const data = meta.data;\n\t\t    const end = start + count;\n\t\t    let i;\n\t\t    const move = (arr) => {\n\t\t      arr.length += count;\n\t\t      for (i = arr.length - 1; i >= end; i--) {\n\t\t        arr[i] = arr[i - count];\n\t\t      }\n\t\t    };\n\t\t    move(data);\n\t\t    for (i = start; i < end; ++i) {\n\t\t      data[i] = new this.dataElementType();\n\t\t    }\n\t\t    if (this._parsing) {\n\t\t      move(meta._parsed);\n\t\t    }\n\t\t    this.parse(start, count);\n\t\t    if (resetNewElements) {\n\t\t      this.updateElements(data, start, count, 'reset');\n\t\t    }\n\t\t  }\n\t\t  updateElements(element, start, count, mode) {}\n\t\t  _removeElements(start, count) {\n\t\t    const meta = this._cachedMeta;\n\t\t    if (this._parsing) {\n\t\t      const removed = meta._parsed.splice(start, count);\n\t\t      if (meta._stacked) {\n\t\t        clearStacks(meta, removed);\n\t\t      }\n\t\t    }\n\t\t    meta.data.splice(start, count);\n\t\t  }\n\t\t  _sync(args) {\n\t\t    if (this._parsing) {\n\t\t      this._syncList.push(args);\n\t\t    } else {\n\t\t      const [method, arg1, arg2] = args;\n\t\t      this[method](arg1, arg2);\n\t\t    }\n\t\t    this.chart._dataChanges.push([this.index, ...args]);\n\t\t  }\n\t\t  _onDataPush() {\n\t\t    const count = arguments.length;\n\t\t    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n\t\t  }\n\t\t  _onDataPop() {\n\t\t    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n\t\t  }\n\t\t  _onDataShift() {\n\t\t    this._sync(['_removeElements', 0, 1]);\n\t\t  }\n\t\t  _onDataSplice(start, count) {\n\t\t    if (count) {\n\t\t      this._sync(['_removeElements', start, count]);\n\t\t    }\n\t\t    const newCount = arguments.length - 2;\n\t\t    if (newCount) {\n\t\t      this._sync(['_insertElements', start, newCount]);\n\t\t    }\n\t\t  }\n\t\t  _onDataUnshift() {\n\t\t    this._sync(['_insertElements', 0, arguments.length]);\n\t\t  }\n\t\t}\n\t\tDatasetController.defaults = {};\n\t\tDatasetController.prototype.datasetElementType = null;\n\t\tDatasetController.prototype.dataElementType = null;\n\n\t\tclass Element {\n\t\t  constructor() {\n\t\t    this.x = undefined;\n\t\t    this.y = undefined;\n\t\t    this.active = false;\n\t\t    this.options = undefined;\n\t\t    this.$animations = undefined;\n\t\t  }\n\t\t  tooltipPosition(useFinalPosition) {\n\t\t    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n\t\t    return {x, y};\n\t\t  }\n\t\t  hasValue() {\n\t\t    return isNumber(this.x) && isNumber(this.y);\n\t\t  }\n\t\t  getProps(props, final) {\n\t\t    const anims = this.$animations;\n\t\t    if (!final || !anims) {\n\t\t      return this;\n\t\t    }\n\t\t    const ret = {};\n\t\t    props.forEach(prop => {\n\t\t      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n\t\t    });\n\t\t    return ret;\n\t\t  }\n\t\t}\n\t\tElement.defaults = {};\n\t\tElement.defaultRoutes = undefined;\n\n\t\tconst formatters = {\n\t\t  values(value) {\n\t\t    return isArray(value) ? value : '' + value;\n\t\t  },\n\t\t  numeric(tickValue, index, ticks) {\n\t\t    if (tickValue === 0) {\n\t\t      return '0';\n\t\t    }\n\t\t    const locale = this.chart.options.locale;\n\t\t    let notation;\n\t\t    let delta = tickValue;\n\t\t    if (ticks.length > 1) {\n\t\t      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n\t\t      if (maxTick < 1e-4 || maxTick > 1e+15) {\n\t\t        notation = 'scientific';\n\t\t      }\n\t\t      delta = calculateDelta(tickValue, ticks);\n\t\t    }\n\t\t    const logDelta = log10(Math.abs(delta));\n\t\t    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\t\t    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n\t\t    Object.assign(options, this.options.ticks.format);\n\t\t    return formatNumber(tickValue, locale, options);\n\t\t  },\n\t\t  logarithmic(tickValue, index, ticks) {\n\t\t    if (tickValue === 0) {\n\t\t      return '0';\n\t\t    }\n\t\t    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\n\t\t    if (remain === 1 || remain === 2 || remain === 5) {\n\t\t      return formatters.numeric.call(this, tickValue, index, ticks);\n\t\t    }\n\t\t    return '';\n\t\t  }\n\t\t};\n\t\tfunction calculateDelta(tickValue, ticks) {\n\t\t  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\t\t  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n\t\t    delta = tickValue - Math.floor(tickValue);\n\t\t  }\n\t\t  return delta;\n\t\t}\n\t\tvar Ticks = {formatters};\n\n\t\tdefaults.set('scale', {\n\t\t  display: true,\n\t\t  offset: false,\n\t\t  reverse: false,\n\t\t  beginAtZero: false,\n\t\t  bounds: 'ticks',\n\t\t  grace: 0,\n\t\t  grid: {\n\t\t    display: true,\n\t\t    lineWidth: 1,\n\t\t    drawBorder: true,\n\t\t    drawOnChartArea: true,\n\t\t    drawTicks: true,\n\t\t    tickLength: 8,\n\t\t    tickWidth: (_ctx, options) => options.lineWidth,\n\t\t    tickColor: (_ctx, options) => options.color,\n\t\t    offset: false,\n\t\t    borderDash: [],\n\t\t    borderDashOffset: 0.0,\n\t\t    borderWidth: 1\n\t\t  },\n\t\t  title: {\n\t\t    display: false,\n\t\t    text: '',\n\t\t    padding: {\n\t\t      top: 4,\n\t\t      bottom: 4\n\t\t    }\n\t\t  },\n\t\t  ticks: {\n\t\t    minRotation: 0,\n\t\t    maxRotation: 50,\n\t\t    mirror: false,\n\t\t    textStrokeWidth: 0,\n\t\t    textStrokeColor: '',\n\t\t    padding: 3,\n\t\t    display: true,\n\t\t    autoSkip: true,\n\t\t    autoSkipPadding: 3,\n\t\t    labelOffset: 0,\n\t\t    callback: Ticks.formatters.values,\n\t\t    minor: {},\n\t\t    major: {},\n\t\t    align: 'center',\n\t\t    crossAlign: 'near',\n\t\t    showLabelBackdrop: false,\n\t\t    backdropColor: 'rgba(255, 255, 255, 0.75)',\n\t\t    backdropPadding: 2,\n\t\t  }\n\t\t});\n\t\tdefaults.route('scale.ticks', 'color', '', 'color');\n\t\tdefaults.route('scale.grid', 'color', '', 'borderColor');\n\t\tdefaults.route('scale.grid', 'borderColor', '', 'borderColor');\n\t\tdefaults.route('scale.title', 'color', '', 'color');\n\t\tdefaults.describe('scale', {\n\t\t  _fallback: false,\n\t\t  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n\t\t  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n\t\t});\n\t\tdefaults.describe('scales', {\n\t\t  _fallback: 'scale',\n\t\t});\n\t\tdefaults.describe('scale.ticks', {\n\t\t  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n\t\t  _indexable: (name) => name !== 'backdropPadding',\n\t\t});\n\n\t\tfunction autoSkip(scale, ticks) {\n\t\t  const tickOpts = scale.options.ticks;\n\t\t  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n\t\t  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n\t\t  const numMajorIndices = majorIndices.length;\n\t\t  const first = majorIndices[0];\n\t\t  const last = majorIndices[numMajorIndices - 1];\n\t\t  const newTicks = [];\n\t\t  if (numMajorIndices > ticksLimit) {\n\t\t    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n\t\t    return newTicks;\n\t\t  }\n\t\t  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\t\t  if (numMajorIndices > 0) {\n\t\t    let i, ilen;\n\t\t    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n\t\t    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n\t\t    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n\t\t      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n\t\t    }\n\t\t    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n\t\t    return newTicks;\n\t\t  }\n\t\t  skip(ticks, newTicks, spacing);\n\t\t  return newTicks;\n\t\t}\n\t\tfunction determineMaxTicks(scale) {\n\t\t  const offset = scale.options.offset;\n\t\t  const tickLength = scale._tickSize();\n\t\t  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n\t\t  const maxChart = scale._maxLength / tickLength;\n\t\t  return Math.floor(Math.min(maxScale, maxChart));\n\t\t}\n\t\tfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n\t\t  const evenMajorSpacing = getEvenSpacing(majorIndices);\n\t\t  const spacing = ticks.length / ticksLimit;\n\t\t  if (!evenMajorSpacing) {\n\t\t    return Math.max(spacing, 1);\n\t\t  }\n\t\t  const factors = _factorize(evenMajorSpacing);\n\t\t  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n\t\t    const factor = factors[i];\n\t\t    if (factor > spacing) {\n\t\t      return factor;\n\t\t    }\n\t\t  }\n\t\t  return Math.max(spacing, 1);\n\t\t}\n\t\tfunction getMajorIndices(ticks) {\n\t\t  const result = [];\n\t\t  let i, ilen;\n\t\t  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n\t\t    if (ticks[i].major) {\n\t\t      result.push(i);\n\t\t    }\n\t\t  }\n\t\t  return result;\n\t\t}\n\t\tfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n\t\t  let count = 0;\n\t\t  let next = majorIndices[0];\n\t\t  let i;\n\t\t  spacing = Math.ceil(spacing);\n\t\t  for (i = 0; i < ticks.length; i++) {\n\t\t    if (i === next) {\n\t\t      newTicks.push(ticks[i]);\n\t\t      count++;\n\t\t      next = majorIndices[count * spacing];\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n\t\t  const start = valueOrDefault(majorStart, 0);\n\t\t  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n\t\t  let count = 0;\n\t\t  let length, i, next;\n\t\t  spacing = Math.ceil(spacing);\n\t\t  if (majorEnd) {\n\t\t    length = majorEnd - majorStart;\n\t\t    spacing = length / Math.floor(length / spacing);\n\t\t  }\n\t\t  next = start;\n\t\t  while (next < 0) {\n\t\t    count++;\n\t\t    next = Math.round(start + count * spacing);\n\t\t  }\n\t\t  for (i = Math.max(start, 0); i < end; i++) {\n\t\t    if (i === next) {\n\t\t      newTicks.push(ticks[i]);\n\t\t      count++;\n\t\t      next = Math.round(start + count * spacing);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction getEvenSpacing(arr) {\n\t\t  const len = arr.length;\n\t\t  let i, diff;\n\t\t  if (len < 2) {\n\t\t    return false;\n\t\t  }\n\t\t  for (diff = arr[0], i = 1; i < len; ++i) {\n\t\t    if (arr[i] - arr[i - 1] !== diff) {\n\t\t      return false;\n\t\t    }\n\t\t  }\n\t\t  return diff;\n\t\t}\n\n\t\tconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\n\t\tconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\n\t\tfunction sample(arr, numItems) {\n\t\t  const result = [];\n\t\t  const increment = arr.length / numItems;\n\t\t  const len = arr.length;\n\t\t  let i = 0;\n\t\t  for (; i < len; i += increment) {\n\t\t    result.push(arr[Math.floor(i)]);\n\t\t  }\n\t\t  return result;\n\t\t}\n\t\tfunction getPixelForGridLine(scale, index, offsetGridLines) {\n\t\t  const length = scale.ticks.length;\n\t\t  const validIndex = Math.min(index, length - 1);\n\t\t  const start = scale._startPixel;\n\t\t  const end = scale._endPixel;\n\t\t  const epsilon = 1e-6;\n\t\t  let lineValue = scale.getPixelForTick(validIndex);\n\t\t  let offset;\n\t\t  if (offsetGridLines) {\n\t\t    if (length === 1) {\n\t\t      offset = Math.max(lineValue - start, end - lineValue);\n\t\t    } else if (index === 0) {\n\t\t      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t    } else {\n\t\t      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n\t\t    }\n\t\t    lineValue += validIndex < index ? offset : -offset;\n\t\t    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t  return lineValue;\n\t\t}\n\t\tfunction garbageCollect(caches, length) {\n\t\t  each(caches, (cache) => {\n\t\t    const gc = cache.gc;\n\t\t    const gcLen = gc.length / 2;\n\t\t    let i;\n\t\t    if (gcLen > length) {\n\t\t      for (i = 0; i < gcLen; ++i) {\n\t\t        delete cache.data[gc[i]];\n\t\t      }\n\t\t      gc.splice(0, gcLen);\n\t\t    }\n\t\t  });\n\t\t}\n\t\tfunction getTickMarkLength(options) {\n\t\t  return options.drawTicks ? options.tickLength : 0;\n\t\t}\n\t\tfunction getTitleHeight(options, fallback) {\n\t\t  if (!options.display) {\n\t\t    return 0;\n\t\t  }\n\t\t  const font = toFont(options.font, fallback);\n\t\t  const padding = toPadding(options.padding);\n\t\t  const lines = isArray(options.text) ? options.text.length : 1;\n\t\t  return (lines * font.lineHeight) + padding.height;\n\t\t}\n\t\tfunction createScaleContext(parent, scale) {\n\t\t  return createContext(parent, {\n\t\t    scale,\n\t\t    type: 'scale'\n\t\t  });\n\t\t}\n\t\tfunction createTickContext(parent, index, tick) {\n\t\t  return createContext(parent, {\n\t\t    tick,\n\t\t    index,\n\t\t    type: 'tick'\n\t\t  });\n\t\t}\n\t\tfunction titleAlign(align, position, reverse) {\n\t\t  let ret = _toLeftRightCenter(align);\n\t\t  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n\t\t    ret = reverseAlign(ret);\n\t\t  }\n\t\t  return ret;\n\t\t}\n\t\tfunction titleArgs(scale, offset, position, align) {\n\t\t  const {top, left, bottom, right, chart} = scale;\n\t\t  const {chartArea, scales} = chart;\n\t\t  let rotation = 0;\n\t\t  let maxWidth, titleX, titleY;\n\t\t  const height = bottom - top;\n\t\t  const width = right - left;\n\t\t  if (scale.isHorizontal()) {\n\t\t    titleX = _alignStartEnd(align, left, right);\n\t\t    if (isObject(position)) {\n\t\t      const positionAxisID = Object.keys(position)[0];\n\t\t      const value = position[positionAxisID];\n\t\t      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n\t\t    } else if (position === 'center') {\n\t\t      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n\t\t    } else {\n\t\t      titleY = offsetFromEdge(scale, position, offset);\n\t\t    }\n\t\t    maxWidth = right - left;\n\t\t  } else {\n\t\t    if (isObject(position)) {\n\t\t      const positionAxisID = Object.keys(position)[0];\n\t\t      const value = position[positionAxisID];\n\t\t      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n\t\t    } else if (position === 'center') {\n\t\t      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n\t\t    } else {\n\t\t      titleX = offsetFromEdge(scale, position, offset);\n\t\t    }\n\t\t    titleY = _alignStartEnd(align, bottom, top);\n\t\t    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n\t\t  }\n\t\t  return {titleX, titleY, maxWidth, rotation};\n\t\t}\n\t\tclass Scale extends Element {\n\t\t  constructor(cfg) {\n\t\t    super();\n\t\t    this.id = cfg.id;\n\t\t    this.type = cfg.type;\n\t\t    this.options = undefined;\n\t\t    this.ctx = cfg.ctx;\n\t\t    this.chart = cfg.chart;\n\t\t    this.top = undefined;\n\t\t    this.bottom = undefined;\n\t\t    this.left = undefined;\n\t\t    this.right = undefined;\n\t\t    this.width = undefined;\n\t\t    this.height = undefined;\n\t\t    this._margins = {\n\t\t      left: 0,\n\t\t      right: 0,\n\t\t      top: 0,\n\t\t      bottom: 0\n\t\t    };\n\t\t    this.maxWidth = undefined;\n\t\t    this.maxHeight = undefined;\n\t\t    this.paddingTop = undefined;\n\t\t    this.paddingBottom = undefined;\n\t\t    this.paddingLeft = undefined;\n\t\t    this.paddingRight = undefined;\n\t\t    this.axis = undefined;\n\t\t    this.labelRotation = undefined;\n\t\t    this.min = undefined;\n\t\t    this.max = undefined;\n\t\t    this._range = undefined;\n\t\t    this.ticks = [];\n\t\t    this._gridLineItems = null;\n\t\t    this._labelItems = null;\n\t\t    this._labelSizes = null;\n\t\t    this._length = 0;\n\t\t    this._maxLength = 0;\n\t\t    this._longestTextCache = {};\n\t\t    this._startPixel = undefined;\n\t\t    this._endPixel = undefined;\n\t\t    this._reversePixels = false;\n\t\t    this._userMax = undefined;\n\t\t    this._userMin = undefined;\n\t\t    this._suggestedMax = undefined;\n\t\t    this._suggestedMin = undefined;\n\t\t    this._ticksLength = 0;\n\t\t    this._borderValue = 0;\n\t\t    this._cache = {};\n\t\t    this._dataLimitsCached = false;\n\t\t    this.$context = undefined;\n\t\t  }\n\t\t  init(options) {\n\t\t    this.options = options.setContext(this.getContext());\n\t\t    this.axis = options.axis;\n\t\t    this._userMin = this.parse(options.min);\n\t\t    this._userMax = this.parse(options.max);\n\t\t    this._suggestedMin = this.parse(options.suggestedMin);\n\t\t    this._suggestedMax = this.parse(options.suggestedMax);\n\t\t  }\n\t\t  parse(raw, index) {\n\t\t    return raw;\n\t\t  }\n\t\t  getUserBounds() {\n\t\t    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n\t\t    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n\t\t    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n\t\t    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n\t\t    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n\t\t    return {\n\t\t      min: finiteOrDefault(_userMin, _suggestedMin),\n\t\t      max: finiteOrDefault(_userMax, _suggestedMax),\n\t\t      minDefined: isNumberFinite(_userMin),\n\t\t      maxDefined: isNumberFinite(_userMax)\n\t\t    };\n\t\t  }\n\t\t  getMinMax(canStack) {\n\t\t    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\t\t    let range;\n\t\t    if (minDefined && maxDefined) {\n\t\t      return {min, max};\n\t\t    }\n\t\t    const metas = this.getMatchingVisibleMetas();\n\t\t    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n\t\t      range = metas[i].controller.getMinMax(this, canStack);\n\t\t      if (!minDefined) {\n\t\t        min = Math.min(min, range.min);\n\t\t      }\n\t\t      if (!maxDefined) {\n\t\t        max = Math.max(max, range.max);\n\t\t      }\n\t\t    }\n\t\t    min = maxDefined && min > max ? max : min;\n\t\t    max = minDefined && min > max ? min : max;\n\t\t    return {\n\t\t      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n\t\t      max: finiteOrDefault(max, finiteOrDefault(min, max))\n\t\t    };\n\t\t  }\n\t\t  getPadding() {\n\t\t    return {\n\t\t      left: this.paddingLeft || 0,\n\t\t      top: this.paddingTop || 0,\n\t\t      right: this.paddingRight || 0,\n\t\t      bottom: this.paddingBottom || 0\n\t\t    };\n\t\t  }\n\t\t  getTicks() {\n\t\t    return this.ticks;\n\t\t  }\n\t\t  getLabels() {\n\t\t    const data = this.chart.data;\n\t\t    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n\t\t  }\n\t\t  beforeLayout() {\n\t\t    this._cache = {};\n\t\t    this._dataLimitsCached = false;\n\t\t  }\n\t\t  beforeUpdate() {\n\t\t    callback(this.options.beforeUpdate, [this]);\n\t\t  }\n\t\t  update(maxWidth, maxHeight, margins) {\n\t\t    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n\t\t    const sampleSize = tickOpts.sampleSize;\n\t\t    this.beforeUpdate();\n\t\t    this.maxWidth = maxWidth;\n\t\t    this.maxHeight = maxHeight;\n\t\t    this._margins = margins = Object.assign({\n\t\t      left: 0,\n\t\t      right: 0,\n\t\t      top: 0,\n\t\t      bottom: 0\n\t\t    }, margins);\n\t\t    this.ticks = null;\n\t\t    this._labelSizes = null;\n\t\t    this._gridLineItems = null;\n\t\t    this._labelItems = null;\n\t\t    this.beforeSetDimensions();\n\t\t    this.setDimensions();\n\t\t    this.afterSetDimensions();\n\t\t    this._maxLength = this.isHorizontal()\n\t\t      ? this.width + margins.left + margins.right\n\t\t      : this.height + margins.top + margins.bottom;\n\t\t    if (!this._dataLimitsCached) {\n\t\t      this.beforeDataLimits();\n\t\t      this.determineDataLimits();\n\t\t      this.afterDataLimits();\n\t\t      this._range = _addGrace(this, grace, beginAtZero);\n\t\t      this._dataLimitsCached = true;\n\t\t    }\n\t\t    this.beforeBuildTicks();\n\t\t    this.ticks = this.buildTicks() || [];\n\t\t    this.afterBuildTicks();\n\t\t    const samplingEnabled = sampleSize < this.ticks.length;\n\t\t    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\t\t    this.configure();\n\t\t    this.beforeCalculateLabelRotation();\n\t\t    this.calculateLabelRotation();\n\t\t    this.afterCalculateLabelRotation();\n\t\t    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n\t\t      this.ticks = autoSkip(this, this.ticks);\n\t\t      this._labelSizes = null;\n\t\t    }\n\t\t    if (samplingEnabled) {\n\t\t      this._convertTicksToLabels(this.ticks);\n\t\t    }\n\t\t    this.beforeFit();\n\t\t    this.fit();\n\t\t    this.afterFit();\n\t\t    this.afterUpdate();\n\t\t  }\n\t\t  configure() {\n\t\t    let reversePixels = this.options.reverse;\n\t\t    let startPixel, endPixel;\n\t\t    if (this.isHorizontal()) {\n\t\t      startPixel = this.left;\n\t\t      endPixel = this.right;\n\t\t    } else {\n\t\t      startPixel = this.top;\n\t\t      endPixel = this.bottom;\n\t\t      reversePixels = !reversePixels;\n\t\t    }\n\t\t    this._startPixel = startPixel;\n\t\t    this._endPixel = endPixel;\n\t\t    this._reversePixels = reversePixels;\n\t\t    this._length = endPixel - startPixel;\n\t\t    this._alignToPixels = this.options.alignToPixels;\n\t\t  }\n\t\t  afterUpdate() {\n\t\t    callback(this.options.afterUpdate, [this]);\n\t\t  }\n\t\t  beforeSetDimensions() {\n\t\t    callback(this.options.beforeSetDimensions, [this]);\n\t\t  }\n\t\t  setDimensions() {\n\t\t    if (this.isHorizontal()) {\n\t\t      this.width = this.maxWidth;\n\t\t      this.left = 0;\n\t\t      this.right = this.width;\n\t\t    } else {\n\t\t      this.height = this.maxHeight;\n\t\t      this.top = 0;\n\t\t      this.bottom = this.height;\n\t\t    }\n\t\t    this.paddingLeft = 0;\n\t\t    this.paddingTop = 0;\n\t\t    this.paddingRight = 0;\n\t\t    this.paddingBottom = 0;\n\t\t  }\n\t\t  afterSetDimensions() {\n\t\t    callback(this.options.afterSetDimensions, [this]);\n\t\t  }\n\t\t  _callHooks(name) {\n\t\t    this.chart.notifyPlugins(name, this.getContext());\n\t\t    callback(this.options[name], [this]);\n\t\t  }\n\t\t  beforeDataLimits() {\n\t\t    this._callHooks('beforeDataLimits');\n\t\t  }\n\t\t  determineDataLimits() {}\n\t\t  afterDataLimits() {\n\t\t    this._callHooks('afterDataLimits');\n\t\t  }\n\t\t  beforeBuildTicks() {\n\t\t    this._callHooks('beforeBuildTicks');\n\t\t  }\n\t\t  buildTicks() {\n\t\t    return [];\n\t\t  }\n\t\t  afterBuildTicks() {\n\t\t    this._callHooks('afterBuildTicks');\n\t\t  }\n\t\t  beforeTickToLabelConversion() {\n\t\t    callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t  }\n\t\t  generateTickLabels(ticks) {\n\t\t    const tickOpts = this.options.ticks;\n\t\t    let i, ilen, tick;\n\t\t    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n\t\t      tick = ticks[i];\n\t\t      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\n\t\t    }\n\t\t  }\n\t\t  afterTickToLabelConversion() {\n\t\t    callback(this.options.afterTickToLabelConversion, [this]);\n\t\t  }\n\t\t  beforeCalculateLabelRotation() {\n\t\t    callback(this.options.beforeCalculateLabelRotation, [this]);\n\t\t  }\n\t\t  calculateLabelRotation() {\n\t\t    const options = this.options;\n\t\t    const tickOpts = options.ticks;\n\t\t    const numTicks = this.ticks.length;\n\t\t    const minRotation = tickOpts.minRotation || 0;\n\t\t    const maxRotation = tickOpts.maxRotation;\n\t\t    let labelRotation = minRotation;\n\t\t    let tickWidth, maxHeight, maxLabelDiagonal;\n\t\t    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n\t\t      this.labelRotation = minRotation;\n\t\t      return;\n\t\t    }\n\t\t    const labelSizes = this._getLabelSizes();\n\t\t    const maxLabelWidth = labelSizes.widest.width;\n\t\t    const maxLabelHeight = labelSizes.highest.height;\n\t\t    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n\t\t    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\t\t    if (maxLabelWidth + 6 > tickWidth) {\n\t\t      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n\t\t      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n\t\t      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n\t\t      labelRotation = toDegrees(Math.min(\n\t\t        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n\t\t        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n\t\t      ));\n\t\t      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n\t\t    }\n\t\t    this.labelRotation = labelRotation;\n\t\t  }\n\t\t  afterCalculateLabelRotation() {\n\t\t    callback(this.options.afterCalculateLabelRotation, [this]);\n\t\t  }\n\t\t  beforeFit() {\n\t\t    callback(this.options.beforeFit, [this]);\n\t\t  }\n\t\t  fit() {\n\t\t    const minSize = {\n\t\t      width: 0,\n\t\t      height: 0\n\t\t    };\n\t\t    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n\t\t    const display = this._isVisible();\n\t\t    const isHorizontal = this.isHorizontal();\n\t\t    if (display) {\n\t\t      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n\t\t      if (isHorizontal) {\n\t\t        minSize.width = this.maxWidth;\n\t\t        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n\t\t      } else {\n\t\t        minSize.height = this.maxHeight;\n\t\t        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n\t\t      }\n\t\t      if (tickOpts.display && this.ticks.length) {\n\t\t        const {first, last, widest, highest} = this._getLabelSizes();\n\t\t        const tickPadding = tickOpts.padding * 2;\n\t\t        const angleRadians = toRadians(this.labelRotation);\n\t\t        const cos = Math.cos(angleRadians);\n\t\t        const sin = Math.sin(angleRadians);\n\t\t        if (isHorizontal) {\n\t\t          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n\t\t          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n\t\t        } else {\n\t\t          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\t\t          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n\t\t        }\n\t\t        this._calculatePadding(first, last, sin, cos);\n\t\t      }\n\t\t    }\n\t\t    this._handleMargins();\n\t\t    if (isHorizontal) {\n\t\t      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n\t\t      this.height = minSize.height;\n\t\t    } else {\n\t\t      this.width = minSize.width;\n\t\t      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n\t\t    }\n\t\t  }\n\t\t  _calculatePadding(first, last, sin, cos) {\n\t\t    const {ticks: {align, padding}, position} = this.options;\n\t\t    const isRotated = this.labelRotation !== 0;\n\t\t    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\t\t    if (this.isHorizontal()) {\n\t\t      const offsetLeft = this.getPixelForTick(0) - this.left;\n\t\t      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n\t\t      let paddingLeft = 0;\n\t\t      let paddingRight = 0;\n\t\t      if (isRotated) {\n\t\t        if (labelsBelowTicks) {\n\t\t          paddingLeft = cos * first.width;\n\t\t          paddingRight = sin * last.height;\n\t\t        } else {\n\t\t          paddingLeft = sin * first.height;\n\t\t          paddingRight = cos * last.width;\n\t\t        }\n\t\t      } else if (align === 'start') {\n\t\t        paddingRight = last.width;\n\t\t      } else if (align === 'end') {\n\t\t        paddingLeft = first.width;\n\t\t      } else {\n\t\t        paddingLeft = first.width / 2;\n\t\t        paddingRight = last.width / 2;\n\t\t      }\n\t\t      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n\t\t      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n\t\t    } else {\n\t\t      let paddingTop = last.height / 2;\n\t\t      let paddingBottom = first.height / 2;\n\t\t      if (align === 'start') {\n\t\t        paddingTop = 0;\n\t\t        paddingBottom = first.height;\n\t\t      } else if (align === 'end') {\n\t\t        paddingTop = last.height;\n\t\t        paddingBottom = 0;\n\t\t      }\n\t\t      this.paddingTop = paddingTop + padding;\n\t\t      this.paddingBottom = paddingBottom + padding;\n\t\t    }\n\t\t  }\n\t\t  _handleMargins() {\n\t\t    if (this._margins) {\n\t\t      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n\t\t      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n\t\t      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n\t\t      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n\t\t    }\n\t\t  }\n\t\t  afterFit() {\n\t\t    callback(this.options.afterFit, [this]);\n\t\t  }\n\t\t  isHorizontal() {\n\t\t    const {axis, position} = this.options;\n\t\t    return position === 'top' || position === 'bottom' || axis === 'x';\n\t\t  }\n\t\t  isFullSize() {\n\t\t    return this.options.fullSize;\n\t\t  }\n\t\t  _convertTicksToLabels(ticks) {\n\t\t    this.beforeTickToLabelConversion();\n\t\t    this.generateTickLabels(ticks);\n\t\t    let i, ilen;\n\t\t    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n\t\t      if (isNullOrUndef(ticks[i].label)) {\n\t\t        ticks.splice(i, 1);\n\t\t        ilen--;\n\t\t        i--;\n\t\t      }\n\t\t    }\n\t\t    this.afterTickToLabelConversion();\n\t\t  }\n\t\t  _getLabelSizes() {\n\t\t    let labelSizes = this._labelSizes;\n\t\t    if (!labelSizes) {\n\t\t      const sampleSize = this.options.ticks.sampleSize;\n\t\t      let ticks = this.ticks;\n\t\t      if (sampleSize < ticks.length) {\n\t\t        ticks = sample(ticks, sampleSize);\n\t\t      }\n\t\t      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n\t\t    }\n\t\t    return labelSizes;\n\t\t  }\n\t\t  _computeLabelSizes(ticks, length) {\n\t\t    const {ctx, _longestTextCache: caches} = this;\n\t\t    const widths = [];\n\t\t    const heights = [];\n\t\t    let widestLabelSize = 0;\n\t\t    let highestLabelSize = 0;\n\t\t    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\t\t    for (i = 0; i < length; ++i) {\n\t\t      label = ticks[i].label;\n\t\t      tickFont = this._resolveTickFontOptions(i);\n\t\t      ctx.font = fontString = tickFont.string;\n\t\t      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n\t\t      lineHeight = tickFont.lineHeight;\n\t\t      width = height = 0;\n\t\t      if (!isNullOrUndef(label) && !isArray(label)) {\n\t\t        width = _measureText(ctx, cache.data, cache.gc, width, label);\n\t\t        height = lineHeight;\n\t\t      } else if (isArray(label)) {\n\t\t        for (j = 0, jlen = label.length; j < jlen; ++j) {\n\t\t          nestedLabel = label[j];\n\t\t          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n\t\t            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n\t\t            height += lineHeight;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      widths.push(width);\n\t\t      heights.push(height);\n\t\t      widestLabelSize = Math.max(width, widestLabelSize);\n\t\t      highestLabelSize = Math.max(height, highestLabelSize);\n\t\t    }\n\t\t    garbageCollect(caches, length);\n\t\t    const widest = widths.indexOf(widestLabelSize);\n\t\t    const highest = heights.indexOf(highestLabelSize);\n\t\t    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\t\t    return {\n\t\t      first: valueAt(0),\n\t\t      last: valueAt(length - 1),\n\t\t      widest: valueAt(widest),\n\t\t      highest: valueAt(highest),\n\t\t      widths,\n\t\t      heights,\n\t\t    };\n\t\t  }\n\t\t  getLabelForValue(value) {\n\t\t    return value;\n\t\t  }\n\t\t  getPixelForValue(value, index) {\n\t\t    return NaN;\n\t\t  }\n\t\t  getValueForPixel(pixel) {}\n\t\t  getPixelForTick(index) {\n\t\t    const ticks = this.ticks;\n\t\t    if (index < 0 || index > ticks.length - 1) {\n\t\t      return null;\n\t\t    }\n\t\t    return this.getPixelForValue(ticks[index].value);\n\t\t  }\n\t\t  getPixelForDecimal(decimal) {\n\t\t    if (this._reversePixels) {\n\t\t      decimal = 1 - decimal;\n\t\t    }\n\t\t    const pixel = this._startPixel + decimal * this._length;\n\t\t    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n\t\t  }\n\t\t  getDecimalForPixel(pixel) {\n\t\t    const decimal = (pixel - this._startPixel) / this._length;\n\t\t    return this._reversePixels ? 1 - decimal : decimal;\n\t\t  }\n\t\t  getBasePixel() {\n\t\t    return this.getPixelForValue(this.getBaseValue());\n\t\t  }\n\t\t  getBaseValue() {\n\t\t    const {min, max} = this;\n\t\t    return min < 0 && max < 0 ? max :\n\t\t      min > 0 && max > 0 ? min :\n\t\t      0;\n\t\t  }\n\t\t  getContext(index) {\n\t\t    const ticks = this.ticks || [];\n\t\t    if (index >= 0 && index < ticks.length) {\n\t\t      const tick = ticks[index];\n\t\t      return tick.$context ||\n\t\t\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n\t\t    }\n\t\t    return this.$context ||\n\t\t\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n\t\t  }\n\t\t  _tickSize() {\n\t\t    const optionTicks = this.options.ticks;\n\t\t    const rot = toRadians(this.labelRotation);\n\t\t    const cos = Math.abs(Math.cos(rot));\n\t\t    const sin = Math.abs(Math.sin(rot));\n\t\t    const labelSizes = this._getLabelSizes();\n\t\t    const padding = optionTicks.autoSkipPadding || 0;\n\t\t    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n\t\t    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\t\t    return this.isHorizontal()\n\t\t      ? h * cos > w * sin ? w / cos : h / sin\n\t\t      : h * sin < w * cos ? h / cos : w / sin;\n\t\t  }\n\t\t  _isVisible() {\n\t\t    const display = this.options.display;\n\t\t    if (display !== 'auto') {\n\t\t      return !!display;\n\t\t    }\n\t\t    return this.getMatchingVisibleMetas().length > 0;\n\t\t  }\n\t\t  _computeGridLineItems(chartArea) {\n\t\t    const axis = this.axis;\n\t\t    const chart = this.chart;\n\t\t    const options = this.options;\n\t\t    const {grid, position} = options;\n\t\t    const offset = grid.offset;\n\t\t    const isHorizontal = this.isHorizontal();\n\t\t    const ticks = this.ticks;\n\t\t    const ticksLength = ticks.length + (offset ? 1 : 0);\n\t\t    const tl = getTickMarkLength(grid);\n\t\t    const items = [];\n\t\t    const borderOpts = grid.setContext(this.getContext());\n\t\t    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n\t\t    const axisHalfWidth = axisWidth / 2;\n\t\t    const alignBorderValue = function(pixel) {\n\t\t      return _alignPixel(chart, pixel, axisWidth);\n\t\t    };\n\t\t    let borderValue, i, lineValue, alignedLineValue;\n\t\t    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\t\t    if (position === 'top') {\n\t\t      borderValue = alignBorderValue(this.bottom);\n\t\t      ty1 = this.bottom - tl;\n\t\t      ty2 = borderValue - axisHalfWidth;\n\t\t      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n\t\t      y2 = chartArea.bottom;\n\t\t    } else if (position === 'bottom') {\n\t\t      borderValue = alignBorderValue(this.top);\n\t\t      y1 = chartArea.top;\n\t\t      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n\t\t      ty1 = borderValue + axisHalfWidth;\n\t\t      ty2 = this.top + tl;\n\t\t    } else if (position === 'left') {\n\t\t      borderValue = alignBorderValue(this.right);\n\t\t      tx1 = this.right - tl;\n\t\t      tx2 = borderValue - axisHalfWidth;\n\t\t      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n\t\t      x2 = chartArea.right;\n\t\t    } else if (position === 'right') {\n\t\t      borderValue = alignBorderValue(this.left);\n\t\t      x1 = chartArea.left;\n\t\t      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n\t\t      tx1 = borderValue + axisHalfWidth;\n\t\t      tx2 = this.left + tl;\n\t\t    } else if (axis === 'x') {\n\t\t      if (position === 'center') {\n\t\t        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n\t\t      } else if (isObject(position)) {\n\t\t        const positionAxisID = Object.keys(position)[0];\n\t\t        const value = position[positionAxisID];\n\t\t        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n\t\t      }\n\t\t      y1 = chartArea.top;\n\t\t      y2 = chartArea.bottom;\n\t\t      ty1 = borderValue + axisHalfWidth;\n\t\t      ty2 = ty1 + tl;\n\t\t    } else if (axis === 'y') {\n\t\t      if (position === 'center') {\n\t\t        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n\t\t      } else if (isObject(position)) {\n\t\t        const positionAxisID = Object.keys(position)[0];\n\t\t        const value = position[positionAxisID];\n\t\t        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n\t\t      }\n\t\t      tx1 = borderValue - axisHalfWidth;\n\t\t      tx2 = tx1 - tl;\n\t\t      x1 = chartArea.left;\n\t\t      x2 = chartArea.right;\n\t\t    }\n\t\t    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n\t\t    const step = Math.max(1, Math.ceil(ticksLength / limit));\n\t\t    for (i = 0; i < ticksLength; i += step) {\n\t\t      const optsAtIndex = grid.setContext(this.getContext(i));\n\t\t      const lineWidth = optsAtIndex.lineWidth;\n\t\t      const lineColor = optsAtIndex.color;\n\t\t      const borderDash = grid.borderDash || [];\n\t\t      const borderDashOffset = optsAtIndex.borderDashOffset;\n\t\t      const tickWidth = optsAtIndex.tickWidth;\n\t\t      const tickColor = optsAtIndex.tickColor;\n\t\t      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n\t\t      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\t\t      lineValue = getPixelForGridLine(this, i, offset);\n\t\t      if (lineValue === undefined) {\n\t\t        continue;\n\t\t      }\n\t\t      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\t\t      if (isHorizontal) {\n\t\t        tx1 = tx2 = x1 = x2 = alignedLineValue;\n\t\t      } else {\n\t\t        ty1 = ty2 = y1 = y2 = alignedLineValue;\n\t\t      }\n\t\t      items.push({\n\t\t        tx1,\n\t\t        ty1,\n\t\t        tx2,\n\t\t        ty2,\n\t\t        x1,\n\t\t        y1,\n\t\t        x2,\n\t\t        y2,\n\t\t        width: lineWidth,\n\t\t        color: lineColor,\n\t\t        borderDash,\n\t\t        borderDashOffset,\n\t\t        tickWidth,\n\t\t        tickColor,\n\t\t        tickBorderDash,\n\t\t        tickBorderDashOffset,\n\t\t      });\n\t\t    }\n\t\t    this._ticksLength = ticksLength;\n\t\t    this._borderValue = borderValue;\n\t\t    return items;\n\t\t  }\n\t\t  _computeLabelItems(chartArea) {\n\t\t    const axis = this.axis;\n\t\t    const options = this.options;\n\t\t    const {position, ticks: optionTicks} = options;\n\t\t    const isHorizontal = this.isHorizontal();\n\t\t    const ticks = this.ticks;\n\t\t    const {align, crossAlign, padding, mirror} = optionTicks;\n\t\t    const tl = getTickMarkLength(options.grid);\n\t\t    const tickAndPadding = tl + padding;\n\t\t    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n\t\t    const rotation = -toRadians(this.labelRotation);\n\t\t    const items = [];\n\t\t    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n\t\t    let textBaseline = 'middle';\n\t\t    if (position === 'top') {\n\t\t      y = this.bottom - hTickAndPadding;\n\t\t      textAlign = this._getXAxisLabelAlignment();\n\t\t    } else if (position === 'bottom') {\n\t\t      y = this.top + hTickAndPadding;\n\t\t      textAlign = this._getXAxisLabelAlignment();\n\t\t    } else if (position === 'left') {\n\t\t      const ret = this._getYAxisLabelAlignment(tl);\n\t\t      textAlign = ret.textAlign;\n\t\t      x = ret.x;\n\t\t    } else if (position === 'right') {\n\t\t      const ret = this._getYAxisLabelAlignment(tl);\n\t\t      textAlign = ret.textAlign;\n\t\t      x = ret.x;\n\t\t    } else if (axis === 'x') {\n\t\t      if (position === 'center') {\n\t\t        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n\t\t      } else if (isObject(position)) {\n\t\t        const positionAxisID = Object.keys(position)[0];\n\t\t        const value = position[positionAxisID];\n\t\t        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n\t\t      }\n\t\t      textAlign = this._getXAxisLabelAlignment();\n\t\t    } else if (axis === 'y') {\n\t\t      if (position === 'center') {\n\t\t        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n\t\t      } else if (isObject(position)) {\n\t\t        const positionAxisID = Object.keys(position)[0];\n\t\t        const value = position[positionAxisID];\n\t\t        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n\t\t      }\n\t\t      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n\t\t    }\n\t\t    if (axis === 'y') {\n\t\t      if (align === 'start') {\n\t\t        textBaseline = 'top';\n\t\t      } else if (align === 'end') {\n\t\t        textBaseline = 'bottom';\n\t\t      }\n\t\t    }\n\t\t    const labelSizes = this._getLabelSizes();\n\t\t    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t      tick = ticks[i];\n\t\t      label = tick.label;\n\t\t      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n\t\t      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n\t\t      font = this._resolveTickFontOptions(i);\n\t\t      lineHeight = font.lineHeight;\n\t\t      lineCount = isArray(label) ? label.length : 1;\n\t\t      const halfCount = lineCount / 2;\n\t\t      const color = optsAtIndex.color;\n\t\t      const strokeColor = optsAtIndex.textStrokeColor;\n\t\t      const strokeWidth = optsAtIndex.textStrokeWidth;\n\t\t      if (isHorizontal) {\n\t\t        x = pixel;\n\t\t        if (position === 'top') {\n\t\t          if (crossAlign === 'near' || rotation !== 0) {\n\t\t            textOffset = -lineCount * lineHeight + lineHeight / 2;\n\t\t          } else if (crossAlign === 'center') {\n\t\t            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n\t\t          } else {\n\t\t            textOffset = -labelSizes.highest.height + lineHeight / 2;\n\t\t          }\n\t\t        } else {\n\t\t          if (crossAlign === 'near' || rotation !== 0) {\n\t\t            textOffset = lineHeight / 2;\n\t\t          } else if (crossAlign === 'center') {\n\t\t            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n\t\t          } else {\n\t\t            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n\t\t          }\n\t\t        }\n\t\t        if (mirror) {\n\t\t          textOffset *= -1;\n\t\t        }\n\t\t      } else {\n\t\t        y = pixel;\n\t\t        textOffset = (1 - lineCount) * lineHeight / 2;\n\t\t      }\n\t\t      let backdrop;\n\t\t      if (optsAtIndex.showLabelBackdrop) {\n\t\t        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n\t\t        const height = labelSizes.heights[i];\n\t\t        const width = labelSizes.widths[i];\n\t\t        let top = y + textOffset - labelPadding.top;\n\t\t        let left = x - labelPadding.left;\n\t\t        switch (textBaseline) {\n\t\t        case 'middle':\n\t\t          top -= height / 2;\n\t\t          break;\n\t\t        case 'bottom':\n\t\t          top -= height;\n\t\t          break;\n\t\t        }\n\t\t        switch (textAlign) {\n\t\t        case 'center':\n\t\t          left -= width / 2;\n\t\t          break;\n\t\t        case 'right':\n\t\t          left -= width;\n\t\t          break;\n\t\t        }\n\t\t        backdrop = {\n\t\t          left,\n\t\t          top,\n\t\t          width: width + labelPadding.width,\n\t\t          height: height + labelPadding.height,\n\t\t          color: optsAtIndex.backdropColor,\n\t\t        };\n\t\t      }\n\t\t      items.push({\n\t\t        rotation,\n\t\t        label,\n\t\t        font,\n\t\t        color,\n\t\t        strokeColor,\n\t\t        strokeWidth,\n\t\t        textOffset,\n\t\t        textAlign,\n\t\t        textBaseline,\n\t\t        translation: [x, y],\n\t\t        backdrop,\n\t\t      });\n\t\t    }\n\t\t    return items;\n\t\t  }\n\t\t  _getXAxisLabelAlignment() {\n\t\t    const {position, ticks} = this.options;\n\t\t    const rotation = -toRadians(this.labelRotation);\n\t\t    if (rotation) {\n\t\t      return position === 'top' ? 'left' : 'right';\n\t\t    }\n\t\t    let align = 'center';\n\t\t    if (ticks.align === 'start') {\n\t\t      align = 'left';\n\t\t    } else if (ticks.align === 'end') {\n\t\t      align = 'right';\n\t\t    }\n\t\t    return align;\n\t\t  }\n\t\t  _getYAxisLabelAlignment(tl) {\n\t\t    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n\t\t    const labelSizes = this._getLabelSizes();\n\t\t    const tickAndPadding = tl + padding;\n\t\t    const widest = labelSizes.widest.width;\n\t\t    let textAlign;\n\t\t    let x;\n\t\t    if (position === 'left') {\n\t\t      if (mirror) {\n\t\t        x = this.right + padding;\n\t\t        if (crossAlign === 'near') {\n\t\t          textAlign = 'left';\n\t\t        } else if (crossAlign === 'center') {\n\t\t          textAlign = 'center';\n\t\t          x += (widest / 2);\n\t\t        } else {\n\t\t          textAlign = 'right';\n\t\t          x += widest;\n\t\t        }\n\t\t      } else {\n\t\t        x = this.right - tickAndPadding;\n\t\t        if (crossAlign === 'near') {\n\t\t          textAlign = 'right';\n\t\t        } else if (crossAlign === 'center') {\n\t\t          textAlign = 'center';\n\t\t          x -= (widest / 2);\n\t\t        } else {\n\t\t          textAlign = 'left';\n\t\t          x = this.left;\n\t\t        }\n\t\t      }\n\t\t    } else if (position === 'right') {\n\t\t      if (mirror) {\n\t\t        x = this.left + padding;\n\t\t        if (crossAlign === 'near') {\n\t\t          textAlign = 'right';\n\t\t        } else if (crossAlign === 'center') {\n\t\t          textAlign = 'center';\n\t\t          x -= (widest / 2);\n\t\t        } else {\n\t\t          textAlign = 'left';\n\t\t          x -= widest;\n\t\t        }\n\t\t      } else {\n\t\t        x = this.left + tickAndPadding;\n\t\t        if (crossAlign === 'near') {\n\t\t          textAlign = 'left';\n\t\t        } else if (crossAlign === 'center') {\n\t\t          textAlign = 'center';\n\t\t          x += widest / 2;\n\t\t        } else {\n\t\t          textAlign = 'right';\n\t\t          x = this.right;\n\t\t        }\n\t\t      }\n\t\t    } else {\n\t\t      textAlign = 'right';\n\t\t    }\n\t\t    return {textAlign, x};\n\t\t  }\n\t\t  _computeLabelArea() {\n\t\t    if (this.options.ticks.mirror) {\n\t\t      return;\n\t\t    }\n\t\t    const chart = this.chart;\n\t\t    const position = this.options.position;\n\t\t    if (position === 'left' || position === 'right') {\n\t\t      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n\t\t    } if (position === 'top' || position === 'bottom') {\n\t\t      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n\t\t    }\n\t\t  }\n\t\t  drawBackground() {\n\t\t    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n\t\t    if (backgroundColor) {\n\t\t      ctx.save();\n\t\t      ctx.fillStyle = backgroundColor;\n\t\t      ctx.fillRect(left, top, width, height);\n\t\t      ctx.restore();\n\t\t    }\n\t\t  }\n\t\t  getLineWidthForValue(value) {\n\t\t    const grid = this.options.grid;\n\t\t    if (!this._isVisible() || !grid.display) {\n\t\t      return 0;\n\t\t    }\n\t\t    const ticks = this.ticks;\n\t\t    const index = ticks.findIndex(t => t.value === value);\n\t\t    if (index >= 0) {\n\t\t      const opts = grid.setContext(this.getContext(index));\n\t\t      return opts.lineWidth;\n\t\t    }\n\t\t    return 0;\n\t\t  }\n\t\t  drawGrid(chartArea) {\n\t\t    const grid = this.options.grid;\n\t\t    const ctx = this.ctx;\n\t\t    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n\t\t    let i, ilen;\n\t\t    const drawLine = (p1, p2, style) => {\n\t\t      if (!style.width || !style.color) {\n\t\t        return;\n\t\t      }\n\t\t      ctx.save();\n\t\t      ctx.lineWidth = style.width;\n\t\t      ctx.strokeStyle = style.color;\n\t\t      ctx.setLineDash(style.borderDash || []);\n\t\t      ctx.lineDashOffset = style.borderDashOffset;\n\t\t      ctx.beginPath();\n\t\t      ctx.moveTo(p1.x, p1.y);\n\t\t      ctx.lineTo(p2.x, p2.y);\n\t\t      ctx.stroke();\n\t\t      ctx.restore();\n\t\t    };\n\t\t    if (grid.display) {\n\t\t      for (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t        const item = items[i];\n\t\t        if (grid.drawOnChartArea) {\n\t\t          drawLine(\n\t\t            {x: item.x1, y: item.y1},\n\t\t            {x: item.x2, y: item.y2},\n\t\t            item\n\t\t          );\n\t\t        }\n\t\t        if (grid.drawTicks) {\n\t\t          drawLine(\n\t\t            {x: item.tx1, y: item.ty1},\n\t\t            {x: item.tx2, y: item.ty2},\n\t\t            {\n\t\t              color: item.tickColor,\n\t\t              width: item.tickWidth,\n\t\t              borderDash: item.tickBorderDash,\n\t\t              borderDashOffset: item.tickBorderDashOffset\n\t\t            }\n\t\t          );\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  drawBorder() {\n\t\t    const {chart, ctx, options: {grid}} = this;\n\t\t    const borderOpts = grid.setContext(this.getContext());\n\t\t    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n\t\t    if (!axisWidth) {\n\t\t      return;\n\t\t    }\n\t\t    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n\t\t    const borderValue = this._borderValue;\n\t\t    let x1, x2, y1, y2;\n\t\t    if (this.isHorizontal()) {\n\t\t      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n\t\t      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n\t\t      y1 = y2 = borderValue;\n\t\t    } else {\n\t\t      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n\t\t      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n\t\t      x1 = x2 = borderValue;\n\t\t    }\n\t\t    ctx.save();\n\t\t    ctx.lineWidth = borderOpts.borderWidth;\n\t\t    ctx.strokeStyle = borderOpts.borderColor;\n\t\t    ctx.beginPath();\n\t\t    ctx.moveTo(x1, y1);\n\t\t    ctx.lineTo(x2, y2);\n\t\t    ctx.stroke();\n\t\t    ctx.restore();\n\t\t  }\n\t\t  drawLabels(chartArea) {\n\t\t    const optionTicks = this.options.ticks;\n\t\t    if (!optionTicks.display) {\n\t\t      return;\n\t\t    }\n\t\t    const ctx = this.ctx;\n\t\t    const area = this._computeLabelArea();\n\t\t    if (area) {\n\t\t      clipArea(ctx, area);\n\t\t    }\n\t\t    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n\t\t    let i, ilen;\n\t\t    for (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t      const item = items[i];\n\t\t      const tickFont = item.font;\n\t\t      const label = item.label;\n\t\t      if (item.backdrop) {\n\t\t        ctx.fillStyle = item.backdrop.color;\n\t\t        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n\t\t      }\n\t\t      let y = item.textOffset;\n\t\t      renderText(ctx, label, 0, y, tickFont, item);\n\t\t    }\n\t\t    if (area) {\n\t\t      unclipArea(ctx);\n\t\t    }\n\t\t  }\n\t\t  drawTitle() {\n\t\t    const {ctx, options: {position, title, reverse}} = this;\n\t\t    if (!title.display) {\n\t\t      return;\n\t\t    }\n\t\t    const font = toFont(title.font);\n\t\t    const padding = toPadding(title.padding);\n\t\t    const align = title.align;\n\t\t    let offset = font.lineHeight / 2;\n\t\t    if (position === 'bottom' || position === 'center' || isObject(position)) {\n\t\t      offset += padding.bottom;\n\t\t      if (isArray(title.text)) {\n\t\t        offset += font.lineHeight * (title.text.length - 1);\n\t\t      }\n\t\t    } else {\n\t\t      offset += padding.top;\n\t\t    }\n\t\t    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\t\t    renderText(ctx, title.text, 0, 0, font, {\n\t\t      color: title.color,\n\t\t      maxWidth,\n\t\t      rotation,\n\t\t      textAlign: titleAlign(align, position, reverse),\n\t\t      textBaseline: 'middle',\n\t\t      translation: [titleX, titleY],\n\t\t    });\n\t\t  }\n\t\t  draw(chartArea) {\n\t\t    if (!this._isVisible()) {\n\t\t      return;\n\t\t    }\n\t\t    this.drawBackground();\n\t\t    this.drawGrid(chartArea);\n\t\t    this.drawBorder();\n\t\t    this.drawTitle();\n\t\t    this.drawLabels(chartArea);\n\t\t  }\n\t\t  _layers() {\n\t\t    const opts = this.options;\n\t\t    const tz = opts.ticks && opts.ticks.z || 0;\n\t\t    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n\t\t    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n\t\t      return [{\n\t\t        z: tz,\n\t\t        draw: (chartArea) => {\n\t\t          this.draw(chartArea);\n\t\t        }\n\t\t      }];\n\t\t    }\n\t\t    return [{\n\t\t      z: gz,\n\t\t      draw: (chartArea) => {\n\t\t        this.drawBackground();\n\t\t        this.drawGrid(chartArea);\n\t\t        this.drawTitle();\n\t\t      }\n\t\t    }, {\n\t\t      z: gz + 1,\n\t\t      draw: () => {\n\t\t        this.drawBorder();\n\t\t      }\n\t\t    }, {\n\t\t      z: tz,\n\t\t      draw: (chartArea) => {\n\t\t        this.drawLabels(chartArea);\n\t\t      }\n\t\t    }];\n\t\t  }\n\t\t  getMatchingVisibleMetas(type) {\n\t\t    const metas = this.chart.getSortedVisibleDatasetMetas();\n\t\t    const axisID = this.axis + 'AxisID';\n\t\t    const result = [];\n\t\t    let i, ilen;\n\t\t    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n\t\t      const meta = metas[i];\n\t\t      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n\t\t        result.push(meta);\n\t\t      }\n\t\t    }\n\t\t    return result;\n\t\t  }\n\t\t  _resolveTickFontOptions(index) {\n\t\t    const opts = this.options.ticks.setContext(this.getContext(index));\n\t\t    return toFont(opts.font);\n\t\t  }\n\t\t  _maxDigits() {\n\t\t    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n\t\t    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n\t\t  }\n\t\t}\n\n\t\tclass TypedRegistry {\n\t\t  constructor(type, scope, override) {\n\t\t    this.type = type;\n\t\t    this.scope = scope;\n\t\t    this.override = override;\n\t\t    this.items = Object.create(null);\n\t\t  }\n\t\t  isForType(type) {\n\t\t    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n\t\t  }\n\t\t  register(item) {\n\t\t    const proto = Object.getPrototypeOf(item);\n\t\t    let parentScope;\n\t\t    if (isIChartComponent(proto)) {\n\t\t      parentScope = this.register(proto);\n\t\t    }\n\t\t    const items = this.items;\n\t\t    const id = item.id;\n\t\t    const scope = this.scope + '.' + id;\n\t\t    if (!id) {\n\t\t      throw new Error('class does not have id: ' + item);\n\t\t    }\n\t\t    if (id in items) {\n\t\t      return scope;\n\t\t    }\n\t\t    items[id] = item;\n\t\t    registerDefaults(item, scope, parentScope);\n\t\t    if (this.override) {\n\t\t      defaults.override(item.id, item.overrides);\n\t\t    }\n\t\t    return scope;\n\t\t  }\n\t\t  get(id) {\n\t\t    return this.items[id];\n\t\t  }\n\t\t  unregister(item) {\n\t\t    const items = this.items;\n\t\t    const id = item.id;\n\t\t    const scope = this.scope;\n\t\t    if (id in items) {\n\t\t      delete items[id];\n\t\t    }\n\t\t    if (scope && id in defaults[scope]) {\n\t\t      delete defaults[scope][id];\n\t\t      if (this.override) {\n\t\t        delete overrides[id];\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction registerDefaults(item, scope, parentScope) {\n\t\t  const itemDefaults = merge(Object.create(null), [\n\t\t    parentScope ? defaults.get(parentScope) : {},\n\t\t    defaults.get(scope),\n\t\t    item.defaults\n\t\t  ]);\n\t\t  defaults.set(scope, itemDefaults);\n\t\t  if (item.defaultRoutes) {\n\t\t    routeDefaults(scope, item.defaultRoutes);\n\t\t  }\n\t\t  if (item.descriptors) {\n\t\t    defaults.describe(scope, item.descriptors);\n\t\t  }\n\t\t}\n\t\tfunction routeDefaults(scope, routes) {\n\t\t  Object.keys(routes).forEach(property => {\n\t\t    const propertyParts = property.split('.');\n\t\t    const sourceName = propertyParts.pop();\n\t\t    const sourceScope = [scope].concat(propertyParts).join('.');\n\t\t    const parts = routes[property].split('.');\n\t\t    const targetName = parts.pop();\n\t\t    const targetScope = parts.join('.');\n\t\t    defaults.route(sourceScope, sourceName, targetScope, targetName);\n\t\t  });\n\t\t}\n\t\tfunction isIChartComponent(proto) {\n\t\t  return 'id' in proto && 'defaults' in proto;\n\t\t}\n\n\t\tclass Registry {\n\t\t  constructor() {\n\t\t    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n\t\t    this.elements = new TypedRegistry(Element, 'elements');\n\t\t    this.plugins = new TypedRegistry(Object, 'plugins');\n\t\t    this.scales = new TypedRegistry(Scale, 'scales');\n\t\t    this._typedRegistries = [this.controllers, this.scales, this.elements];\n\t\t  }\n\t\t  add(...args) {\n\t\t    this._each('register', args);\n\t\t  }\n\t\t  remove(...args) {\n\t\t    this._each('unregister', args);\n\t\t  }\n\t\t  addControllers(...args) {\n\t\t    this._each('register', args, this.controllers);\n\t\t  }\n\t\t  addElements(...args) {\n\t\t    this._each('register', args, this.elements);\n\t\t  }\n\t\t  addPlugins(...args) {\n\t\t    this._each('register', args, this.plugins);\n\t\t  }\n\t\t  addScales(...args) {\n\t\t    this._each('register', args, this.scales);\n\t\t  }\n\t\t  getController(id) {\n\t\t    return this._get(id, this.controllers, 'controller');\n\t\t  }\n\t\t  getElement(id) {\n\t\t    return this._get(id, this.elements, 'element');\n\t\t  }\n\t\t  getPlugin(id) {\n\t\t    return this._get(id, this.plugins, 'plugin');\n\t\t  }\n\t\t  getScale(id) {\n\t\t    return this._get(id, this.scales, 'scale');\n\t\t  }\n\t\t  removeControllers(...args) {\n\t\t    this._each('unregister', args, this.controllers);\n\t\t  }\n\t\t  removeElements(...args) {\n\t\t    this._each('unregister', args, this.elements);\n\t\t  }\n\t\t  removePlugins(...args) {\n\t\t    this._each('unregister', args, this.plugins);\n\t\t  }\n\t\t  removeScales(...args) {\n\t\t    this._each('unregister', args, this.scales);\n\t\t  }\n\t\t  _each(method, args, typedRegistry) {\n\t\t    [...args].forEach(arg => {\n\t\t      const reg = typedRegistry || this._getRegistryForType(arg);\n\t\t      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n\t\t        this._exec(method, reg, arg);\n\t\t      } else {\n\t\t        each(arg, item => {\n\t\t          const itemReg = typedRegistry || this._getRegistryForType(item);\n\t\t          this._exec(method, itemReg, item);\n\t\t        });\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  _exec(method, registry, component) {\n\t\t    const camelMethod = _capitalize(method);\n\t\t    callback(component['before' + camelMethod], [], component);\n\t\t    registry[method](component);\n\t\t    callback(component['after' + camelMethod], [], component);\n\t\t  }\n\t\t  _getRegistryForType(type) {\n\t\t    for (let i = 0; i < this._typedRegistries.length; i++) {\n\t\t      const reg = this._typedRegistries[i];\n\t\t      if (reg.isForType(type)) {\n\t\t        return reg;\n\t\t      }\n\t\t    }\n\t\t    return this.plugins;\n\t\t  }\n\t\t  _get(id, typedRegistry, type) {\n\t\t    const item = typedRegistry.get(id);\n\t\t    if (item === undefined) {\n\t\t      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n\t\t    }\n\t\t    return item;\n\t\t  }\n\t\t}\n\t\tvar registry = new Registry();\n\n\t\tclass PluginService {\n\t\t  constructor() {\n\t\t    this._init = [];\n\t\t  }\n\t\t  notify(chart, hook, args, filter) {\n\t\t    if (hook === 'beforeInit') {\n\t\t      this._init = this._createDescriptors(chart, true);\n\t\t      this._notify(this._init, chart, 'install');\n\t\t    }\n\t\t    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n\t\t    const result = this._notify(descriptors, chart, hook, args);\n\t\t    if (hook === 'afterDestroy') {\n\t\t      this._notify(descriptors, chart, 'stop');\n\t\t      this._notify(this._init, chart, 'uninstall');\n\t\t    }\n\t\t    return result;\n\t\t  }\n\t\t  _notify(descriptors, chart, hook, args) {\n\t\t    args = args || {};\n\t\t    for (const descriptor of descriptors) {\n\t\t      const plugin = descriptor.plugin;\n\t\t      const method = plugin[hook];\n\t\t      const params = [chart, args, descriptor.options];\n\t\t      if (callback(method, params, plugin) === false && args.cancelable) {\n\t\t        return false;\n\t\t      }\n\t\t    }\n\t\t    return true;\n\t\t  }\n\t\t  invalidate() {\n\t\t    if (!isNullOrUndef(this._cache)) {\n\t\t      this._oldCache = this._cache;\n\t\t      this._cache = undefined;\n\t\t    }\n\t\t  }\n\t\t  _descriptors(chart) {\n\t\t    if (this._cache) {\n\t\t      return this._cache;\n\t\t    }\n\t\t    const descriptors = this._cache = this._createDescriptors(chart);\n\t\t    this._notifyStateChanges(chart);\n\t\t    return descriptors;\n\t\t  }\n\t\t  _createDescriptors(chart, all) {\n\t\t    const config = chart && chart.config;\n\t\t    const options = valueOrDefault(config.options && config.options.plugins, {});\n\t\t    const plugins = allPlugins(config);\n\t\t    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n\t\t  }\n\t\t  _notifyStateChanges(chart) {\n\t\t    const previousDescriptors = this._oldCache || [];\n\t\t    const descriptors = this._cache;\n\t\t    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n\t\t    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n\t\t    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n\t\t  }\n\t\t}\n\t\tfunction allPlugins(config) {\n\t\t  const plugins = [];\n\t\t  const keys = Object.keys(registry.plugins.items);\n\t\t  for (let i = 0; i < keys.length; i++) {\n\t\t    plugins.push(registry.getPlugin(keys[i]));\n\t\t  }\n\t\t  const local = config.plugins || [];\n\t\t  for (let i = 0; i < local.length; i++) {\n\t\t    const plugin = local[i];\n\t\t    if (plugins.indexOf(plugin) === -1) {\n\t\t      plugins.push(plugin);\n\t\t    }\n\t\t  }\n\t\t  return plugins;\n\t\t}\n\t\tfunction getOpts(options, all) {\n\t\t  if (!all && options === false) {\n\t\t    return null;\n\t\t  }\n\t\t  if (options === true) {\n\t\t    return {};\n\t\t  }\n\t\t  return options;\n\t\t}\n\t\tfunction createDescriptors(chart, plugins, options, all) {\n\t\t  const result = [];\n\t\t  const context = chart.getContext();\n\t\t  for (let i = 0; i < plugins.length; i++) {\n\t\t    const plugin = plugins[i];\n\t\t    const id = plugin.id;\n\t\t    const opts = getOpts(options[id], all);\n\t\t    if (opts === null) {\n\t\t      continue;\n\t\t    }\n\t\t    result.push({\n\t\t      plugin,\n\t\t      options: pluginOpts(chart.config, plugin, opts, context)\n\t\t    });\n\t\t  }\n\t\t  return result;\n\t\t}\n\t\tfunction pluginOpts(config, plugin, opts, context) {\n\t\t  const keys = config.pluginScopeKeys(plugin);\n\t\t  const scopes = config.getOptionScopes(opts, keys);\n\t\t  return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});\n\t\t}\n\n\t\tfunction getIndexAxis(type, options) {\n\t\t  const datasetDefaults = defaults.datasets[type] || {};\n\t\t  const datasetOptions = (options.datasets || {})[type] || {};\n\t\t  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n\t\t}\n\t\tfunction getAxisFromDefaultScaleID(id, indexAxis) {\n\t\t  let axis = id;\n\t\t  if (id === '_index_') {\n\t\t    axis = indexAxis;\n\t\t  } else if (id === '_value_') {\n\t\t    axis = indexAxis === 'x' ? 'y' : 'x';\n\t\t  }\n\t\t  return axis;\n\t\t}\n\t\tfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n\t\t  return axis === indexAxis ? '_index_' : '_value_';\n\t\t}\n\t\tfunction axisFromPosition(position) {\n\t\t  if (position === 'top' || position === 'bottom') {\n\t\t    return 'x';\n\t\t  }\n\t\t  if (position === 'left' || position === 'right') {\n\t\t    return 'y';\n\t\t  }\n\t\t}\n\t\tfunction determineAxis(id, scaleOptions) {\n\t\t  if (id === 'x' || id === 'y') {\n\t\t    return id;\n\t\t  }\n\t\t  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n\t\t}\n\t\tfunction mergeScaleConfig(config, options) {\n\t\t  const chartDefaults = overrides[config.type] || {scales: {}};\n\t\t  const configScales = options.scales || {};\n\t\t  const chartIndexAxis = getIndexAxis(config.type, options);\n\t\t  const firstIDs = Object.create(null);\n\t\t  const scales = Object.create(null);\n\t\t  Object.keys(configScales).forEach(id => {\n\t\t    const scaleConf = configScales[id];\n\t\t    if (!isObject(scaleConf)) {\n\t\t      return console.error(`Invalid scale configuration for scale: ${id}`);\n\t\t    }\n\t\t    if (scaleConf._proxy) {\n\t\t      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n\t\t    }\n\t\t    const axis = determineAxis(id, scaleConf);\n\t\t    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n\t\t    const defaultScaleOptions = chartDefaults.scales || {};\n\t\t    firstIDs[axis] = firstIDs[axis] || id;\n\t\t    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n\t\t  });\n\t\t  config.data.datasets.forEach(dataset => {\n\t\t    const type = dataset.type || config.type;\n\t\t    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n\t\t    const datasetDefaults = overrides[type] || {};\n\t\t    const defaultScaleOptions = datasetDefaults.scales || {};\n\t\t    Object.keys(defaultScaleOptions).forEach(defaultID => {\n\t\t      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n\t\t      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n\t\t      scales[id] = scales[id] || Object.create(null);\n\t\t      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n\t\t    });\n\t\t  });\n\t\t  Object.keys(scales).forEach(key => {\n\t\t    const scale = scales[key];\n\t\t    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n\t\t  });\n\t\t  return scales;\n\t\t}\n\t\tfunction initOptions(config) {\n\t\t  const options = config.options || (config.options = {});\n\t\t  options.plugins = valueOrDefault(options.plugins, {});\n\t\t  options.scales = mergeScaleConfig(config, options);\n\t\t}\n\t\tfunction initData(data) {\n\t\t  data = data || {};\n\t\t  data.datasets = data.datasets || [];\n\t\t  data.labels = data.labels || [];\n\t\t  return data;\n\t\t}\n\t\tfunction initConfig(config) {\n\t\t  config = config || {};\n\t\t  config.data = initData(config.data);\n\t\t  initOptions(config);\n\t\t  return config;\n\t\t}\n\t\tconst keyCache = new Map();\n\t\tconst keysCached = new Set();\n\t\tfunction cachedKeys(cacheKey, generate) {\n\t\t  let keys = keyCache.get(cacheKey);\n\t\t  if (!keys) {\n\t\t    keys = generate();\n\t\t    keyCache.set(cacheKey, keys);\n\t\t    keysCached.add(keys);\n\t\t  }\n\t\t  return keys;\n\t\t}\n\t\tconst addIfFound = (set, obj, key) => {\n\t\t  const opts = resolveObjectKey(obj, key);\n\t\t  if (opts !== undefined) {\n\t\t    set.add(opts);\n\t\t  }\n\t\t};\n\t\tclass Config {\n\t\t  constructor(config) {\n\t\t    this._config = initConfig(config);\n\t\t    this._scopeCache = new Map();\n\t\t    this._resolverCache = new Map();\n\t\t  }\n\t\t  get platform() {\n\t\t    return this._config.platform;\n\t\t  }\n\t\t  get type() {\n\t\t    return this._config.type;\n\t\t  }\n\t\t  set type(type) {\n\t\t    this._config.type = type;\n\t\t  }\n\t\t  get data() {\n\t\t    return this._config.data;\n\t\t  }\n\t\t  set data(data) {\n\t\t    this._config.data = initData(data);\n\t\t  }\n\t\t  get options() {\n\t\t    return this._config.options;\n\t\t  }\n\t\t  set options(options) {\n\t\t    this._config.options = options;\n\t\t  }\n\t\t  get plugins() {\n\t\t    return this._config.plugins;\n\t\t  }\n\t\t  update() {\n\t\t    const config = this._config;\n\t\t    this.clearCache();\n\t\t    initOptions(config);\n\t\t  }\n\t\t  clearCache() {\n\t\t    this._scopeCache.clear();\n\t\t    this._resolverCache.clear();\n\t\t  }\n\t\t  datasetScopeKeys(datasetType) {\n\t\t    return cachedKeys(datasetType,\n\t\t      () => [[\n\t\t        `datasets.${datasetType}`,\n\t\t        ''\n\t\t      ]]);\n\t\t  }\n\t\t  datasetAnimationScopeKeys(datasetType, transition) {\n\t\t    return cachedKeys(`${datasetType}.transition.${transition}`,\n\t\t      () => [\n\t\t        [\n\t\t          `datasets.${datasetType}.transitions.${transition}`,\n\t\t          `transitions.${transition}`,\n\t\t        ],\n\t\t        [\n\t\t          `datasets.${datasetType}`,\n\t\t          ''\n\t\t        ]\n\t\t      ]);\n\t\t  }\n\t\t  datasetElementScopeKeys(datasetType, elementType) {\n\t\t    return cachedKeys(`${datasetType}-${elementType}`,\n\t\t      () => [[\n\t\t        `datasets.${datasetType}.elements.${elementType}`,\n\t\t        `datasets.${datasetType}`,\n\t\t        `elements.${elementType}`,\n\t\t        ''\n\t\t      ]]);\n\t\t  }\n\t\t  pluginScopeKeys(plugin) {\n\t\t    const id = plugin.id;\n\t\t    const type = this.type;\n\t\t    return cachedKeys(`${type}-plugin-${id}`,\n\t\t      () => [[\n\t\t        `plugins.${id}`,\n\t\t        ...plugin.additionalOptionScopes || [],\n\t\t      ]]);\n\t\t  }\n\t\t  _cachedScopes(mainScope, resetCache) {\n\t\t    const _scopeCache = this._scopeCache;\n\t\t    let cache = _scopeCache.get(mainScope);\n\t\t    if (!cache || resetCache) {\n\t\t      cache = new Map();\n\t\t      _scopeCache.set(mainScope, cache);\n\t\t    }\n\t\t    return cache;\n\t\t  }\n\t\t  getOptionScopes(mainScope, keyLists, resetCache) {\n\t\t    const {options, type} = this;\n\t\t    const cache = this._cachedScopes(mainScope, resetCache);\n\t\t    const cached = cache.get(keyLists);\n\t\t    if (cached) {\n\t\t      return cached;\n\t\t    }\n\t\t    const scopes = new Set();\n\t\t    keyLists.forEach(keys => {\n\t\t      if (mainScope) {\n\t\t        scopes.add(mainScope);\n\t\t        keys.forEach(key => addIfFound(scopes, mainScope, key));\n\t\t      }\n\t\t      keys.forEach(key => addIfFound(scopes, options, key));\n\t\t      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n\t\t      keys.forEach(key => addIfFound(scopes, defaults, key));\n\t\t      keys.forEach(key => addIfFound(scopes, descriptors, key));\n\t\t    });\n\t\t    const array = Array.from(scopes);\n\t\t    if (array.length === 0) {\n\t\t      array.push(Object.create(null));\n\t\t    }\n\t\t    if (keysCached.has(keyLists)) {\n\t\t      cache.set(keyLists, array);\n\t\t    }\n\t\t    return array;\n\t\t  }\n\t\t  chartOptionScopes() {\n\t\t    const {options, type} = this;\n\t\t    return [\n\t\t      options,\n\t\t      overrides[type] || {},\n\t\t      defaults.datasets[type] || {},\n\t\t      {type},\n\t\t      defaults,\n\t\t      descriptors\n\t\t    ];\n\t\t  }\n\t\t  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n\t\t    const result = {$shared: true};\n\t\t    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n\t\t    let options = resolver;\n\t\t    if (needContext(resolver, names)) {\n\t\t      result.$shared = false;\n\t\t      context = isFunction(context) ? context() : context;\n\t\t      const subResolver = this.createResolver(scopes, context, subPrefixes);\n\t\t      options = _attachContext(resolver, context, subResolver);\n\t\t    }\n\t\t    for (const prop of names) {\n\t\t      result[prop] = options[prop];\n\t\t    }\n\t\t    return result;\n\t\t  }\n\t\t  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n\t\t    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n\t\t    return isObject(context)\n\t\t      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n\t\t      : resolver;\n\t\t  }\n\t\t}\n\t\tfunction getResolver(resolverCache, scopes, prefixes) {\n\t\t  let cache = resolverCache.get(scopes);\n\t\t  if (!cache) {\n\t\t    cache = new Map();\n\t\t    resolverCache.set(scopes, cache);\n\t\t  }\n\t\t  const cacheKey = prefixes.join();\n\t\t  let cached = cache.get(cacheKey);\n\t\t  if (!cached) {\n\t\t    const resolver = _createResolver(scopes, prefixes);\n\t\t    cached = {\n\t\t      resolver,\n\t\t      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n\t\t    };\n\t\t    cache.set(cacheKey, cached);\n\t\t  }\n\t\t  return cached;\n\t\t}\n\t\tconst hasFunction = value => isObject(value)\n\t\t  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\n\t\tfunction needContext(proxy, names) {\n\t\t  const {isScriptable, isIndexable} = _descriptors(proxy);\n\t\t  for (const prop of names) {\n\t\t    const scriptable = isScriptable(prop);\n\t\t    const indexable = isIndexable(prop);\n\t\t    const value = (indexable || scriptable) && proxy[prop];\n\t\t    if ((scriptable && (isFunction(value) || hasFunction(value)))\n\t\t      || (indexable && isArray(value))) {\n\t\t      return true;\n\t\t    }\n\t\t  }\n\t\t  return false;\n\t\t}\n\n\t\tvar version = \"3.7.1\";\n\n\t\tconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\n\t\tfunction positionIsHorizontal(position, axis) {\n\t\t  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n\t\t}\n\t\tfunction compare2Level(l1, l2) {\n\t\t  return function(a, b) {\n\t\t    return a[l1] === b[l1]\n\t\t      ? a[l2] - b[l2]\n\t\t      : a[l1] - b[l1];\n\t\t  };\n\t\t}\n\t\tfunction onAnimationsComplete(context) {\n\t\t  const chart = context.chart;\n\t\t  const animationOptions = chart.options.animation;\n\t\t  chart.notifyPlugins('afterRender');\n\t\t  callback(animationOptions && animationOptions.onComplete, [context], chart);\n\t\t}\n\t\tfunction onAnimationProgress(context) {\n\t\t  const chart = context.chart;\n\t\t  const animationOptions = chart.options.animation;\n\t\t  callback(animationOptions && animationOptions.onProgress, [context], chart);\n\t\t}\n\t\tfunction getCanvas(item) {\n\t\t  if (_isDomSupported() && typeof item === 'string') {\n\t\t    item = document.getElementById(item);\n\t\t  } else if (item && item.length) {\n\t\t    item = item[0];\n\t\t  }\n\t\t  if (item && item.canvas) {\n\t\t    item = item.canvas;\n\t\t  }\n\t\t  return item;\n\t\t}\n\t\tconst instances = {};\n\t\tconst getChart = (key) => {\n\t\t  const canvas = getCanvas(key);\n\t\t  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n\t\t};\n\t\tfunction moveNumericKeys(obj, start, move) {\n\t\t  const keys = Object.keys(obj);\n\t\t  for (const key of keys) {\n\t\t    const intKey = +key;\n\t\t    if (intKey >= start) {\n\t\t      const value = obj[key];\n\t\t      delete obj[key];\n\t\t      if (move > 0 || intKey > start) {\n\t\t        obj[intKey + move] = value;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n\t\t  if (!inChartArea || e.type === 'mouseout') {\n\t\t    return null;\n\t\t  }\n\t\t  if (isClick) {\n\t\t    return lastEvent;\n\t\t  }\n\t\t  return e;\n\t\t}\n\t\tclass Chart {\n\t\t  constructor(item, userConfig) {\n\t\t    const config = this.config = new Config(userConfig);\n\t\t    const initialCanvas = getCanvas(item);\n\t\t    const existingChart = getChart(initialCanvas);\n\t\t    if (existingChart) {\n\t\t      throw new Error(\n\t\t        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t\t\t' must be destroyed before the canvas can be reused.'\n\t\t      );\n\t\t    }\n\t\t    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\t\t    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n\t\t    this.platform.updateConfig(config);\n\t\t    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n\t\t    const canvas = context && context.canvas;\n\t\t    const height = canvas && canvas.height;\n\t\t    const width = canvas && canvas.width;\n\t\t    this.id = uid();\n\t\t    this.ctx = context;\n\t\t    this.canvas = canvas;\n\t\t    this.width = width;\n\t\t    this.height = height;\n\t\t    this._options = options;\n\t\t    this._aspectRatio = this.aspectRatio;\n\t\t    this._layers = [];\n\t\t    this._metasets = [];\n\t\t    this._stacks = undefined;\n\t\t    this.boxes = [];\n\t\t    this.currentDevicePixelRatio = undefined;\n\t\t    this.chartArea = undefined;\n\t\t    this._active = [];\n\t\t    this._lastEvent = undefined;\n\t\t    this._listeners = {};\n\t\t    this._responsiveListeners = undefined;\n\t\t    this._sortedMetasets = [];\n\t\t    this.scales = {};\n\t\t    this._plugins = new PluginService();\n\t\t    this.$proxies = {};\n\t\t    this._hiddenIndices = {};\n\t\t    this.attached = false;\n\t\t    this._animationsDisabled = undefined;\n\t\t    this.$context = undefined;\n\t\t    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n\t\t    this._dataChanges = [];\n\t\t    instances[this.id] = this;\n\t\t    if (!context || !canvas) {\n\t\t      console.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t      return;\n\t\t    }\n\t\t    animator.listen(this, 'complete', onAnimationsComplete);\n\t\t    animator.listen(this, 'progress', onAnimationProgress);\n\t\t    this._initialize();\n\t\t    if (this.attached) {\n\t\t      this.update();\n\t\t    }\n\t\t  }\n\t\t  get aspectRatio() {\n\t\t    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n\t\t    if (!isNullOrUndef(aspectRatio)) {\n\t\t      return aspectRatio;\n\t\t    }\n\t\t    if (maintainAspectRatio && _aspectRatio) {\n\t\t      return _aspectRatio;\n\t\t    }\n\t\t    return height ? width / height : null;\n\t\t  }\n\t\t  get data() {\n\t\t    return this.config.data;\n\t\t  }\n\t\t  set data(data) {\n\t\t    this.config.data = data;\n\t\t  }\n\t\t  get options() {\n\t\t    return this._options;\n\t\t  }\n\t\t  set options(options) {\n\t\t    this.config.options = options;\n\t\t  }\n\t\t  _initialize() {\n\t\t    this.notifyPlugins('beforeInit');\n\t\t    if (this.options.responsive) {\n\t\t      this.resize();\n\t\t    } else {\n\t\t      retinaScale(this, this.options.devicePixelRatio);\n\t\t    }\n\t\t    this.bindEvents();\n\t\t    this.notifyPlugins('afterInit');\n\t\t    return this;\n\t\t  }\n\t\t  clear() {\n\t\t    clearCanvas(this.canvas, this.ctx);\n\t\t    return this;\n\t\t  }\n\t\t  stop() {\n\t\t    animator.stop(this);\n\t\t    return this;\n\t\t  }\n\t\t  resize(width, height) {\n\t\t    if (!animator.running(this)) {\n\t\t      this._resize(width, height);\n\t\t    } else {\n\t\t      this._resizeBeforeDraw = {width, height};\n\t\t    }\n\t\t  }\n\t\t  _resize(width, height) {\n\t\t    const options = this.options;\n\t\t    const canvas = this.canvas;\n\t\t    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n\t\t    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n\t\t    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n\t\t    const mode = this.width ? 'resize' : 'attach';\n\t\t    this.width = newSize.width;\n\t\t    this.height = newSize.height;\n\t\t    this._aspectRatio = this.aspectRatio;\n\t\t    if (!retinaScale(this, newRatio, true)) {\n\t\t      return;\n\t\t    }\n\t\t    this.notifyPlugins('resize', {size: newSize});\n\t\t    callback(options.onResize, [this, newSize], this);\n\t\t    if (this.attached) {\n\t\t      if (this._doResize(mode)) {\n\t\t        this.render();\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  ensureScalesHaveIDs() {\n\t\t    const options = this.options;\n\t\t    const scalesOptions = options.scales || {};\n\t\t    each(scalesOptions, (axisOptions, axisID) => {\n\t\t      axisOptions.id = axisID;\n\t\t    });\n\t\t  }\n\t\t  buildOrUpdateScales() {\n\t\t    const options = this.options;\n\t\t    const scaleOpts = options.scales;\n\t\t    const scales = this.scales;\n\t\t    const updated = Object.keys(scales).reduce((obj, id) => {\n\t\t      obj[id] = false;\n\t\t      return obj;\n\t\t    }, {});\n\t\t    let items = [];\n\t\t    if (scaleOpts) {\n\t\t      items = items.concat(\n\t\t        Object.keys(scaleOpts).map((id) => {\n\t\t          const scaleOptions = scaleOpts[id];\n\t\t          const axis = determineAxis(id, scaleOptions);\n\t\t          const isRadial = axis === 'r';\n\t\t          const isHorizontal = axis === 'x';\n\t\t          return {\n\t\t            options: scaleOptions,\n\t\t            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n\t\t            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n\t\t          };\n\t\t        })\n\t\t      );\n\t\t    }\n\t\t    each(items, (item) => {\n\t\t      const scaleOptions = item.options;\n\t\t      const id = scaleOptions.id;\n\t\t      const axis = determineAxis(id, scaleOptions);\n\t\t      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\t\t      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n\t\t        scaleOptions.position = item.dposition;\n\t\t      }\n\t\t      updated[id] = true;\n\t\t      let scale = null;\n\t\t      if (id in scales && scales[id].type === scaleType) {\n\t\t        scale = scales[id];\n\t\t      } else {\n\t\t        const scaleClass = registry.getScale(scaleType);\n\t\t        scale = new scaleClass({\n\t\t          id,\n\t\t          type: scaleType,\n\t\t          ctx: this.ctx,\n\t\t          chart: this\n\t\t        });\n\t\t        scales[scale.id] = scale;\n\t\t      }\n\t\t      scale.init(scaleOptions, options);\n\t\t    });\n\t\t    each(updated, (hasUpdated, id) => {\n\t\t      if (!hasUpdated) {\n\t\t        delete scales[id];\n\t\t      }\n\t\t    });\n\t\t    each(scales, (scale) => {\n\t\t      layouts.configure(this, scale, scale.options);\n\t\t      layouts.addBox(this, scale);\n\t\t    });\n\t\t  }\n\t\t  _updateMetasets() {\n\t\t    const metasets = this._metasets;\n\t\t    const numData = this.data.datasets.length;\n\t\t    const numMeta = metasets.length;\n\t\t    metasets.sort((a, b) => a.index - b.index);\n\t\t    if (numMeta > numData) {\n\t\t      for (let i = numData; i < numMeta; ++i) {\n\t\t        this._destroyDatasetMeta(i);\n\t\t      }\n\t\t      metasets.splice(numData, numMeta - numData);\n\t\t    }\n\t\t    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n\t\t  }\n\t\t  _removeUnreferencedMetasets() {\n\t\t    const {_metasets: metasets, data: {datasets}} = this;\n\t\t    if (metasets.length > datasets.length) {\n\t\t      delete this._stacks;\n\t\t    }\n\t\t    metasets.forEach((meta, index) => {\n\t\t      if (datasets.filter(x => x === meta._dataset).length === 0) {\n\t\t        this._destroyDatasetMeta(index);\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  buildOrUpdateControllers() {\n\t\t    const newControllers = [];\n\t\t    const datasets = this.data.datasets;\n\t\t    let i, ilen;\n\t\t    this._removeUnreferencedMetasets();\n\t\t    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n\t\t      const dataset = datasets[i];\n\t\t      let meta = this.getDatasetMeta(i);\n\t\t      const type = dataset.type || this.config.type;\n\t\t      if (meta.type && meta.type !== type) {\n\t\t        this._destroyDatasetMeta(i);\n\t\t        meta = this.getDatasetMeta(i);\n\t\t      }\n\t\t      meta.type = type;\n\t\t      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n\t\t      meta.order = dataset.order || 0;\n\t\t      meta.index = i;\n\t\t      meta.label = '' + dataset.label;\n\t\t      meta.visible = this.isDatasetVisible(i);\n\t\t      if (meta.controller) {\n\t\t        meta.controller.updateIndex(i);\n\t\t        meta.controller.linkScales();\n\t\t      } else {\n\t\t        const ControllerClass = registry.getController(type);\n\t\t        const {datasetElementType, dataElementType} = defaults.datasets[type];\n\t\t        Object.assign(ControllerClass.prototype, {\n\t\t          dataElementType: registry.getElement(dataElementType),\n\t\t          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n\t\t        });\n\t\t        meta.controller = new ControllerClass(this, i);\n\t\t        newControllers.push(meta.controller);\n\t\t      }\n\t\t    }\n\t\t    this._updateMetasets();\n\t\t    return newControllers;\n\t\t  }\n\t\t  _resetElements() {\n\t\t    each(this.data.datasets, (dataset, datasetIndex) => {\n\t\t      this.getDatasetMeta(datasetIndex).controller.reset();\n\t\t    }, this);\n\t\t  }\n\t\t  reset() {\n\t\t    this._resetElements();\n\t\t    this.notifyPlugins('reset');\n\t\t  }\n\t\t  update(mode) {\n\t\t    const config = this.config;\n\t\t    config.update();\n\t\t    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\t\t    const animsDisabled = this._animationsDisabled = !options.animation;\n\t\t    this._updateScales();\n\t\t    this._checkEventBindings();\n\t\t    this._updateHiddenIndices();\n\t\t    this._plugins.invalidate();\n\t\t    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n\t\t      return;\n\t\t    }\n\t\t    const newControllers = this.buildOrUpdateControllers();\n\t\t    this.notifyPlugins('beforeElementsUpdate');\n\t\t    let minPadding = 0;\n\t\t    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n\t\t      const {controller} = this.getDatasetMeta(i);\n\t\t      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n\t\t      controller.buildOrUpdateElements(reset);\n\t\t      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n\t\t    }\n\t\t    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n\t\t    this._updateLayout(minPadding);\n\t\t    if (!animsDisabled) {\n\t\t      each(newControllers, (controller) => {\n\t\t        controller.reset();\n\t\t      });\n\t\t    }\n\t\t    this._updateDatasets(mode);\n\t\t    this.notifyPlugins('afterUpdate', {mode});\n\t\t    this._layers.sort(compare2Level('z', '_idx'));\n\t\t    const {_active, _lastEvent} = this;\n\t\t    if (_lastEvent) {\n\t\t      this._eventHandler(_lastEvent, true);\n\t\t    } else if (_active.length) {\n\t\t      this._updateHoverStyles(_active, _active, true);\n\t\t    }\n\t\t    this.render();\n\t\t  }\n\t\t  _updateScales() {\n\t\t    each(this.scales, (scale) => {\n\t\t      layouts.removeBox(this, scale);\n\t\t    });\n\t\t    this.ensureScalesHaveIDs();\n\t\t    this.buildOrUpdateScales();\n\t\t  }\n\t\t  _checkEventBindings() {\n\t\t    const options = this.options;\n\t\t    const existingEvents = new Set(Object.keys(this._listeners));\n\t\t    const newEvents = new Set(options.events);\n\t\t    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n\t\t      this.unbindEvents();\n\t\t      this.bindEvents();\n\t\t    }\n\t\t  }\n\t\t  _updateHiddenIndices() {\n\t\t    const {_hiddenIndices} = this;\n\t\t    const changes = this._getUniformDataChanges() || [];\n\t\t    for (const {method, start, count} of changes) {\n\t\t      const move = method === '_removeElements' ? -count : count;\n\t\t      moveNumericKeys(_hiddenIndices, start, move);\n\t\t    }\n\t\t  }\n\t\t  _getUniformDataChanges() {\n\t\t    const _dataChanges = this._dataChanges;\n\t\t    if (!_dataChanges || !_dataChanges.length) {\n\t\t      return;\n\t\t    }\n\t\t    this._dataChanges = [];\n\t\t    const datasetCount = this.data.datasets.length;\n\t\t    const makeSet = (idx) => new Set(\n\t\t      _dataChanges\n\t\t        .filter(c => c[0] === idx)\n\t\t        .map((c, i) => i + ',' + c.splice(1).join(','))\n\t\t    );\n\t\t    const changeSet = makeSet(0);\n\t\t    for (let i = 1; i < datasetCount; i++) {\n\t\t      if (!setsEqual(changeSet, makeSet(i))) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t    return Array.from(changeSet)\n\t\t      .map(c => c.split(','))\n\t\t      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n\t\t  }\n\t\t  _updateLayout(minPadding) {\n\t\t    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n\t\t      return;\n\t\t    }\n\t\t    layouts.update(this, this.width, this.height, minPadding);\n\t\t    const area = this.chartArea;\n\t\t    const noArea = area.width <= 0 || area.height <= 0;\n\t\t    this._layers = [];\n\t\t    each(this.boxes, (box) => {\n\t\t      if (noArea && box.position === 'chartArea') {\n\t\t        return;\n\t\t      }\n\t\t      if (box.configure) {\n\t\t        box.configure();\n\t\t      }\n\t\t      this._layers.push(...box._layers());\n\t\t    }, this);\n\t\t    this._layers.forEach((item, index) => {\n\t\t      item._idx = index;\n\t\t    });\n\t\t    this.notifyPlugins('afterLayout');\n\t\t  }\n\t\t  _updateDatasets(mode) {\n\t\t    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n\t\t      return;\n\t\t    }\n\t\t    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t      this.getDatasetMeta(i).controller.configure();\n\t\t    }\n\t\t    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n\t\t    }\n\t\t    this.notifyPlugins('afterDatasetsUpdate', {mode});\n\t\t  }\n\t\t  _updateDataset(index, mode) {\n\t\t    const meta = this.getDatasetMeta(index);\n\t\t    const args = {meta, index, mode, cancelable: true};\n\t\t    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n\t\t      return;\n\t\t    }\n\t\t    meta.controller._update(mode);\n\t\t    args.cancelable = false;\n\t\t    this.notifyPlugins('afterDatasetUpdate', args);\n\t\t  }\n\t\t  render() {\n\t\t    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n\t\t      return;\n\t\t    }\n\t\t    if (animator.has(this)) {\n\t\t      if (this.attached && !animator.running(this)) {\n\t\t        animator.start(this);\n\t\t      }\n\t\t    } else {\n\t\t      this.draw();\n\t\t      onAnimationsComplete({chart: this});\n\t\t    }\n\t\t  }\n\t\t  draw() {\n\t\t    let i;\n\t\t    if (this._resizeBeforeDraw) {\n\t\t      const {width, height} = this._resizeBeforeDraw;\n\t\t      this._resize(width, height);\n\t\t      this._resizeBeforeDraw = null;\n\t\t    }\n\t\t    this.clear();\n\t\t    if (this.width <= 0 || this.height <= 0) {\n\t\t      return;\n\t\t    }\n\t\t    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n\t\t      return;\n\t\t    }\n\t\t    const layers = this._layers;\n\t\t    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n\t\t      layers[i].draw(this.chartArea);\n\t\t    }\n\t\t    this._drawDatasets();\n\t\t    for (; i < layers.length; ++i) {\n\t\t      layers[i].draw(this.chartArea);\n\t\t    }\n\t\t    this.notifyPlugins('afterDraw');\n\t\t  }\n\t\t  _getSortedDatasetMetas(filterVisible) {\n\t\t    const metasets = this._sortedMetasets;\n\t\t    const result = [];\n\t\t    let i, ilen;\n\t\t    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\t      const meta = metasets[i];\n\t\t      if (!filterVisible || meta.visible) {\n\t\t        result.push(meta);\n\t\t      }\n\t\t    }\n\t\t    return result;\n\t\t  }\n\t\t  getSortedVisibleDatasetMetas() {\n\t\t    return this._getSortedDatasetMetas(true);\n\t\t  }\n\t\t  _drawDatasets() {\n\t\t    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n\t\t      return;\n\t\t    }\n\t\t    const metasets = this.getSortedVisibleDatasetMetas();\n\t\t    for (let i = metasets.length - 1; i >= 0; --i) {\n\t\t      this._drawDataset(metasets[i]);\n\t\t    }\n\t\t    this.notifyPlugins('afterDatasetsDraw');\n\t\t  }\n\t\t  _drawDataset(meta) {\n\t\t    const ctx = this.ctx;\n\t\t    const clip = meta._clip;\n\t\t    const useClip = !clip.disabled;\n\t\t    const area = this.chartArea;\n\t\t    const args = {\n\t\t      meta,\n\t\t      index: meta.index,\n\t\t      cancelable: true\n\t\t    };\n\t\t    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n\t\t      return;\n\t\t    }\n\t\t    if (useClip) {\n\t\t      clipArea(ctx, {\n\t\t        left: clip.left === false ? 0 : area.left - clip.left,\n\t\t        right: clip.right === false ? this.width : area.right + clip.right,\n\t\t        top: clip.top === false ? 0 : area.top - clip.top,\n\t\t        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n\t\t      });\n\t\t    }\n\t\t    meta.controller.draw();\n\t\t    if (useClip) {\n\t\t      unclipArea(ctx);\n\t\t    }\n\t\t    args.cancelable = false;\n\t\t    this.notifyPlugins('afterDatasetDraw', args);\n\t\t  }\n\t\t  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n\t\t    const method = Interaction.modes[mode];\n\t\t    if (typeof method === 'function') {\n\t\t      return method(this, e, options, useFinalPosition);\n\t\t    }\n\t\t    return [];\n\t\t  }\n\t\t  getDatasetMeta(datasetIndex) {\n\t\t    const dataset = this.data.datasets[datasetIndex];\n\t\t    const metasets = this._metasets;\n\t\t    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\t\t    if (!meta) {\n\t\t      meta = {\n\t\t        type: null,\n\t\t        data: [],\n\t\t        dataset: null,\n\t\t        controller: null,\n\t\t        hidden: null,\n\t\t        xAxisID: null,\n\t\t        yAxisID: null,\n\t\t        order: dataset && dataset.order || 0,\n\t\t        index: datasetIndex,\n\t\t        _dataset: dataset,\n\t\t        _parsed: [],\n\t\t        _sorted: false\n\t\t      };\n\t\t      metasets.push(meta);\n\t\t    }\n\t\t    return meta;\n\t\t  }\n\t\t  getContext() {\n\t\t    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n\t\t  }\n\t\t  getVisibleDatasetCount() {\n\t\t    return this.getSortedVisibleDatasetMetas().length;\n\t\t  }\n\t\t  isDatasetVisible(datasetIndex) {\n\t\t    const dataset = this.data.datasets[datasetIndex];\n\t\t    if (!dataset) {\n\t\t      return false;\n\t\t    }\n\t\t    const meta = this.getDatasetMeta(datasetIndex);\n\t\t    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n\t\t  }\n\t\t  setDatasetVisibility(datasetIndex, visible) {\n\t\t    const meta = this.getDatasetMeta(datasetIndex);\n\t\t    meta.hidden = !visible;\n\t\t  }\n\t\t  toggleDataVisibility(index) {\n\t\t    this._hiddenIndices[index] = !this._hiddenIndices[index];\n\t\t  }\n\t\t  getDataVisibility(index) {\n\t\t    return !this._hiddenIndices[index];\n\t\t  }\n\t\t  _updateVisibility(datasetIndex, dataIndex, visible) {\n\t\t    const mode = visible ? 'show' : 'hide';\n\t\t    const meta = this.getDatasetMeta(datasetIndex);\n\t\t    const anims = meta.controller._resolveAnimations(undefined, mode);\n\t\t    if (defined(dataIndex)) {\n\t\t      meta.data[dataIndex].hidden = !visible;\n\t\t      this.update();\n\t\t    } else {\n\t\t      this.setDatasetVisibility(datasetIndex, visible);\n\t\t      anims.update(meta, {visible});\n\t\t      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n\t\t    }\n\t\t  }\n\t\t  hide(datasetIndex, dataIndex) {\n\t\t    this._updateVisibility(datasetIndex, dataIndex, false);\n\t\t  }\n\t\t  show(datasetIndex, dataIndex) {\n\t\t    this._updateVisibility(datasetIndex, dataIndex, true);\n\t\t  }\n\t\t  _destroyDatasetMeta(datasetIndex) {\n\t\t    const meta = this._metasets[datasetIndex];\n\t\t    if (meta && meta.controller) {\n\t\t      meta.controller._destroy();\n\t\t    }\n\t\t    delete this._metasets[datasetIndex];\n\t\t  }\n\t\t  _stop() {\n\t\t    let i, ilen;\n\t\t    this.stop();\n\t\t    animator.remove(this);\n\t\t    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t      this._destroyDatasetMeta(i);\n\t\t    }\n\t\t  }\n\t\t  destroy() {\n\t\t    this.notifyPlugins('beforeDestroy');\n\t\t    const {canvas, ctx} = this;\n\t\t    this._stop();\n\t\t    this.config.clearCache();\n\t\t    if (canvas) {\n\t\t      this.unbindEvents();\n\t\t      clearCanvas(canvas, ctx);\n\t\t      this.platform.releaseContext(ctx);\n\t\t      this.canvas = null;\n\t\t      this.ctx = null;\n\t\t    }\n\t\t    this.notifyPlugins('destroy');\n\t\t    delete instances[this.id];\n\t\t    this.notifyPlugins('afterDestroy');\n\t\t  }\n\t\t  toBase64Image(...args) {\n\t\t    return this.canvas.toDataURL(...args);\n\t\t  }\n\t\t  bindEvents() {\n\t\t    this.bindUserEvents();\n\t\t    if (this.options.responsive) {\n\t\t      this.bindResponsiveEvents();\n\t\t    } else {\n\t\t      this.attached = true;\n\t\t    }\n\t\t  }\n\t\t  bindUserEvents() {\n\t\t    const listeners = this._listeners;\n\t\t    const platform = this.platform;\n\t\t    const _add = (type, listener) => {\n\t\t      platform.addEventListener(this, type, listener);\n\t\t      listeners[type] = listener;\n\t\t    };\n\t\t    const listener = (e, x, y) => {\n\t\t      e.offsetX = x;\n\t\t      e.offsetY = y;\n\t\t      this._eventHandler(e);\n\t\t    };\n\t\t    each(this.options.events, (type) => _add(type, listener));\n\t\t  }\n\t\t  bindResponsiveEvents() {\n\t\t    if (!this._responsiveListeners) {\n\t\t      this._responsiveListeners = {};\n\t\t    }\n\t\t    const listeners = this._responsiveListeners;\n\t\t    const platform = this.platform;\n\t\t    const _add = (type, listener) => {\n\t\t      platform.addEventListener(this, type, listener);\n\t\t      listeners[type] = listener;\n\t\t    };\n\t\t    const _remove = (type, listener) => {\n\t\t      if (listeners[type]) {\n\t\t        platform.removeEventListener(this, type, listener);\n\t\t        delete listeners[type];\n\t\t      }\n\t\t    };\n\t\t    const listener = (width, height) => {\n\t\t      if (this.canvas) {\n\t\t        this.resize(width, height);\n\t\t      }\n\t\t    };\n\t\t    let detached;\n\t\t    const attached = () => {\n\t\t      _remove('attach', attached);\n\t\t      this.attached = true;\n\t\t      this.resize();\n\t\t      _add('resize', listener);\n\t\t      _add('detach', detached);\n\t\t    };\n\t\t    detached = () => {\n\t\t      this.attached = false;\n\t\t      _remove('resize', listener);\n\t\t      this._stop();\n\t\t      this._resize(0, 0);\n\t\t      _add('attach', attached);\n\t\t    };\n\t\t    if (platform.isAttached(this.canvas)) {\n\t\t      attached();\n\t\t    } else {\n\t\t      detached();\n\t\t    }\n\t\t  }\n\t\t  unbindEvents() {\n\t\t    each(this._listeners, (listener, type) => {\n\t\t      this.platform.removeEventListener(this, type, listener);\n\t\t    });\n\t\t    this._listeners = {};\n\t\t    each(this._responsiveListeners, (listener, type) => {\n\t\t      this.platform.removeEventListener(this, type, listener);\n\t\t    });\n\t\t    this._responsiveListeners = undefined;\n\t\t  }\n\t\t  updateHoverStyle(items, mode, enabled) {\n\t\t    const prefix = enabled ? 'set' : 'remove';\n\t\t    let meta, item, i, ilen;\n\t\t    if (mode === 'dataset') {\n\t\t      meta = this.getDatasetMeta(items[0].datasetIndex);\n\t\t      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n\t\t    }\n\t\t    for (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t      item = items[i];\n\t\t      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n\t\t      if (controller) {\n\t\t        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  getActiveElements() {\n\t\t    return this._active || [];\n\t\t  }\n\t\t  setActiveElements(activeElements) {\n\t\t    const lastActive = this._active || [];\n\t\t    const active = activeElements.map(({datasetIndex, index}) => {\n\t\t      const meta = this.getDatasetMeta(datasetIndex);\n\t\t      if (!meta) {\n\t\t        throw new Error('No dataset found at index ' + datasetIndex);\n\t\t      }\n\t\t      return {\n\t\t        datasetIndex,\n\t\t        element: meta.data[index],\n\t\t        index,\n\t\t      };\n\t\t    });\n\t\t    const changed = !_elementsEqual(active, lastActive);\n\t\t    if (changed) {\n\t\t      this._active = active;\n\t\t      this._lastEvent = null;\n\t\t      this._updateHoverStyles(active, lastActive);\n\t\t    }\n\t\t  }\n\t\t  notifyPlugins(hook, args, filter) {\n\t\t    return this._plugins.notify(this, hook, args, filter);\n\t\t  }\n\t\t  _updateHoverStyles(active, lastActive, replay) {\n\t\t    const hoverOptions = this.options.hover;\n\t\t    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n\t\t    const deactivated = diff(lastActive, active);\n\t\t    const activated = replay ? active : diff(active, lastActive);\n\t\t    if (deactivated.length) {\n\t\t      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n\t\t    }\n\t\t    if (activated.length && hoverOptions.mode) {\n\t\t      this.updateHoverStyle(activated, hoverOptions.mode, true);\n\t\t    }\n\t\t  }\n\t\t  _eventHandler(e, replay) {\n\t\t    const args = {\n\t\t      event: e,\n\t\t      replay,\n\t\t      cancelable: true,\n\t\t      inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)\n\t\t    };\n\t\t    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\t\t    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n\t\t      return;\n\t\t    }\n\t\t    const changed = this._handleEvent(e, replay, args.inChartArea);\n\t\t    args.cancelable = false;\n\t\t    this.notifyPlugins('afterEvent', args, eventFilter);\n\t\t    if (changed || args.changed) {\n\t\t      this.render();\n\t\t    }\n\t\t    return this;\n\t\t  }\n\t\t  _handleEvent(e, replay, inChartArea) {\n\t\t    const {_active: lastActive = [], options} = this;\n\t\t    const useFinalPosition = replay;\n\t\t    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n\t\t    const isClick = _isClickEvent(e);\n\t\t    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\t\t    if (inChartArea) {\n\t\t      this._lastEvent = null;\n\t\t      callback(options.onHover, [e, active, this], this);\n\t\t      if (isClick) {\n\t\t        callback(options.onClick, [e, active, this], this);\n\t\t      }\n\t\t    }\n\t\t    const changed = !_elementsEqual(active, lastActive);\n\t\t    if (changed || replay) {\n\t\t      this._active = active;\n\t\t      this._updateHoverStyles(active, lastActive, replay);\n\t\t    }\n\t\t    this._lastEvent = lastEvent;\n\t\t    return changed;\n\t\t  }\n\t\t  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n\t\t    if (e.type === 'mouseout') {\n\t\t      return [];\n\t\t    }\n\t\t    if (!inChartArea) {\n\t\t      return lastActive;\n\t\t    }\n\t\t    const hoverOptions = this.options.hover;\n\t\t    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n\t\t  }\n\t\t}\n\t\tconst invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\n\t\tconst enumerable = true;\n\t\tObject.defineProperties(Chart, {\n\t\t  defaults: {\n\t\t    enumerable,\n\t\t    value: defaults\n\t\t  },\n\t\t  instances: {\n\t\t    enumerable,\n\t\t    value: instances\n\t\t  },\n\t\t  overrides: {\n\t\t    enumerable,\n\t\t    value: overrides\n\t\t  },\n\t\t  registry: {\n\t\t    enumerable,\n\t\t    value: registry\n\t\t  },\n\t\t  version: {\n\t\t    enumerable,\n\t\t    value: version\n\t\t  },\n\t\t  getChart: {\n\t\t    enumerable,\n\t\t    value: getChart\n\t\t  },\n\t\t  register: {\n\t\t    enumerable,\n\t\t    value: (...items) => {\n\t\t      registry.add(...items);\n\t\t      invalidatePlugins();\n\t\t    }\n\t\t  },\n\t\t  unregister: {\n\t\t    enumerable,\n\t\t    value: (...items) => {\n\t\t      registry.remove(...items);\n\t\t      invalidatePlugins();\n\t\t    }\n\t\t  }\n\t\t});\n\n\t\tfunction abstract() {\n\t\t  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n\t\t}\n\t\tclass DateAdapter {\n\t\t  constructor(options) {\n\t\t    this.options = options || {};\n\t\t  }\n\t\t  formats() {\n\t\t    return abstract();\n\t\t  }\n\t\t  parse(value, format) {\n\t\t    return abstract();\n\t\t  }\n\t\t  format(timestamp, format) {\n\t\t    return abstract();\n\t\t  }\n\t\t  add(timestamp, amount, unit) {\n\t\t    return abstract();\n\t\t  }\n\t\t  diff(a, b, unit) {\n\t\t    return abstract();\n\t\t  }\n\t\t  startOf(timestamp, unit, weekday) {\n\t\t    return abstract();\n\t\t  }\n\t\t  endOf(timestamp, unit) {\n\t\t    return abstract();\n\t\t  }\n\t\t}\n\t\tDateAdapter.override = function(members) {\n\t\t  Object.assign(DateAdapter.prototype, members);\n\t\t};\n\t\tvar _adapters = {\n\t\t  _date: DateAdapter\n\t\t};\n\n\t\tfunction getAllScaleValues(scale, type) {\n\t\t  if (!scale._cache.$bar) {\n\t\t    const visibleMetas = scale.getMatchingVisibleMetas(type);\n\t\t    let values = [];\n\t\t    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n\t\t      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n\t\t    }\n\t\t    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n\t\t  }\n\t\t  return scale._cache.$bar;\n\t\t}\n\t\tfunction computeMinSampleSize(meta) {\n\t\t  const scale = meta.iScale;\n\t\t  const values = getAllScaleValues(scale, meta.type);\n\t\t  let min = scale._length;\n\t\t  let i, ilen, curr, prev;\n\t\t  const updateMinAndPrev = () => {\n\t\t    if (curr === 32767 || curr === -32768) {\n\t\t      return;\n\t\t    }\n\t\t    if (defined(prev)) {\n\t\t      min = Math.min(min, Math.abs(curr - prev) || min);\n\t\t    }\n\t\t    prev = curr;\n\t\t  };\n\t\t  for (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\t    curr = scale.getPixelForValue(values[i]);\n\t\t    updateMinAndPrev();\n\t\t  }\n\t\t  prev = undefined;\n\t\t  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n\t\t    curr = scale.getPixelForTick(i);\n\t\t    updateMinAndPrev();\n\t\t  }\n\t\t  return min;\n\t\t}\n\t\tfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n\t\t  const thickness = options.barThickness;\n\t\t  let size, ratio;\n\t\t  if (isNullOrUndef(thickness)) {\n\t\t    size = ruler.min * options.categoryPercentage;\n\t\t    ratio = options.barPercentage;\n\t\t  } else {\n\t\t    size = thickness * stackCount;\n\t\t    ratio = 1;\n\t\t  }\n\t\t  return {\n\t\t    chunk: size / stackCount,\n\t\t    ratio,\n\t\t    start: ruler.pixels[index] - (size / 2)\n\t\t  };\n\t\t}\n\t\tfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n\t\t  const pixels = ruler.pixels;\n\t\t  const curr = pixels[index];\n\t\t  let prev = index > 0 ? pixels[index - 1] : null;\n\t\t  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\t\t  const percent = options.categoryPercentage;\n\t\t  if (prev === null) {\n\t\t    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n\t\t  }\n\t\t  if (next === null) {\n\t\t    next = curr + curr - prev;\n\t\t  }\n\t\t  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n\t\t  const size = Math.abs(next - prev) / 2 * percent;\n\t\t  return {\n\t\t    chunk: size / stackCount,\n\t\t    ratio: options.barPercentage,\n\t\t    start\n\t\t  };\n\t\t}\n\t\tfunction parseFloatBar(entry, item, vScale, i) {\n\t\t  const startValue = vScale.parse(entry[0], i);\n\t\t  const endValue = vScale.parse(entry[1], i);\n\t\t  const min = Math.min(startValue, endValue);\n\t\t  const max = Math.max(startValue, endValue);\n\t\t  let barStart = min;\n\t\t  let barEnd = max;\n\t\t  if (Math.abs(min) > Math.abs(max)) {\n\t\t    barStart = max;\n\t\t    barEnd = min;\n\t\t  }\n\t\t  item[vScale.axis] = barEnd;\n\t\t  item._custom = {\n\t\t    barStart,\n\t\t    barEnd,\n\t\t    start: startValue,\n\t\t    end: endValue,\n\t\t    min,\n\t\t    max\n\t\t  };\n\t\t}\n\t\tfunction parseValue(entry, item, vScale, i) {\n\t\t  if (isArray(entry)) {\n\t\t    parseFloatBar(entry, item, vScale, i);\n\t\t  } else {\n\t\t    item[vScale.axis] = vScale.parse(entry, i);\n\t\t  }\n\t\t  return item;\n\t\t}\n\t\tfunction parseArrayOrPrimitive(meta, data, start, count) {\n\t\t  const iScale = meta.iScale;\n\t\t  const vScale = meta.vScale;\n\t\t  const labels = iScale.getLabels();\n\t\t  const singleScale = iScale === vScale;\n\t\t  const parsed = [];\n\t\t  let i, ilen, item, entry;\n\t\t  for (i = start, ilen = start + count; i < ilen; ++i) {\n\t\t    entry = data[i];\n\t\t    item = {};\n\t\t    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n\t\t    parsed.push(parseValue(entry, item, vScale, i));\n\t\t  }\n\t\t  return parsed;\n\t\t}\n\t\tfunction isFloatBar(custom) {\n\t\t  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n\t\t}\n\t\tfunction barSign(size, vScale, actualBase) {\n\t\t  if (size !== 0) {\n\t\t    return sign(size);\n\t\t  }\n\t\t  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n\t\t}\n\t\tfunction borderProps(properties) {\n\t\t  let reverse, start, end, top, bottom;\n\t\t  if (properties.horizontal) {\n\t\t    reverse = properties.base > properties.x;\n\t\t    start = 'left';\n\t\t    end = 'right';\n\t\t  } else {\n\t\t    reverse = properties.base < properties.y;\n\t\t    start = 'bottom';\n\t\t    end = 'top';\n\t\t  }\n\t\t  if (reverse) {\n\t\t    top = 'end';\n\t\t    bottom = 'start';\n\t\t  } else {\n\t\t    top = 'start';\n\t\t    bottom = 'end';\n\t\t  }\n\t\t  return {start, end, reverse, top, bottom};\n\t\t}\n\t\tfunction setBorderSkipped(properties, options, stack, index) {\n\t\t  let edge = options.borderSkipped;\n\t\t  const res = {};\n\t\t  if (!edge) {\n\t\t    properties.borderSkipped = res;\n\t\t    return;\n\t\t  }\n\t\t  const {start, end, reverse, top, bottom} = borderProps(properties);\n\t\t  if (edge === 'middle' && stack) {\n\t\t    properties.enableBorderRadius = true;\n\t\t    if ((stack._top || 0) === index) {\n\t\t      edge = top;\n\t\t    } else if ((stack._bottom || 0) === index) {\n\t\t      edge = bottom;\n\t\t    } else {\n\t\t      res[parseEdge(bottom, start, end, reverse)] = true;\n\t\t      edge = top;\n\t\t    }\n\t\t  }\n\t\t  res[parseEdge(edge, start, end, reverse)] = true;\n\t\t  properties.borderSkipped = res;\n\t\t}\n\t\tfunction parseEdge(edge, a, b, reverse) {\n\t\t  if (reverse) {\n\t\t    edge = swap(edge, a, b);\n\t\t    edge = startEnd(edge, b, a);\n\t\t  } else {\n\t\t    edge = startEnd(edge, a, b);\n\t\t  }\n\t\t  return edge;\n\t\t}\n\t\tfunction swap(orig, v1, v2) {\n\t\t  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n\t\t}\n\t\tfunction startEnd(v, start, end) {\n\t\t  return v === 'start' ? start : v === 'end' ? end : v;\n\t\t}\n\t\tfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n\t\t  properties.inflateAmount = inflateAmount === 'auto'\n\t\t    ? ratio === 1 ? 0.33 : 0\n\t\t    : inflateAmount;\n\t\t}\n\t\tclass BarController extends DatasetController {\n\t\t  parsePrimitiveData(meta, data, start, count) {\n\t\t    return parseArrayOrPrimitive(meta, data, start, count);\n\t\t  }\n\t\t  parseArrayData(meta, data, start, count) {\n\t\t    return parseArrayOrPrimitive(meta, data, start, count);\n\t\t  }\n\t\t  parseObjectData(meta, data, start, count) {\n\t\t    const {iScale, vScale} = meta;\n\t\t    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n\t\t    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n\t\t    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n\t\t    const parsed = [];\n\t\t    let i, ilen, item, obj;\n\t\t    for (i = start, ilen = start + count; i < ilen; ++i) {\n\t\t      obj = data[i];\n\t\t      item = {};\n\t\t      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n\t\t      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n\t\t    }\n\t\t    return parsed;\n\t\t  }\n\t\t  updateRangeFromParsed(range, scale, parsed, stack) {\n\t\t    super.updateRangeFromParsed(range, scale, parsed, stack);\n\t\t    const custom = parsed._custom;\n\t\t    if (custom && scale === this._cachedMeta.vScale) {\n\t\t      range.min = Math.min(range.min, custom.min);\n\t\t      range.max = Math.max(range.max, custom.max);\n\t\t    }\n\t\t  }\n\t\t  getMaxOverflow() {\n\t\t    return 0;\n\t\t  }\n\t\t  getLabelAndValue(index) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const {iScale, vScale} = meta;\n\t\t    const parsed = this.getParsed(index);\n\t\t    const custom = parsed._custom;\n\t\t    const value = isFloatBar(custom)\n\t\t      ? '[' + custom.start + ', ' + custom.end + ']'\n\t\t      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\t\t    return {\n\t\t      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n\t\t      value\n\t\t    };\n\t\t  }\n\t\t  initialize() {\n\t\t    this.enableOptionSharing = true;\n\t\t    super.initialize();\n\t\t    const meta = this._cachedMeta;\n\t\t    meta.stack = this.getDataset().stack;\n\t\t  }\n\t\t  update(mode) {\n\t\t    const meta = this._cachedMeta;\n\t\t    this.updateElements(meta.data, 0, meta.data.length, mode);\n\t\t  }\n\t\t  updateElements(bars, start, count, mode) {\n\t\t    const reset = mode === 'reset';\n\t\t    const {index, _cachedMeta: {vScale}} = this;\n\t\t    const base = vScale.getBasePixel();\n\t\t    const horizontal = vScale.isHorizontal();\n\t\t    const ruler = this._getRuler();\n\t\t    const firstOpts = this.resolveDataElementOptions(start, mode);\n\t\t    const sharedOptions = this.getSharedOptions(firstOpts);\n\t\t    const includeOptions = this.includeOptions(mode, sharedOptions);\n\t\t    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t\t    for (let i = start; i < start + count; i++) {\n\t\t      const parsed = this.getParsed(i);\n\t\t      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n\t\t      const ipixels = this._calculateBarIndexPixels(i, ruler);\n\t\t      const stack = (parsed._stacks || {})[vScale.axis];\n\t\t      const properties = {\n\t\t        horizontal,\n\t\t        base: vpixels.base,\n\t\t        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n\t\t        x: horizontal ? vpixels.head : ipixels.center,\n\t\t        y: horizontal ? ipixels.center : vpixels.head,\n\t\t        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n\t\t        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n\t\t      };\n\t\t      if (includeOptions) {\n\t\t        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n\t\t      }\n\t\t      const options = properties.options || bars[i].options;\n\t\t      setBorderSkipped(properties, options, stack, index);\n\t\t      setInflateAmount(properties, options, ruler.ratio);\n\t\t      this.updateElement(bars[i], i, properties, mode);\n\t\t    }\n\t\t  }\n\t\t  _getStacks(last, dataIndex) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const iScale = meta.iScale;\n\t\t    const metasets = iScale.getMatchingVisibleMetas(this._type);\n\t\t    const stacked = iScale.options.stacked;\n\t\t    const ilen = metasets.length;\n\t\t    const stacks = [];\n\t\t    let i, item;\n\t\t    for (i = 0; i < ilen; ++i) {\n\t\t      item = metasets[i];\n\t\t      if (!item.controller.options.grouped) {\n\t\t        continue;\n\t\t      }\n\t\t      if (typeof dataIndex !== 'undefined') {\n\t\t        const val = item.controller.getParsed(dataIndex)[\n\t\t          item.controller._cachedMeta.vScale.axis\n\t\t        ];\n\t\t        if (isNullOrUndef(val) || isNaN(val)) {\n\t\t          continue;\n\t\t        }\n\t\t      }\n\t\t      if (stacked === false || stacks.indexOf(item.stack) === -1 ||\n\t\t\t\t\t\t(stacked === undefined && item.stack === undefined)) {\n\t\t        stacks.push(item.stack);\n\t\t      }\n\t\t      if (item.index === last) {\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t    if (!stacks.length) {\n\t\t      stacks.push(undefined);\n\t\t    }\n\t\t    return stacks;\n\t\t  }\n\t\t  _getStackCount(index) {\n\t\t    return this._getStacks(undefined, index).length;\n\t\t  }\n\t\t  _getStackIndex(datasetIndex, name, dataIndex) {\n\t\t    const stacks = this._getStacks(datasetIndex, dataIndex);\n\t\t    const index = (name !== undefined)\n\t\t      ? stacks.indexOf(name)\n\t\t      : -1;\n\t\t    return (index === -1)\n\t\t      ? stacks.length - 1\n\t\t      : index;\n\t\t  }\n\t\t  _getRuler() {\n\t\t    const opts = this.options;\n\t\t    const meta = this._cachedMeta;\n\t\t    const iScale = meta.iScale;\n\t\t    const pixels = [];\n\t\t    let i, ilen;\n\t\t    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n\t\t      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n\t\t    }\n\t\t    const barThickness = opts.barThickness;\n\t\t    const min = barThickness || computeMinSampleSize(meta);\n\t\t    return {\n\t\t      min,\n\t\t      pixels,\n\t\t      start: iScale._startPixel,\n\t\t      end: iScale._endPixel,\n\t\t      stackCount: this._getStackCount(),\n\t\t      scale: iScale,\n\t\t      grouped: opts.grouped,\n\t\t      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n\t\t    };\n\t\t  }\n\t\t  _calculateBarValuePixels(index) {\n\t\t    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n\t\t    const actualBase = baseValue || 0;\n\t\t    const parsed = this.getParsed(index);\n\t\t    const custom = parsed._custom;\n\t\t    const floating = isFloatBar(custom);\n\t\t    let value = parsed[vScale.axis];\n\t\t    let start = 0;\n\t\t    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n\t\t    let head, size;\n\t\t    if (length !== value) {\n\t\t      start = length - value;\n\t\t      length = value;\n\t\t    }\n\t\t    if (floating) {\n\t\t      value = custom.barStart;\n\t\t      length = custom.barEnd - custom.barStart;\n\t\t      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n\t\t        start = 0;\n\t\t      }\n\t\t      start += value;\n\t\t    }\n\t\t    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n\t\t    let base = vScale.getPixelForValue(startValue);\n\t\t    if (this.chart.getDataVisibility(index)) {\n\t\t      head = vScale.getPixelForValue(start + length);\n\t\t    } else {\n\t\t      head = base;\n\t\t    }\n\t\t    size = head - base;\n\t\t    if (Math.abs(size) < minBarLength) {\n\t\t      size = barSign(size, vScale, actualBase) * minBarLength;\n\t\t      if (value === actualBase) {\n\t\t        base -= size / 2;\n\t\t      }\n\t\t      head = base + size;\n\t\t    }\n\t\t    if (base === vScale.getPixelForValue(actualBase)) {\n\t\t      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n\t\t      base += halfGrid;\n\t\t      size -= halfGrid;\n\t\t    }\n\t\t    return {\n\t\t      size,\n\t\t      base,\n\t\t      head,\n\t\t      center: head + size / 2\n\t\t    };\n\t\t  }\n\t\t  _calculateBarIndexPixels(index, ruler) {\n\t\t    const scale = ruler.scale;\n\t\t    const options = this.options;\n\t\t    const skipNull = options.skipNull;\n\t\t    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n\t\t    let center, size;\n\t\t    if (ruler.grouped) {\n\t\t      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n\t\t      const range = options.barThickness === 'flex'\n\t\t        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n\t\t        : computeFitCategoryTraits(index, ruler, options, stackCount);\n\t\t      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n\t\t      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n\t\t    } else {\n\t\t      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n\t\t      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n\t\t    }\n\t\t    return {\n\t\t      base: center - size / 2,\n\t\t      head: center + size / 2,\n\t\t      center,\n\t\t      size\n\t\t    };\n\t\t  }\n\t\t  draw() {\n\t\t    const meta = this._cachedMeta;\n\t\t    const vScale = meta.vScale;\n\t\t    const rects = meta.data;\n\t\t    const ilen = rects.length;\n\t\t    let i = 0;\n\t\t    for (; i < ilen; ++i) {\n\t\t      if (this.getParsed(i)[vScale.axis] !== null) {\n\t\t        rects[i].draw(this._ctx);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\tBarController.id = 'bar';\n\t\tBarController.defaults = {\n\t\t  datasetElementType: false,\n\t\t  dataElementType: 'bar',\n\t\t  categoryPercentage: 0.8,\n\t\t  barPercentage: 0.9,\n\t\t  grouped: true,\n\t\t  animations: {\n\t\t    numbers: {\n\t\t      type: 'number',\n\t\t      properties: ['x', 'y', 'base', 'width', 'height']\n\t\t    }\n\t\t  }\n\t\t};\n\t\tBarController.overrides = {\n\t\t  scales: {\n\t\t    _index_: {\n\t\t      type: 'category',\n\t\t      offset: true,\n\t\t      grid: {\n\t\t        offset: true\n\t\t      }\n\t\t    },\n\t\t    _value_: {\n\t\t      type: 'linear',\n\t\t      beginAtZero: true,\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tclass BubbleController extends DatasetController {\n\t\t  initialize() {\n\t\t    this.enableOptionSharing = true;\n\t\t    super.initialize();\n\t\t  }\n\t\t  parsePrimitiveData(meta, data, start, count) {\n\t\t    const parsed = super.parsePrimitiveData(meta, data, start, count);\n\t\t    for (let i = 0; i < parsed.length; i++) {\n\t\t      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n\t\t    }\n\t\t    return parsed;\n\t\t  }\n\t\t  parseArrayData(meta, data, start, count) {\n\t\t    const parsed = super.parseArrayData(meta, data, start, count);\n\t\t    for (let i = 0; i < parsed.length; i++) {\n\t\t      const item = data[start + i];\n\t\t      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n\t\t    }\n\t\t    return parsed;\n\t\t  }\n\t\t  parseObjectData(meta, data, start, count) {\n\t\t    const parsed = super.parseObjectData(meta, data, start, count);\n\t\t    for (let i = 0; i < parsed.length; i++) {\n\t\t      const item = data[start + i];\n\t\t      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n\t\t    }\n\t\t    return parsed;\n\t\t  }\n\t\t  getMaxOverflow() {\n\t\t    const data = this._cachedMeta.data;\n\t\t    let max = 0;\n\t\t    for (let i = data.length - 1; i >= 0; --i) {\n\t\t      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n\t\t    }\n\t\t    return max > 0 && max;\n\t\t  }\n\t\t  getLabelAndValue(index) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const {xScale, yScale} = meta;\n\t\t    const parsed = this.getParsed(index);\n\t\t    const x = xScale.getLabelForValue(parsed.x);\n\t\t    const y = yScale.getLabelForValue(parsed.y);\n\t\t    const r = parsed._custom;\n\t\t    return {\n\t\t      label: meta.label,\n\t\t      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n\t\t    };\n\t\t  }\n\t\t  update(mode) {\n\t\t    const points = this._cachedMeta.data;\n\t\t    this.updateElements(points, 0, points.length, mode);\n\t\t  }\n\t\t  updateElements(points, start, count, mode) {\n\t\t    const reset = mode === 'reset';\n\t\t    const {iScale, vScale} = this._cachedMeta;\n\t\t    const firstOpts = this.resolveDataElementOptions(start, mode);\n\t\t    const sharedOptions = this.getSharedOptions(firstOpts);\n\t\t    const includeOptions = this.includeOptions(mode, sharedOptions);\n\t\t    const iAxis = iScale.axis;\n\t\t    const vAxis = vScale.axis;\n\t\t    for (let i = start; i < start + count; i++) {\n\t\t      const point = points[i];\n\t\t      const parsed = !reset && this.getParsed(i);\n\t\t      const properties = {};\n\t\t      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n\t\t      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\t\t      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\t\t      if (includeOptions) {\n\t\t        properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\t\t        if (reset) {\n\t\t          properties.options.radius = 0;\n\t\t        }\n\t\t      }\n\t\t      this.updateElement(point, i, properties, mode);\n\t\t    }\n\t\t    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t\t  }\n\t\t  resolveDataElementOptions(index, mode) {\n\t\t    const parsed = this.getParsed(index);\n\t\t    let values = super.resolveDataElementOptions(index, mode);\n\t\t    if (values.$shared) {\n\t\t      values = Object.assign({}, values, {$shared: false});\n\t\t    }\n\t\t    const radius = values.radius;\n\t\t    if (mode !== 'active') {\n\t\t      values.radius = 0;\n\t\t    }\n\t\t    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\t\t    return values;\n\t\t  }\n\t\t}\n\t\tBubbleController.id = 'bubble';\n\t\tBubbleController.defaults = {\n\t\t  datasetElementType: false,\n\t\t  dataElementType: 'point',\n\t\t  animations: {\n\t\t    numbers: {\n\t\t      type: 'number',\n\t\t      properties: ['x', 'y', 'borderWidth', 'radius']\n\t\t    }\n\t\t  }\n\t\t};\n\t\tBubbleController.overrides = {\n\t\t  scales: {\n\t\t    x: {\n\t\t      type: 'linear'\n\t\t    },\n\t\t    y: {\n\t\t      type: 'linear'\n\t\t    }\n\t\t  },\n\t\t  plugins: {\n\t\t    tooltip: {\n\t\t      callbacks: {\n\t\t        title() {\n\t\t          return '';\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tfunction getRatioAndOffset(rotation, circumference, cutout) {\n\t\t  let ratioX = 1;\n\t\t  let ratioY = 1;\n\t\t  let offsetX = 0;\n\t\t  let offsetY = 0;\n\t\t  if (circumference < TAU) {\n\t\t    const startAngle = rotation;\n\t\t    const endAngle = startAngle + circumference;\n\t\t    const startX = Math.cos(startAngle);\n\t\t    const startY = Math.sin(startAngle);\n\t\t    const endX = Math.cos(endAngle);\n\t\t    const endY = Math.sin(endAngle);\n\t\t    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n\t\t    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n\t\t    const maxX = calcMax(0, startX, endX);\n\t\t    const maxY = calcMax(HALF_PI, startY, endY);\n\t\t    const minX = calcMin(PI, startX, endX);\n\t\t    const minY = calcMin(PI + HALF_PI, startY, endY);\n\t\t    ratioX = (maxX - minX) / 2;\n\t\t    ratioY = (maxY - minY) / 2;\n\t\t    offsetX = -(maxX + minX) / 2;\n\t\t    offsetY = -(maxY + minY) / 2;\n\t\t  }\n\t\t  return {ratioX, ratioY, offsetX, offsetY};\n\t\t}\n\t\tclass DoughnutController extends DatasetController {\n\t\t  constructor(chart, datasetIndex) {\n\t\t    super(chart, datasetIndex);\n\t\t    this.enableOptionSharing = true;\n\t\t    this.innerRadius = undefined;\n\t\t    this.outerRadius = undefined;\n\t\t    this.offsetX = undefined;\n\t\t    this.offsetY = undefined;\n\t\t  }\n\t\t  linkScales() {}\n\t\t  parse(start, count) {\n\t\t    const data = this.getDataset().data;\n\t\t    const meta = this._cachedMeta;\n\t\t    if (this._parsing === false) {\n\t\t      meta._parsed = data;\n\t\t    } else {\n\t\t      let getter = (i) => +data[i];\n\t\t      if (isObject(data[start])) {\n\t\t        const {key = 'value'} = this._parsing;\n\t\t        getter = (i) => +resolveObjectKey(data[i], key);\n\t\t      }\n\t\t      let i, ilen;\n\t\t      for (i = start, ilen = start + count; i < ilen; ++i) {\n\t\t        meta._parsed[i] = getter(i);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  _getRotation() {\n\t\t    return toRadians(this.options.rotation - 90);\n\t\t  }\n\t\t  _getCircumference() {\n\t\t    return toRadians(this.options.circumference);\n\t\t  }\n\t\t  _getRotationExtents() {\n\t\t    let min = TAU;\n\t\t    let max = -TAU;\n\t\t    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n\t\t      if (this.chart.isDatasetVisible(i)) {\n\t\t        const controller = this.chart.getDatasetMeta(i).controller;\n\t\t        const rotation = controller._getRotation();\n\t\t        const circumference = controller._getCircumference();\n\t\t        min = Math.min(min, rotation);\n\t\t        max = Math.max(max, rotation + circumference);\n\t\t      }\n\t\t    }\n\t\t    return {\n\t\t      rotation: min,\n\t\t      circumference: max - min,\n\t\t    };\n\t\t  }\n\t\t  update(mode) {\n\t\t    const chart = this.chart;\n\t\t    const {chartArea} = chart;\n\t\t    const meta = this._cachedMeta;\n\t\t    const arcs = meta.data;\n\t\t    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n\t\t    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n\t\t    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n\t\t    const chartWeight = this._getRingWeight(this.index);\n\t\t    const {circumference, rotation} = this._getRotationExtents();\n\t\t    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n\t\t    const maxWidth = (chartArea.width - spacing) / ratioX;\n\t\t    const maxHeight = (chartArea.height - spacing) / ratioY;\n\t\t    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n\t\t    const outerRadius = toDimension(this.options.radius, maxRadius);\n\t\t    const innerRadius = Math.max(outerRadius * cutout, 0);\n\t\t    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n\t\t    this.offsetX = offsetX * outerRadius;\n\t\t    this.offsetY = offsetY * outerRadius;\n\t\t    meta.total = this.calculateTotal();\n\t\t    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n\t\t    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\t\t    this.updateElements(arcs, 0, arcs.length, mode);\n\t\t  }\n\t\t  _circumference(i, reset) {\n\t\t    const opts = this.options;\n\t\t    const meta = this._cachedMeta;\n\t\t    const circumference = this._getCircumference();\n\t\t    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n\t\t      return 0;\n\t\t    }\n\t\t    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n\t\t  }\n\t\t  updateElements(arcs, start, count, mode) {\n\t\t    const reset = mode === 'reset';\n\t\t    const chart = this.chart;\n\t\t    const chartArea = chart.chartArea;\n\t\t    const opts = chart.options;\n\t\t    const animationOpts = opts.animation;\n\t\t    const centerX = (chartArea.left + chartArea.right) / 2;\n\t\t    const centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\t    const animateScale = reset && animationOpts.animateScale;\n\t\t    const innerRadius = animateScale ? 0 : this.innerRadius;\n\t\t    const outerRadius = animateScale ? 0 : this.outerRadius;\n\t\t    const firstOpts = this.resolveDataElementOptions(start, mode);\n\t\t    const sharedOptions = this.getSharedOptions(firstOpts);\n\t\t    const includeOptions = this.includeOptions(mode, sharedOptions);\n\t\t    let startAngle = this._getRotation();\n\t\t    let i;\n\t\t    for (i = 0; i < start; ++i) {\n\t\t      startAngle += this._circumference(i, reset);\n\t\t    }\n\t\t    for (i = start; i < start + count; ++i) {\n\t\t      const circumference = this._circumference(i, reset);\n\t\t      const arc = arcs[i];\n\t\t      const properties = {\n\t\t        x: centerX + this.offsetX,\n\t\t        y: centerY + this.offsetY,\n\t\t        startAngle,\n\t\t        endAngle: startAngle + circumference,\n\t\t        circumference,\n\t\t        outerRadius,\n\t\t        innerRadius\n\t\t      };\n\t\t      if (includeOptions) {\n\t\t        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n\t\t      }\n\t\t      startAngle += circumference;\n\t\t      this.updateElement(arc, i, properties, mode);\n\t\t    }\n\t\t    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t\t  }\n\t\t  calculateTotal() {\n\t\t    const meta = this._cachedMeta;\n\t\t    const metaData = meta.data;\n\t\t    let total = 0;\n\t\t    let i;\n\t\t    for (i = 0; i < metaData.length; i++) {\n\t\t      const value = meta._parsed[i];\n\t\t      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n\t\t        total += Math.abs(value);\n\t\t      }\n\t\t    }\n\t\t    return total;\n\t\t  }\n\t\t  calculateCircumference(value) {\n\t\t    const total = this._cachedMeta.total;\n\t\t    if (total > 0 && !isNaN(value)) {\n\t\t      return TAU * (Math.abs(value) / total);\n\t\t    }\n\t\t    return 0;\n\t\t  }\n\t\t  getLabelAndValue(index) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const chart = this.chart;\n\t\t    const labels = chart.data.labels || [];\n\t\t    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\t\t    return {\n\t\t      label: labels[index] || '',\n\t\t      value,\n\t\t    };\n\t\t  }\n\t\t  getMaxBorderWidth(arcs) {\n\t\t    let max = 0;\n\t\t    const chart = this.chart;\n\t\t    let i, ilen, meta, controller, options;\n\t\t    if (!arcs) {\n\t\t      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n\t\t        if (chart.isDatasetVisible(i)) {\n\t\t          meta = chart.getDatasetMeta(i);\n\t\t          arcs = meta.data;\n\t\t          controller = meta.controller;\n\t\t          break;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    if (!arcs) {\n\t\t      return 0;\n\t\t    }\n\t\t    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t      options = controller.resolveDataElementOptions(i);\n\t\t      if (options.borderAlign !== 'inner') {\n\t\t        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n\t\t      }\n\t\t    }\n\t\t    return max;\n\t\t  }\n\t\t  getMaxOffset(arcs) {\n\t\t    let max = 0;\n\t\t    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t      const options = this.resolveDataElementOptions(i);\n\t\t      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n\t\t    }\n\t\t    return max;\n\t\t  }\n\t\t  _getRingWeightOffset(datasetIndex) {\n\t\t    let ringWeightOffset = 0;\n\t\t    for (let i = 0; i < datasetIndex; ++i) {\n\t\t      if (this.chart.isDatasetVisible(i)) {\n\t\t        ringWeightOffset += this._getRingWeight(i);\n\t\t      }\n\t\t    }\n\t\t    return ringWeightOffset;\n\t\t  }\n\t\t  _getRingWeight(datasetIndex) {\n\t\t    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n\t\t  }\n\t\t  _getVisibleDatasetWeightTotal() {\n\t\t    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n\t\t  }\n\t\t}\n\t\tDoughnutController.id = 'doughnut';\n\t\tDoughnutController.defaults = {\n\t\t  datasetElementType: false,\n\t\t  dataElementType: 'arc',\n\t\t  animation: {\n\t\t    animateRotate: true,\n\t\t    animateScale: false\n\t\t  },\n\t\t  animations: {\n\t\t    numbers: {\n\t\t      type: 'number',\n\t\t      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n\t\t    },\n\t\t  },\n\t\t  cutout: '50%',\n\t\t  rotation: 0,\n\t\t  circumference: 360,\n\t\t  radius: '100%',\n\t\t  spacing: 0,\n\t\t  indexAxis: 'r',\n\t\t};\n\t\tDoughnutController.descriptors = {\n\t\t  _scriptable: (name) => name !== 'spacing',\n\t\t  _indexable: (name) => name !== 'spacing',\n\t\t};\n\t\tDoughnutController.overrides = {\n\t\t  aspectRatio: 1,\n\t\t  plugins: {\n\t\t    legend: {\n\t\t      labels: {\n\t\t        generateLabels(chart) {\n\t\t          const data = chart.data;\n\t\t          if (data.labels.length && data.datasets.length) {\n\t\t            const {labels: {pointStyle}} = chart.legend.options;\n\t\t            return data.labels.map((label, i) => {\n\t\t              const meta = chart.getDatasetMeta(0);\n\t\t              const style = meta.controller.getStyle(i);\n\t\t              return {\n\t\t                text: label,\n\t\t                fillStyle: style.backgroundColor,\n\t\t                strokeStyle: style.borderColor,\n\t\t                lineWidth: style.borderWidth,\n\t\t                pointStyle: pointStyle,\n\t\t                hidden: !chart.getDataVisibility(i),\n\t\t                index: i\n\t\t              };\n\t\t            });\n\t\t          }\n\t\t          return [];\n\t\t        }\n\t\t      },\n\t\t      onClick(e, legendItem, legend) {\n\t\t        legend.chart.toggleDataVisibility(legendItem.index);\n\t\t        legend.chart.update();\n\t\t      }\n\t\t    },\n\t\t    tooltip: {\n\t\t      callbacks: {\n\t\t        title() {\n\t\t          return '';\n\t\t        },\n\t\t        label(tooltipItem) {\n\t\t          let dataLabel = tooltipItem.label;\n\t\t          const value = ': ' + tooltipItem.formattedValue;\n\t\t          if (isArray(dataLabel)) {\n\t\t            dataLabel = dataLabel.slice();\n\t\t            dataLabel[0] += value;\n\t\t          } else {\n\t\t            dataLabel += value;\n\t\t          }\n\t\t          return dataLabel;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tclass LineController extends DatasetController {\n\t\t  initialize() {\n\t\t    this.enableOptionSharing = true;\n\t\t    super.initialize();\n\t\t  }\n\t\t  update(mode) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const {dataset: line, data: points = [], _dataset} = meta;\n\t\t    const animationsDisabled = this.chart._animationsDisabled;\n\t\t    let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\t\t    this._drawStart = start;\n\t\t    this._drawCount = count;\n\t\t    if (scaleRangesChanged(meta)) {\n\t\t      start = 0;\n\t\t      count = points.length;\n\t\t    }\n\t\t    line._chart = this.chart;\n\t\t    line._datasetIndex = this.index;\n\t\t    line._decimated = !!_dataset._decimated;\n\t\t    line.points = points;\n\t\t    const options = this.resolveDatasetElementOptions(mode);\n\t\t    if (!this.options.showLine) {\n\t\t      options.borderWidth = 0;\n\t\t    }\n\t\t    options.segment = this.options.segment;\n\t\t    this.updateElement(line, undefined, {\n\t\t      animated: !animationsDisabled,\n\t\t      options\n\t\t    }, mode);\n\t\t    this.updateElements(points, start, count, mode);\n\t\t  }\n\t\t  updateElements(points, start, count, mode) {\n\t\t    const reset = mode === 'reset';\n\t\t    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n\t\t    const firstOpts = this.resolveDataElementOptions(start, mode);\n\t\t    const sharedOptions = this.getSharedOptions(firstOpts);\n\t\t    const includeOptions = this.includeOptions(mode, sharedOptions);\n\t\t    const iAxis = iScale.axis;\n\t\t    const vAxis = vScale.axis;\n\t\t    const {spanGaps, segment} = this.options;\n\t\t    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n\t\t    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n\t\t    let prevParsed = start > 0 && this.getParsed(start - 1);\n\t\t    for (let i = start; i < start + count; ++i) {\n\t\t      const point = points[i];\n\t\t      const parsed = this.getParsed(i);\n\t\t      const properties = directUpdate ? point : {};\n\t\t      const nullData = isNullOrUndef(parsed[vAxis]);\n\t\t      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n\t\t      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\t\t      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n\t\t      properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n\t\t      if (segment) {\n\t\t        properties.parsed = parsed;\n\t\t        properties.raw = _dataset.data[i];\n\t\t      }\n\t\t      if (includeOptions) {\n\t\t        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\t\t      }\n\t\t      if (!directUpdate) {\n\t\t        this.updateElement(point, i, properties, mode);\n\t\t      }\n\t\t      prevParsed = parsed;\n\t\t    }\n\t\t    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t\t  }\n\t\t  getMaxOverflow() {\n\t\t    const meta = this._cachedMeta;\n\t\t    const dataset = meta.dataset;\n\t\t    const border = dataset.options && dataset.options.borderWidth || 0;\n\t\t    const data = meta.data || [];\n\t\t    if (!data.length) {\n\t\t      return border;\n\t\t    }\n\t\t    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n\t\t    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n\t\t    return Math.max(border, firstPoint, lastPoint) / 2;\n\t\t  }\n\t\t  draw() {\n\t\t    const meta = this._cachedMeta;\n\t\t    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n\t\t    super.draw();\n\t\t  }\n\t\t}\n\t\tLineController.id = 'line';\n\t\tLineController.defaults = {\n\t\t  datasetElementType: 'line',\n\t\t  dataElementType: 'point',\n\t\t  showLine: true,\n\t\t  spanGaps: false,\n\t\t};\n\t\tLineController.overrides = {\n\t\t  scales: {\n\t\t    _index_: {\n\t\t      type: 'category',\n\t\t    },\n\t\t    _value_: {\n\t\t      type: 'linear',\n\t\t    },\n\t\t  }\n\t\t};\n\t\tfunction getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n\t\t  const pointCount = points.length;\n\t\t  let start = 0;\n\t\t  let count = pointCount;\n\t\t  if (meta._sorted) {\n\t\t    const {iScale, _parsed} = meta;\n\t\t    const axis = iScale.axis;\n\t\t    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\t\t    if (minDefined) {\n\t\t      start = _limitValue(Math.min(\n\t\t        _lookupByKey(_parsed, iScale.axis, min).lo,\n\t\t        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n\t\t      0, pointCount - 1);\n\t\t    }\n\t\t    if (maxDefined) {\n\t\t      count = _limitValue(Math.max(\n\t\t        _lookupByKey(_parsed, iScale.axis, max).hi + 1,\n\t\t        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),\n\t\t      start, pointCount) - start;\n\t\t    } else {\n\t\t      count = pointCount - start;\n\t\t    }\n\t\t  }\n\t\t  return {start, count};\n\t\t}\n\t\tfunction scaleRangesChanged(meta) {\n\t\t  const {xScale, yScale, _scaleRanges} = meta;\n\t\t  const newRanges = {\n\t\t    xmin: xScale.min,\n\t\t    xmax: xScale.max,\n\t\t    ymin: yScale.min,\n\t\t    ymax: yScale.max\n\t\t  };\n\t\t  if (!_scaleRanges) {\n\t\t    meta._scaleRanges = newRanges;\n\t\t    return true;\n\t\t  }\n\t\t  const changed = _scaleRanges.xmin !== xScale.min\n\t\t\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t\t\t|| _scaleRanges.ymax !== yScale.max;\n\t\t  Object.assign(_scaleRanges, newRanges);\n\t\t  return changed;\n\t\t}\n\n\t\tclass PolarAreaController extends DatasetController {\n\t\t  constructor(chart, datasetIndex) {\n\t\t    super(chart, datasetIndex);\n\t\t    this.innerRadius = undefined;\n\t\t    this.outerRadius = undefined;\n\t\t  }\n\t\t  getLabelAndValue(index) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const chart = this.chart;\n\t\t    const labels = chart.data.labels || [];\n\t\t    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\t\t    return {\n\t\t      label: labels[index] || '',\n\t\t      value,\n\t\t    };\n\t\t  }\n\t\t  update(mode) {\n\t\t    const arcs = this._cachedMeta.data;\n\t\t    this._updateRadius();\n\t\t    this.updateElements(arcs, 0, arcs.length, mode);\n\t\t  }\n\t\t  _updateRadius() {\n\t\t    const chart = this.chart;\n\t\t    const chartArea = chart.chartArea;\n\t\t    const opts = chart.options;\n\t\t    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t    const outerRadius = Math.max(minSize / 2, 0);\n\t\t    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\t\t    this.outerRadius = outerRadius - (radiusLength * this.index);\n\t\t    this.innerRadius = this.outerRadius - radiusLength;\n\t\t  }\n\t\t  updateElements(arcs, start, count, mode) {\n\t\t    const reset = mode === 'reset';\n\t\t    const chart = this.chart;\n\t\t    const dataset = this.getDataset();\n\t\t    const opts = chart.options;\n\t\t    const animationOpts = opts.animation;\n\t\t    const scale = this._cachedMeta.rScale;\n\t\t    const centerX = scale.xCenter;\n\t\t    const centerY = scale.yCenter;\n\t\t    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n\t\t    let angle = datasetStartAngle;\n\t\t    let i;\n\t\t    const defaultAngle = 360 / this.countVisibleElements();\n\t\t    for (i = 0; i < start; ++i) {\n\t\t      angle += this._computeAngle(i, mode, defaultAngle);\n\t\t    }\n\t\t    for (i = start; i < start + count; i++) {\n\t\t      const arc = arcs[i];\n\t\t      let startAngle = angle;\n\t\t      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n\t\t      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\n\t\t      angle = endAngle;\n\t\t      if (reset) {\n\t\t        if (animationOpts.animateScale) {\n\t\t          outerRadius = 0;\n\t\t        }\n\t\t        if (animationOpts.animateRotate) {\n\t\t          startAngle = endAngle = datasetStartAngle;\n\t\t        }\n\t\t      }\n\t\t      const properties = {\n\t\t        x: centerX,\n\t\t        y: centerY,\n\t\t        innerRadius: 0,\n\t\t        outerRadius,\n\t\t        startAngle,\n\t\t        endAngle,\n\t\t        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n\t\t      };\n\t\t      this.updateElement(arc, i, properties, mode);\n\t\t    }\n\t\t  }\n\t\t  countVisibleElements() {\n\t\t    const dataset = this.getDataset();\n\t\t    const meta = this._cachedMeta;\n\t\t    let count = 0;\n\t\t    meta.data.forEach((element, index) => {\n\t\t      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\n\t\t        count++;\n\t\t      }\n\t\t    });\n\t\t    return count;\n\t\t  }\n\t\t  _computeAngle(index, mode, defaultAngle) {\n\t\t    return this.chart.getDataVisibility(index)\n\t\t      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n\t\t      : 0;\n\t\t  }\n\t\t}\n\t\tPolarAreaController.id = 'polarArea';\n\t\tPolarAreaController.defaults = {\n\t\t  dataElementType: 'arc',\n\t\t  animation: {\n\t\t    animateRotate: true,\n\t\t    animateScale: true\n\t\t  },\n\t\t  animations: {\n\t\t    numbers: {\n\t\t      type: 'number',\n\t\t      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n\t\t    },\n\t\t  },\n\t\t  indexAxis: 'r',\n\t\t  startAngle: 0,\n\t\t};\n\t\tPolarAreaController.overrides = {\n\t\t  aspectRatio: 1,\n\t\t  plugins: {\n\t\t    legend: {\n\t\t      labels: {\n\t\t        generateLabels(chart) {\n\t\t          const data = chart.data;\n\t\t          if (data.labels.length && data.datasets.length) {\n\t\t            const {labels: {pointStyle}} = chart.legend.options;\n\t\t            return data.labels.map((label, i) => {\n\t\t              const meta = chart.getDatasetMeta(0);\n\t\t              const style = meta.controller.getStyle(i);\n\t\t              return {\n\t\t                text: label,\n\t\t                fillStyle: style.backgroundColor,\n\t\t                strokeStyle: style.borderColor,\n\t\t                lineWidth: style.borderWidth,\n\t\t                pointStyle: pointStyle,\n\t\t                hidden: !chart.getDataVisibility(i),\n\t\t                index: i\n\t\t              };\n\t\t            });\n\t\t          }\n\t\t          return [];\n\t\t        }\n\t\t      },\n\t\t      onClick(e, legendItem, legend) {\n\t\t        legend.chart.toggleDataVisibility(legendItem.index);\n\t\t        legend.chart.update();\n\t\t      }\n\t\t    },\n\t\t    tooltip: {\n\t\t      callbacks: {\n\t\t        title() {\n\t\t          return '';\n\t\t        },\n\t\t        label(context) {\n\t\t          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  scales: {\n\t\t    r: {\n\t\t      type: 'radialLinear',\n\t\t      angleLines: {\n\t\t        display: false\n\t\t      },\n\t\t      beginAtZero: true,\n\t\t      grid: {\n\t\t        circular: true\n\t\t      },\n\t\t      pointLabels: {\n\t\t        display: false\n\t\t      },\n\t\t      startAngle: 0\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tclass PieController extends DoughnutController {\n\t\t}\n\t\tPieController.id = 'pie';\n\t\tPieController.defaults = {\n\t\t  cutout: 0,\n\t\t  rotation: 0,\n\t\t  circumference: 360,\n\t\t  radius: '100%'\n\t\t};\n\n\t\tclass RadarController extends DatasetController {\n\t\t  getLabelAndValue(index) {\n\t\t    const vScale = this._cachedMeta.vScale;\n\t\t    const parsed = this.getParsed(index);\n\t\t    return {\n\t\t      label: vScale.getLabels()[index],\n\t\t      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n\t\t    };\n\t\t  }\n\t\t  update(mode) {\n\t\t    const meta = this._cachedMeta;\n\t\t    const line = meta.dataset;\n\t\t    const points = meta.data || [];\n\t\t    const labels = meta.iScale.getLabels();\n\t\t    line.points = points;\n\t\t    if (mode !== 'resize') {\n\t\t      const options = this.resolveDatasetElementOptions(mode);\n\t\t      if (!this.options.showLine) {\n\t\t        options.borderWidth = 0;\n\t\t      }\n\t\t      const properties = {\n\t\t        _loop: true,\n\t\t        _fullLoop: labels.length === points.length,\n\t\t        options\n\t\t      };\n\t\t      this.updateElement(line, undefined, properties, mode);\n\t\t    }\n\t\t    this.updateElements(points, 0, points.length, mode);\n\t\t  }\n\t\t  updateElements(points, start, count, mode) {\n\t\t    const dataset = this.getDataset();\n\t\t    const scale = this._cachedMeta.rScale;\n\t\t    const reset = mode === 'reset';\n\t\t    for (let i = start; i < start + count; i++) {\n\t\t      const point = points[i];\n\t\t      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\t\t      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\n\t\t      const x = reset ? scale.xCenter : pointPosition.x;\n\t\t      const y = reset ? scale.yCenter : pointPosition.y;\n\t\t      const properties = {\n\t\t        x,\n\t\t        y,\n\t\t        angle: pointPosition.angle,\n\t\t        skip: isNaN(x) || isNaN(y),\n\t\t        options\n\t\t      };\n\t\t      this.updateElement(point, i, properties, mode);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tRadarController.id = 'radar';\n\t\tRadarController.defaults = {\n\t\t  datasetElementType: 'line',\n\t\t  dataElementType: 'point',\n\t\t  indexAxis: 'r',\n\t\t  showLine: true,\n\t\t  elements: {\n\t\t    line: {\n\t\t      fill: 'start'\n\t\t    }\n\t\t  },\n\t\t};\n\t\tRadarController.overrides = {\n\t\t  aspectRatio: 1,\n\t\t  scales: {\n\t\t    r: {\n\t\t      type: 'radialLinear',\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tclass ScatterController extends LineController {\n\t\t}\n\t\tScatterController.id = 'scatter';\n\t\tScatterController.defaults = {\n\t\t  showLine: false,\n\t\t  fill: false\n\t\t};\n\t\tScatterController.overrides = {\n\t\t  interaction: {\n\t\t    mode: 'point'\n\t\t  },\n\t\t  plugins: {\n\t\t    tooltip: {\n\t\t      callbacks: {\n\t\t        title() {\n\t\t          return '';\n\t\t        },\n\t\t        label(item) {\n\t\t          return '(' + item.label + ', ' + item.formattedValue + ')';\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  scales: {\n\t\t    x: {\n\t\t      type: 'linear'\n\t\t    },\n\t\t    y: {\n\t\t      type: 'linear'\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tvar controllers = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tBarController: BarController,\n\t\tBubbleController: BubbleController,\n\t\tDoughnutController: DoughnutController,\n\t\tLineController: LineController,\n\t\tPolarAreaController: PolarAreaController,\n\t\tPieController: PieController,\n\t\tRadarController: RadarController,\n\t\tScatterController: ScatterController\n\t\t});\n\n\t\tfunction clipArc(ctx, element, endAngle) {\n\t\t  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n\t\t  let angleMargin = pixelMargin / outerRadius;\n\t\t  ctx.beginPath();\n\t\t  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n\t\t  if (innerRadius > pixelMargin) {\n\t\t    angleMargin = pixelMargin / innerRadius;\n\t\t    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n\t\t  } else {\n\t\t    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n\t\t  }\n\t\t  ctx.closePath();\n\t\t  ctx.clip();\n\t\t}\n\t\tfunction toRadiusCorners(value) {\n\t\t  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n\t\t}\n\t\tfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n\t\t  const o = toRadiusCorners(arc.options.borderRadius);\n\t\t  const halfThickness = (outerRadius - innerRadius) / 2;\n\t\t  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\t\t  const computeOuterLimit = (val) => {\n\t\t    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n\t\t    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n\t\t  };\n\t\t  return {\n\t\t    outerStart: computeOuterLimit(o.outerStart),\n\t\t    outerEnd: computeOuterLimit(o.outerEnd),\n\t\t    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n\t\t    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n\t\t  };\n\t\t}\n\t\tfunction rThetaToXY(r, theta, x, y) {\n\t\t  return {\n\t\t    x: x + r * Math.cos(theta),\n\t\t    y: y + r * Math.sin(theta),\n\t\t  };\n\t\t}\n\t\tfunction pathArc(ctx, element, offset, spacing, end) {\n\t\t  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\t\t  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n\t\t  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\t\t  let spacingOffset = 0;\n\t\t  const alpha = end - start;\n\t\t  if (spacing) {\n\t\t    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n\t\t    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n\t\t    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n\t\t    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n\t\t    spacingOffset = (alpha - adjustedAngle) / 2;\n\t\t  }\n\t\t  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n\t\t  const angleOffset = (alpha - beta) / 2;\n\t\t  const startAngle = start + angleOffset + spacingOffset;\n\t\t  const endAngle = end - angleOffset - spacingOffset;\n\t\t  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n\t\t  const outerStartAdjustedRadius = outerRadius - outerStart;\n\t\t  const outerEndAdjustedRadius = outerRadius - outerEnd;\n\t\t  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n\t\t  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\t\t  const innerStartAdjustedRadius = innerRadius + innerStart;\n\t\t  const innerEndAdjustedRadius = innerRadius + innerEnd;\n\t\t  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n\t\t  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\t\t  ctx.beginPath();\n\t\t  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n\t\t  if (outerEnd > 0) {\n\t\t    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n\t\t    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n\t\t  }\n\t\t  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n\t\t  ctx.lineTo(p4.x, p4.y);\n\t\t  if (innerEnd > 0) {\n\t\t    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n\t\t    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n\t\t  }\n\t\t  ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n\t\t  if (innerStart > 0) {\n\t\t    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n\t\t    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n\t\t  }\n\t\t  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n\t\t  ctx.lineTo(p8.x, p8.y);\n\t\t  if (outerStart > 0) {\n\t\t    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n\t\t    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n\t\t  }\n\t\t  ctx.closePath();\n\t\t}\n\t\tfunction drawArc(ctx, element, offset, spacing) {\n\t\t  const {fullCircles, startAngle, circumference} = element;\n\t\t  let endAngle = element.endAngle;\n\t\t  if (fullCircles) {\n\t\t    pathArc(ctx, element, offset, spacing, startAngle + TAU);\n\t\t    for (let i = 0; i < fullCircles; ++i) {\n\t\t      ctx.fill();\n\t\t    }\n\t\t    if (!isNaN(circumference)) {\n\t\t      endAngle = startAngle + circumference % TAU;\n\t\t      if (circumference % TAU === 0) {\n\t\t        endAngle += TAU;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  pathArc(ctx, element, offset, spacing, endAngle);\n\t\t  ctx.fill();\n\t\t  return endAngle;\n\t\t}\n\t\tfunction drawFullCircleBorders(ctx, element, inner) {\n\t\t  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n\t\t  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n\t\t  const innerRadius = element.innerRadius + pixelMargin;\n\t\t  let i;\n\t\t  if (inner) {\n\t\t    clipArc(ctx, element, startAngle + TAU);\n\t\t  }\n\t\t  ctx.beginPath();\n\t\t  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n\t\t  for (i = 0; i < fullCircles; ++i) {\n\t\t    ctx.stroke();\n\t\t  }\n\t\t  ctx.beginPath();\n\t\t  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n\t\t  for (i = 0; i < fullCircles; ++i) {\n\t\t    ctx.stroke();\n\t\t  }\n\t\t}\n\t\tfunction drawBorder(ctx, element, offset, spacing, endAngle) {\n\t\t  const {options} = element;\n\t\t  const {borderWidth, borderJoinStyle} = options;\n\t\t  const inner = options.borderAlign === 'inner';\n\t\t  if (!borderWidth) {\n\t\t    return;\n\t\t  }\n\t\t  if (inner) {\n\t\t    ctx.lineWidth = borderWidth * 2;\n\t\t    ctx.lineJoin = borderJoinStyle || 'round';\n\t\t  } else {\n\t\t    ctx.lineWidth = borderWidth;\n\t\t    ctx.lineJoin = borderJoinStyle || 'bevel';\n\t\t  }\n\t\t  if (element.fullCircles) {\n\t\t    drawFullCircleBorders(ctx, element, inner);\n\t\t  }\n\t\t  if (inner) {\n\t\t    clipArc(ctx, element, endAngle);\n\t\t  }\n\t\t  pathArc(ctx, element, offset, spacing, endAngle);\n\t\t  ctx.stroke();\n\t\t}\n\t\tclass ArcElement extends Element {\n\t\t  constructor(cfg) {\n\t\t    super();\n\t\t    this.options = undefined;\n\t\t    this.circumference = undefined;\n\t\t    this.startAngle = undefined;\n\t\t    this.endAngle = undefined;\n\t\t    this.innerRadius = undefined;\n\t\t    this.outerRadius = undefined;\n\t\t    this.pixelMargin = 0;\n\t\t    this.fullCircles = 0;\n\t\t    if (cfg) {\n\t\t      Object.assign(this, cfg);\n\t\t    }\n\t\t  }\n\t\t  inRange(chartX, chartY, useFinalPosition) {\n\t\t    const point = this.getProps(['x', 'y'], useFinalPosition);\n\t\t    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n\t\t    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n\t\t      'startAngle',\n\t\t      'endAngle',\n\t\t      'innerRadius',\n\t\t      'outerRadius',\n\t\t      'circumference'\n\t\t    ], useFinalPosition);\n\t\t    const rAdjust = this.options.spacing / 2;\n\t\t    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n\t\t    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n\t\t    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\t\t    return (betweenAngles && withinRadius);\n\t\t  }\n\t\t  getCenterPoint(useFinalPosition) {\n\t\t    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n\t\t      'x',\n\t\t      'y',\n\t\t      'startAngle',\n\t\t      'endAngle',\n\t\t      'innerRadius',\n\t\t      'outerRadius',\n\t\t      'circumference',\n\t\t    ], useFinalPosition);\n\t\t    const {offset, spacing} = this.options;\n\t\t    const halfAngle = (startAngle + endAngle) / 2;\n\t\t    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n\t\t    return {\n\t\t      x: x + Math.cos(halfAngle) * halfRadius,\n\t\t      y: y + Math.sin(halfAngle) * halfRadius\n\t\t    };\n\t\t  }\n\t\t  tooltipPosition(useFinalPosition) {\n\t\t    return this.getCenterPoint(useFinalPosition);\n\t\t  }\n\t\t  draw(ctx) {\n\t\t    const {options, circumference} = this;\n\t\t    const offset = (options.offset || 0) / 2;\n\t\t    const spacing = (options.spacing || 0) / 2;\n\t\t    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n\t\t    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\t\t    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n\t\t      return;\n\t\t    }\n\t\t    ctx.save();\n\t\t    let radiusOffset = 0;\n\t\t    if (offset) {\n\t\t      radiusOffset = offset / 2;\n\t\t      const halfAngle = (this.startAngle + this.endAngle) / 2;\n\t\t      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n\t\t      if (this.circumference >= PI) {\n\t\t        radiusOffset = offset;\n\t\t      }\n\t\t    }\n\t\t    ctx.fillStyle = options.backgroundColor;\n\t\t    ctx.strokeStyle = options.borderColor;\n\t\t    const endAngle = drawArc(ctx, this, radiusOffset, spacing);\n\t\t    drawBorder(ctx, this, radiusOffset, spacing, endAngle);\n\t\t    ctx.restore();\n\t\t  }\n\t\t}\n\t\tArcElement.id = 'arc';\n\t\tArcElement.defaults = {\n\t\t  borderAlign: 'center',\n\t\t  borderColor: '#fff',\n\t\t  borderJoinStyle: undefined,\n\t\t  borderRadius: 0,\n\t\t  borderWidth: 2,\n\t\t  offset: 0,\n\t\t  spacing: 0,\n\t\t  angle: undefined,\n\t\t};\n\t\tArcElement.defaultRoutes = {\n\t\t  backgroundColor: 'backgroundColor'\n\t\t};\n\n\t\tfunction setStyle(ctx, options, style = options) {\n\t\t  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n\t\t  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n\t\t  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n\t\t  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n\t\t  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n\t\t  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n\t\t}\n\t\tfunction lineTo(ctx, previous, target) {\n\t\t  ctx.lineTo(target.x, target.y);\n\t\t}\n\t\tfunction getLineMethod(options) {\n\t\t  if (options.stepped) {\n\t\t    return _steppedLineTo;\n\t\t  }\n\t\t  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n\t\t    return _bezierCurveTo;\n\t\t  }\n\t\t  return lineTo;\n\t\t}\n\t\tfunction pathVars(points, segment, params = {}) {\n\t\t  const count = points.length;\n\t\t  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n\t\t  const {start: segmentStart, end: segmentEnd} = segment;\n\t\t  const start = Math.max(paramsStart, segmentStart);\n\t\t  const end = Math.min(paramsEnd, segmentEnd);\n\t\t  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\t\t  return {\n\t\t    count,\n\t\t    start,\n\t\t    loop: segment.loop,\n\t\t    ilen: end < start && !outside ? count + end - start : end - start\n\t\t  };\n\t\t}\n\t\tfunction pathSegment(ctx, line, segment, params) {\n\t\t  const {points, options} = line;\n\t\t  const {count, start, loop, ilen} = pathVars(points, segment, params);\n\t\t  const lineMethod = getLineMethod(options);\n\t\t  let {move = true, reverse} = params || {};\n\t\t  let i, point, prev;\n\t\t  for (i = 0; i <= ilen; ++i) {\n\t\t    point = points[(start + (reverse ? ilen - i : i)) % count];\n\t\t    if (point.skip) {\n\t\t      continue;\n\t\t    } else if (move) {\n\t\t      ctx.moveTo(point.x, point.y);\n\t\t      move = false;\n\t\t    } else {\n\t\t      lineMethod(ctx, prev, point, reverse, options.stepped);\n\t\t    }\n\t\t    prev = point;\n\t\t  }\n\t\t  if (loop) {\n\t\t    point = points[(start + (reverse ? ilen : 0)) % count];\n\t\t    lineMethod(ctx, prev, point, reverse, options.stepped);\n\t\t  }\n\t\t  return !!loop;\n\t\t}\n\t\tfunction fastPathSegment(ctx, line, segment, params) {\n\t\t  const points = line.points;\n\t\t  const {count, start, ilen} = pathVars(points, segment, params);\n\t\t  const {move = true, reverse} = params || {};\n\t\t  let avgX = 0;\n\t\t  let countX = 0;\n\t\t  let i, point, prevX, minY, maxY, lastY;\n\t\t  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n\t\t  const drawX = () => {\n\t\t    if (minY !== maxY) {\n\t\t      ctx.lineTo(avgX, maxY);\n\t\t      ctx.lineTo(avgX, minY);\n\t\t      ctx.lineTo(avgX, lastY);\n\t\t    }\n\t\t  };\n\t\t  if (move) {\n\t\t    point = points[pointIndex(0)];\n\t\t    ctx.moveTo(point.x, point.y);\n\t\t  }\n\t\t  for (i = 0; i <= ilen; ++i) {\n\t\t    point = points[pointIndex(i)];\n\t\t    if (point.skip) {\n\t\t      continue;\n\t\t    }\n\t\t    const x = point.x;\n\t\t    const y = point.y;\n\t\t    const truncX = x | 0;\n\t\t    if (truncX === prevX) {\n\t\t      if (y < minY) {\n\t\t        minY = y;\n\t\t      } else if (y > maxY) {\n\t\t        maxY = y;\n\t\t      }\n\t\t      avgX = (countX * avgX + x) / ++countX;\n\t\t    } else {\n\t\t      drawX();\n\t\t      ctx.lineTo(x, y);\n\t\t      prevX = truncX;\n\t\t      countX = 0;\n\t\t      minY = maxY = y;\n\t\t    }\n\t\t    lastY = y;\n\t\t  }\n\t\t  drawX();\n\t\t}\n\t\tfunction _getSegmentMethod(line) {\n\t\t  const opts = line.options;\n\t\t  const borderDash = opts.borderDash && opts.borderDash.length;\n\t\t  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n\t\t  return useFastPath ? fastPathSegment : pathSegment;\n\t\t}\n\t\tfunction _getInterpolationMethod(options) {\n\t\t  if (options.stepped) {\n\t\t    return _steppedInterpolation;\n\t\t  }\n\t\t  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n\t\t    return _bezierInterpolation;\n\t\t  }\n\t\t  return _pointInLine;\n\t\t}\n\t\tfunction strokePathWithCache(ctx, line, start, count) {\n\t\t  let path = line._path;\n\t\t  if (!path) {\n\t\t    path = line._path = new Path2D();\n\t\t    if (line.path(path, start, count)) {\n\t\t      path.closePath();\n\t\t    }\n\t\t  }\n\t\t  setStyle(ctx, line.options);\n\t\t  ctx.stroke(path);\n\t\t}\n\t\tfunction strokePathDirect(ctx, line, start, count) {\n\t\t  const {segments, options} = line;\n\t\t  const segmentMethod = _getSegmentMethod(line);\n\t\t  for (const segment of segments) {\n\t\t    setStyle(ctx, options, segment.style);\n\t\t    ctx.beginPath();\n\t\t    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n\t\t      ctx.closePath();\n\t\t    }\n\t\t    ctx.stroke();\n\t\t  }\n\t\t}\n\t\tconst usePath2D = typeof Path2D === 'function';\n\t\tfunction draw(ctx, line, start, count) {\n\t\t  if (usePath2D && !line.options.segment) {\n\t\t    strokePathWithCache(ctx, line, start, count);\n\t\t  } else {\n\t\t    strokePathDirect(ctx, line, start, count);\n\t\t  }\n\t\t}\n\t\tclass LineElement extends Element {\n\t\t  constructor(cfg) {\n\t\t    super();\n\t\t    this.animated = true;\n\t\t    this.options = undefined;\n\t\t    this._chart = undefined;\n\t\t    this._loop = undefined;\n\t\t    this._fullLoop = undefined;\n\t\t    this._path = undefined;\n\t\t    this._points = undefined;\n\t\t    this._segments = undefined;\n\t\t    this._decimated = false;\n\t\t    this._pointsUpdated = false;\n\t\t    this._datasetIndex = undefined;\n\t\t    if (cfg) {\n\t\t      Object.assign(this, cfg);\n\t\t    }\n\t\t  }\n\t\t  updateControlPoints(chartArea, indexAxis) {\n\t\t    const options = this.options;\n\t\t    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n\t\t      const loop = options.spanGaps ? this._loop : this._fullLoop;\n\t\t      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n\t\t      this._pointsUpdated = true;\n\t\t    }\n\t\t  }\n\t\t  set points(points) {\n\t\t    this._points = points;\n\t\t    delete this._segments;\n\t\t    delete this._path;\n\t\t    this._pointsUpdated = false;\n\t\t  }\n\t\t  get points() {\n\t\t    return this._points;\n\t\t  }\n\t\t  get segments() {\n\t\t    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n\t\t  }\n\t\t  first() {\n\t\t    const segments = this.segments;\n\t\t    const points = this.points;\n\t\t    return segments.length && points[segments[0].start];\n\t\t  }\n\t\t  last() {\n\t\t    const segments = this.segments;\n\t\t    const points = this.points;\n\t\t    const count = segments.length;\n\t\t    return count && points[segments[count - 1].end];\n\t\t  }\n\t\t  interpolate(point, property) {\n\t\t    const options = this.options;\n\t\t    const value = point[property];\n\t\t    const points = this.points;\n\t\t    const segments = _boundSegments(this, {property, start: value, end: value});\n\t\t    if (!segments.length) {\n\t\t      return;\n\t\t    }\n\t\t    const result = [];\n\t\t    const _interpolate = _getInterpolationMethod(options);\n\t\t    let i, ilen;\n\t\t    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n\t\t      const {start, end} = segments[i];\n\t\t      const p1 = points[start];\n\t\t      const p2 = points[end];\n\t\t      if (p1 === p2) {\n\t\t        result.push(p1);\n\t\t        continue;\n\t\t      }\n\t\t      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n\t\t      const interpolated = _interpolate(p1, p2, t, options.stepped);\n\t\t      interpolated[property] = point[property];\n\t\t      result.push(interpolated);\n\t\t    }\n\t\t    return result.length === 1 ? result[0] : result;\n\t\t  }\n\t\t  pathSegment(ctx, segment, params) {\n\t\t    const segmentMethod = _getSegmentMethod(this);\n\t\t    return segmentMethod(ctx, this, segment, params);\n\t\t  }\n\t\t  path(ctx, start, count) {\n\t\t    const segments = this.segments;\n\t\t    const segmentMethod = _getSegmentMethod(this);\n\t\t    let loop = this._loop;\n\t\t    start = start || 0;\n\t\t    count = count || (this.points.length - start);\n\t\t    for (const segment of segments) {\n\t\t      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n\t\t    }\n\t\t    return !!loop;\n\t\t  }\n\t\t  draw(ctx, chartArea, start, count) {\n\t\t    const options = this.options || {};\n\t\t    const points = this.points || [];\n\t\t    if (points.length && options.borderWidth) {\n\t\t      ctx.save();\n\t\t      draw(ctx, this, start, count);\n\t\t      ctx.restore();\n\t\t    }\n\t\t    if (this.animated) {\n\t\t      this._pointsUpdated = false;\n\t\t      this._path = undefined;\n\t\t    }\n\t\t  }\n\t\t}\n\t\tLineElement.id = 'line';\n\t\tLineElement.defaults = {\n\t\t  borderCapStyle: 'butt',\n\t\t  borderDash: [],\n\t\t  borderDashOffset: 0,\n\t\t  borderJoinStyle: 'miter',\n\t\t  borderWidth: 3,\n\t\t  capBezierPoints: true,\n\t\t  cubicInterpolationMode: 'default',\n\t\t  fill: false,\n\t\t  spanGaps: false,\n\t\t  stepped: false,\n\t\t  tension: 0,\n\t\t};\n\t\tLineElement.defaultRoutes = {\n\t\t  backgroundColor: 'backgroundColor',\n\t\t  borderColor: 'borderColor'\n\t\t};\n\t\tLineElement.descriptors = {\n\t\t  _scriptable: true,\n\t\t  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n\t\t};\n\n\t\tfunction inRange$1(el, pos, axis, useFinalPosition) {\n\t\t  const options = el.options;\n\t\t  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\t\t  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n\t\t}\n\t\tclass PointElement extends Element {\n\t\t  constructor(cfg) {\n\t\t    super();\n\t\t    this.options = undefined;\n\t\t    this.parsed = undefined;\n\t\t    this.skip = undefined;\n\t\t    this.stop = undefined;\n\t\t    if (cfg) {\n\t\t      Object.assign(this, cfg);\n\t\t    }\n\t\t  }\n\t\t  inRange(mouseX, mouseY, useFinalPosition) {\n\t\t    const options = this.options;\n\t\t    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n\t\t    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n\t\t  }\n\t\t  inXRange(mouseX, useFinalPosition) {\n\t\t    return inRange$1(this, mouseX, 'x', useFinalPosition);\n\t\t  }\n\t\t  inYRange(mouseY, useFinalPosition) {\n\t\t    return inRange$1(this, mouseY, 'y', useFinalPosition);\n\t\t  }\n\t\t  getCenterPoint(useFinalPosition) {\n\t\t    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n\t\t    return {x, y};\n\t\t  }\n\t\t  size(options) {\n\t\t    options = options || this.options || {};\n\t\t    let radius = options.radius || 0;\n\t\t    radius = Math.max(radius, radius && options.hoverRadius || 0);\n\t\t    const borderWidth = radius && options.borderWidth || 0;\n\t\t    return (radius + borderWidth) * 2;\n\t\t  }\n\t\t  draw(ctx, area) {\n\t\t    const options = this.options;\n\t\t    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n\t\t      return;\n\t\t    }\n\t\t    ctx.strokeStyle = options.borderColor;\n\t\t    ctx.lineWidth = options.borderWidth;\n\t\t    ctx.fillStyle = options.backgroundColor;\n\t\t    drawPoint(ctx, options, this.x, this.y);\n\t\t  }\n\t\t  getRange() {\n\t\t    const options = this.options || {};\n\t\t    return options.radius + options.hitRadius;\n\t\t  }\n\t\t}\n\t\tPointElement.id = 'point';\n\t\tPointElement.defaults = {\n\t\t  borderWidth: 1,\n\t\t  hitRadius: 1,\n\t\t  hoverBorderWidth: 1,\n\t\t  hoverRadius: 4,\n\t\t  pointStyle: 'circle',\n\t\t  radius: 3,\n\t\t  rotation: 0\n\t\t};\n\t\tPointElement.defaultRoutes = {\n\t\t  backgroundColor: 'backgroundColor',\n\t\t  borderColor: 'borderColor'\n\t\t};\n\n\t\tfunction getBarBounds(bar, useFinalPosition) {\n\t\t  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n\t\t  let left, right, top, bottom, half;\n\t\t  if (bar.horizontal) {\n\t\t    half = height / 2;\n\t\t    left = Math.min(x, base);\n\t\t    right = Math.max(x, base);\n\t\t    top = y - half;\n\t\t    bottom = y + half;\n\t\t  } else {\n\t\t    half = width / 2;\n\t\t    left = x - half;\n\t\t    right = x + half;\n\t\t    top = Math.min(y, base);\n\t\t    bottom = Math.max(y, base);\n\t\t  }\n\t\t  return {left, top, right, bottom};\n\t\t}\n\t\tfunction skipOrLimit(skip, value, min, max) {\n\t\t  return skip ? 0 : _limitValue(value, min, max);\n\t\t}\n\t\tfunction parseBorderWidth(bar, maxW, maxH) {\n\t\t  const value = bar.options.borderWidth;\n\t\t  const skip = bar.borderSkipped;\n\t\t  const o = toTRBL(value);\n\t\t  return {\n\t\t    t: skipOrLimit(skip.top, o.top, 0, maxH),\n\t\t    r: skipOrLimit(skip.right, o.right, 0, maxW),\n\t\t    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n\t\t    l: skipOrLimit(skip.left, o.left, 0, maxW)\n\t\t  };\n\t\t}\n\t\tfunction parseBorderRadius(bar, maxW, maxH) {\n\t\t  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n\t\t  const value = bar.options.borderRadius;\n\t\t  const o = toTRBLCorners(value);\n\t\t  const maxR = Math.min(maxW, maxH);\n\t\t  const skip = bar.borderSkipped;\n\t\t  const enableBorder = enableBorderRadius || isObject(value);\n\t\t  return {\n\t\t    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n\t\t    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n\t\t    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n\t\t    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n\t\t  };\n\t\t}\n\t\tfunction boundingRects(bar) {\n\t\t  const bounds = getBarBounds(bar);\n\t\t  const width = bounds.right - bounds.left;\n\t\t  const height = bounds.bottom - bounds.top;\n\t\t  const border = parseBorderWidth(bar, width / 2, height / 2);\n\t\t  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\t\t  return {\n\t\t    outer: {\n\t\t      x: bounds.left,\n\t\t      y: bounds.top,\n\t\t      w: width,\n\t\t      h: height,\n\t\t      radius\n\t\t    },\n\t\t    inner: {\n\t\t      x: bounds.left + border.l,\n\t\t      y: bounds.top + border.t,\n\t\t      w: width - border.l - border.r,\n\t\t      h: height - border.t - border.b,\n\t\t      radius: {\n\t\t        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n\t\t        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n\t\t        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n\t\t        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t}\n\t\tfunction inRange(bar, x, y, useFinalPosition) {\n\t\t  const skipX = x === null;\n\t\t  const skipY = y === null;\n\t\t  const skipBoth = skipX && skipY;\n\t\t  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\t\t  return bounds\n\t\t\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n\t\t}\n\t\tfunction hasRadius(radius) {\n\t\t  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n\t\t}\n\t\tfunction addNormalRectPath(ctx, rect) {\n\t\t  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n\t\t}\n\t\tfunction inflateRect(rect, amount, refRect = {}) {\n\t\t  const x = rect.x !== refRect.x ? -amount : 0;\n\t\t  const y = rect.y !== refRect.y ? -amount : 0;\n\t\t  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n\t\t  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n\t\t  return {\n\t\t    x: rect.x + x,\n\t\t    y: rect.y + y,\n\t\t    w: rect.w + w,\n\t\t    h: rect.h + h,\n\t\t    radius: rect.radius\n\t\t  };\n\t\t}\n\t\tclass BarElement extends Element {\n\t\t  constructor(cfg) {\n\t\t    super();\n\t\t    this.options = undefined;\n\t\t    this.horizontal = undefined;\n\t\t    this.base = undefined;\n\t\t    this.width = undefined;\n\t\t    this.height = undefined;\n\t\t    this.inflateAmount = undefined;\n\t\t    if (cfg) {\n\t\t      Object.assign(this, cfg);\n\t\t    }\n\t\t  }\n\t\t  draw(ctx) {\n\t\t    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n\t\t    const {inner, outer} = boundingRects(this);\n\t\t    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\t\t    ctx.save();\n\t\t    if (outer.w !== inner.w || outer.h !== inner.h) {\n\t\t      ctx.beginPath();\n\t\t      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n\t\t      ctx.clip();\n\t\t      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n\t\t      ctx.fillStyle = borderColor;\n\t\t      ctx.fill('evenodd');\n\t\t    }\n\t\t    ctx.beginPath();\n\t\t    addRectPath(ctx, inflateRect(inner, inflateAmount));\n\t\t    ctx.fillStyle = backgroundColor;\n\t\t    ctx.fill();\n\t\t    ctx.restore();\n\t\t  }\n\t\t  inRange(mouseX, mouseY, useFinalPosition) {\n\t\t    return inRange(this, mouseX, mouseY, useFinalPosition);\n\t\t  }\n\t\t  inXRange(mouseX, useFinalPosition) {\n\t\t    return inRange(this, mouseX, null, useFinalPosition);\n\t\t  }\n\t\t  inYRange(mouseY, useFinalPosition) {\n\t\t    return inRange(this, null, mouseY, useFinalPosition);\n\t\t  }\n\t\t  getCenterPoint(useFinalPosition) {\n\t\t    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n\t\t    return {\n\t\t      x: horizontal ? (x + base) / 2 : x,\n\t\t      y: horizontal ? y : (y + base) / 2\n\t\t    };\n\t\t  }\n\t\t  getRange(axis) {\n\t\t    return axis === 'x' ? this.width / 2 : this.height / 2;\n\t\t  }\n\t\t}\n\t\tBarElement.id = 'bar';\n\t\tBarElement.defaults = {\n\t\t  borderSkipped: 'start',\n\t\t  borderWidth: 0,\n\t\t  borderRadius: 0,\n\t\t  inflateAmount: 'auto',\n\t\t  pointStyle: undefined\n\t\t};\n\t\tBarElement.defaultRoutes = {\n\t\t  backgroundColor: 'backgroundColor',\n\t\t  borderColor: 'borderColor'\n\t\t};\n\n\t\tvar elements = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tArcElement: ArcElement,\n\t\tLineElement: LineElement,\n\t\tPointElement: PointElement,\n\t\tBarElement: BarElement\n\t\t});\n\n\t\tfunction lttbDecimation(data, start, count, availableWidth, options) {\n\t\t  const samples = options.samples || availableWidth;\n\t\t  if (samples >= count) {\n\t\t    return data.slice(start, start + count);\n\t\t  }\n\t\t  const decimated = [];\n\t\t  const bucketWidth = (count - 2) / (samples - 2);\n\t\t  let sampledIndex = 0;\n\t\t  const endIndex = start + count - 1;\n\t\t  let a = start;\n\t\t  let i, maxAreaPoint, maxArea, area, nextA;\n\t\t  decimated[sampledIndex++] = data[a];\n\t\t  for (i = 0; i < samples - 2; i++) {\n\t\t    let avgX = 0;\n\t\t    let avgY = 0;\n\t\t    let j;\n\t\t    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n\t\t    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n\t\t    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\t\t    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n\t\t      avgX += data[j].x;\n\t\t      avgY += data[j].y;\n\t\t    }\n\t\t    avgX /= avgRangeLength;\n\t\t    avgY /= avgRangeLength;\n\t\t    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n\t\t    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n\t\t    const {x: pointAx, y: pointAy} = data[a];\n\t\t    maxArea = area = -1;\n\t\t    for (j = rangeOffs; j < rangeTo; j++) {\n\t\t      area = 0.5 * Math.abs(\n\t\t        (pointAx - avgX) * (data[j].y - pointAy) -\n\t\t        (pointAx - data[j].x) * (avgY - pointAy)\n\t\t      );\n\t\t      if (area > maxArea) {\n\t\t        maxArea = area;\n\t\t        maxAreaPoint = data[j];\n\t\t        nextA = j;\n\t\t      }\n\t\t    }\n\t\t    decimated[sampledIndex++] = maxAreaPoint;\n\t\t    a = nextA;\n\t\t  }\n\t\t  decimated[sampledIndex++] = data[endIndex];\n\t\t  return decimated;\n\t\t}\n\t\tfunction minMaxDecimation(data, start, count, availableWidth) {\n\t\t  let avgX = 0;\n\t\t  let countX = 0;\n\t\t  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n\t\t  const decimated = [];\n\t\t  const endIndex = start + count - 1;\n\t\t  const xMin = data[start].x;\n\t\t  const xMax = data[endIndex].x;\n\t\t  const dx = xMax - xMin;\n\t\t  for (i = start; i < start + count; ++i) {\n\t\t    point = data[i];\n\t\t    x = (point.x - xMin) / dx * availableWidth;\n\t\t    y = point.y;\n\t\t    const truncX = x | 0;\n\t\t    if (truncX === prevX) {\n\t\t      if (y < minY) {\n\t\t        minY = y;\n\t\t        minIndex = i;\n\t\t      } else if (y > maxY) {\n\t\t        maxY = y;\n\t\t        maxIndex = i;\n\t\t      }\n\t\t      avgX = (countX * avgX + point.x) / ++countX;\n\t\t    } else {\n\t\t      const lastIndex = i - 1;\n\t\t      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n\t\t        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n\t\t        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\t\t        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n\t\t          decimated.push({\n\t\t            ...data[intermediateIndex1],\n\t\t            x: avgX,\n\t\t          });\n\t\t        }\n\t\t        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n\t\t          decimated.push({\n\t\t            ...data[intermediateIndex2],\n\t\t            x: avgX\n\t\t          });\n\t\t        }\n\t\t      }\n\t\t      if (i > 0 && lastIndex !== startIndex) {\n\t\t        decimated.push(data[lastIndex]);\n\t\t      }\n\t\t      decimated.push(point);\n\t\t      prevX = truncX;\n\t\t      countX = 0;\n\t\t      minY = maxY = y;\n\t\t      minIndex = maxIndex = startIndex = i;\n\t\t    }\n\t\t  }\n\t\t  return decimated;\n\t\t}\n\t\tfunction cleanDecimatedDataset(dataset) {\n\t\t  if (dataset._decimated) {\n\t\t    const data = dataset._data;\n\t\t    delete dataset._decimated;\n\t\t    delete dataset._data;\n\t\t    Object.defineProperty(dataset, 'data', {value: data});\n\t\t  }\n\t\t}\n\t\tfunction cleanDecimatedData(chart) {\n\t\t  chart.data.datasets.forEach((dataset) => {\n\t\t    cleanDecimatedDataset(dataset);\n\t\t  });\n\t\t}\n\t\tfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n\t\t  const pointCount = points.length;\n\t\t  let start = 0;\n\t\t  let count;\n\t\t  const {iScale} = meta;\n\t\t  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\t\t  if (minDefined) {\n\t\t    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n\t\t  }\n\t\t  if (maxDefined) {\n\t\t    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n\t\t  } else {\n\t\t    count = pointCount - start;\n\t\t  }\n\t\t  return {start, count};\n\t\t}\n\t\tvar plugin_decimation = {\n\t\t  id: 'decimation',\n\t\t  defaults: {\n\t\t    algorithm: 'min-max',\n\t\t    enabled: false,\n\t\t  },\n\t\t  beforeElementsUpdate: (chart, args, options) => {\n\t\t    if (!options.enabled) {\n\t\t      cleanDecimatedData(chart);\n\t\t      return;\n\t\t    }\n\t\t    const availableWidth = chart.width;\n\t\t    chart.data.datasets.forEach((dataset, datasetIndex) => {\n\t\t      const {_data, indexAxis} = dataset;\n\t\t      const meta = chart.getDatasetMeta(datasetIndex);\n\t\t      const data = _data || dataset.data;\n\t\t      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n\t\t        return;\n\t\t      }\n\t\t      if (meta.type !== 'line') {\n\t\t        return;\n\t\t      }\n\t\t      const xAxis = chart.scales[meta.xAxisID];\n\t\t      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n\t\t        return;\n\t\t      }\n\t\t      if (chart.options.parsing) {\n\t\t        return;\n\t\t      }\n\t\t      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n\t\t      const threshold = options.threshold || 4 * availableWidth;\n\t\t      if (count <= threshold) {\n\t\t        cleanDecimatedDataset(dataset);\n\t\t        return;\n\t\t      }\n\t\t      if (isNullOrUndef(_data)) {\n\t\t        dataset._data = data;\n\t\t        delete dataset.data;\n\t\t        Object.defineProperty(dataset, 'data', {\n\t\t          configurable: true,\n\t\t          enumerable: true,\n\t\t          get: function() {\n\t\t            return this._decimated;\n\t\t          },\n\t\t          set: function(d) {\n\t\t            this._data = d;\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      let decimated;\n\t\t      switch (options.algorithm) {\n\t\t      case 'lttb':\n\t\t        decimated = lttbDecimation(data, start, count, availableWidth, options);\n\t\t        break;\n\t\t      case 'min-max':\n\t\t        decimated = minMaxDecimation(data, start, count, availableWidth);\n\t\t        break;\n\t\t      default:\n\t\t        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n\t\t      }\n\t\t      dataset._decimated = decimated;\n\t\t    });\n\t\t  },\n\t\t  destroy(chart) {\n\t\t    cleanDecimatedData(chart);\n\t\t  }\n\t\t};\n\n\t\tfunction getLineByIndex(chart, index) {\n\t\t  const meta = chart.getDatasetMeta(index);\n\t\t  const visible = meta && chart.isDatasetVisible(index);\n\t\t  return visible ? meta.dataset : null;\n\t\t}\n\t\tfunction parseFillOption(line) {\n\t\t  const options = line.options;\n\t\t  const fillOption = options.fill;\n\t\t  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\t\t  if (fill === undefined) {\n\t\t    fill = !!options.backgroundColor;\n\t\t  }\n\t\t  if (fill === false || fill === null) {\n\t\t    return false;\n\t\t  }\n\t\t  if (fill === true) {\n\t\t    return 'origin';\n\t\t  }\n\t\t  return fill;\n\t\t}\n\t\tfunction decodeFill(line, index, count) {\n\t\t  const fill = parseFillOption(line);\n\t\t  if (isObject(fill)) {\n\t\t    return isNaN(fill.value) ? false : fill;\n\t\t  }\n\t\t  let target = parseFloat(fill);\n\t\t  if (isNumberFinite(target) && Math.floor(target) === target) {\n\t\t    if (fill[0] === '-' || fill[0] === '+') {\n\t\t      target = index + target;\n\t\t    }\n\t\t    if (target === index || target < 0 || target >= count) {\n\t\t      return false;\n\t\t    }\n\t\t    return target;\n\t\t  }\n\t\t  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n\t\t}\n\t\tfunction computeLinearBoundary(source) {\n\t\t  const {scale = {}, fill} = source;\n\t\t  let target = null;\n\t\t  let horizontal;\n\t\t  if (fill === 'start') {\n\t\t    target = scale.bottom;\n\t\t  } else if (fill === 'end') {\n\t\t    target = scale.top;\n\t\t  } else if (isObject(fill)) {\n\t\t    target = scale.getPixelForValue(fill.value);\n\t\t  } else if (scale.getBasePixel) {\n\t\t    target = scale.getBasePixel();\n\t\t  }\n\t\t  if (isNumberFinite(target)) {\n\t\t    horizontal = scale.isHorizontal();\n\t\t    return {\n\t\t      x: horizontal ? target : null,\n\t\t      y: horizontal ? null : target\n\t\t    };\n\t\t  }\n\t\t  return null;\n\t\t}\n\t\tclass simpleArc {\n\t\t  constructor(opts) {\n\t\t    this.x = opts.x;\n\t\t    this.y = opts.y;\n\t\t    this.radius = opts.radius;\n\t\t  }\n\t\t  pathSegment(ctx, bounds, opts) {\n\t\t    const {x, y, radius} = this;\n\t\t    bounds = bounds || {start: 0, end: TAU};\n\t\t    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n\t\t    return !opts.bounds;\n\t\t  }\n\t\t  interpolate(point) {\n\t\t    const {x, y, radius} = this;\n\t\t    const angle = point.angle;\n\t\t    return {\n\t\t      x: x + Math.cos(angle) * radius,\n\t\t      y: y + Math.sin(angle) * radius,\n\t\t      angle\n\t\t    };\n\t\t  }\n\t\t}\n\t\tfunction computeCircularBoundary(source) {\n\t\t  const {scale, fill} = source;\n\t\t  const options = scale.options;\n\t\t  const length = scale.getLabels().length;\n\t\t  const target = [];\n\t\t  const start = options.reverse ? scale.max : scale.min;\n\t\t  const end = options.reverse ? scale.min : scale.max;\n\t\t  let i, center, value;\n\t\t  if (fill === 'start') {\n\t\t    value = start;\n\t\t  } else if (fill === 'end') {\n\t\t    value = end;\n\t\t  } else if (isObject(fill)) {\n\t\t    value = fill.value;\n\t\t  } else {\n\t\t    value = scale.getBaseValue();\n\t\t  }\n\t\t  if (options.grid.circular) {\n\t\t    center = scale.getPointPositionForValue(0, start);\n\t\t    return new simpleArc({\n\t\t      x: center.x,\n\t\t      y: center.y,\n\t\t      radius: scale.getDistanceFromCenterForValue(value)\n\t\t    });\n\t\t  }\n\t\t  for (i = 0; i < length; ++i) {\n\t\t    target.push(scale.getPointPositionForValue(i, value));\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\tfunction computeBoundary(source) {\n\t\t  const scale = source.scale || {};\n\t\t  if (scale.getPointPositionForValue) {\n\t\t    return computeCircularBoundary(source);\n\t\t  }\n\t\t  return computeLinearBoundary(source);\n\t\t}\n\t\tfunction findSegmentEnd(start, end, points) {\n\t\t  for (;end > start; end--) {\n\t\t    const point = points[end];\n\t\t    if (!isNaN(point.x) && !isNaN(point.y)) {\n\t\t      break;\n\t\t    }\n\t\t  }\n\t\t  return end;\n\t\t}\n\t\tfunction pointsFromSegments(boundary, line) {\n\t\t  const {x = null, y = null} = boundary || {};\n\t\t  const linePoints = line.points;\n\t\t  const points = [];\n\t\t  line.segments.forEach(({start, end}) => {\n\t\t    end = findSegmentEnd(start, end, linePoints);\n\t\t    const first = linePoints[start];\n\t\t    const last = linePoints[end];\n\t\t    if (y !== null) {\n\t\t      points.push({x: first.x, y});\n\t\t      points.push({x: last.x, y});\n\t\t    } else if (x !== null) {\n\t\t      points.push({x, y: first.y});\n\t\t      points.push({x, y: last.y});\n\t\t    }\n\t\t  });\n\t\t  return points;\n\t\t}\n\t\tfunction buildStackLine(source) {\n\t\t  const {scale, index, line} = source;\n\t\t  const points = [];\n\t\t  const segments = line.segments;\n\t\t  const sourcePoints = line.points;\n\t\t  const linesBelow = getLinesBelow(scale, index);\n\t\t  linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));\n\t\t  for (let i = 0; i < segments.length; i++) {\n\t\t    const segment = segments[i];\n\t\t    for (let j = segment.start; j <= segment.end; j++) {\n\t\t      addPointsBelow(points, sourcePoints[j], linesBelow);\n\t\t    }\n\t\t  }\n\t\t  return new LineElement({points, options: {}});\n\t\t}\n\t\tfunction getLinesBelow(scale, index) {\n\t\t  const below = [];\n\t\t  const metas = scale.getMatchingVisibleMetas('line');\n\t\t  for (let i = 0; i < metas.length; i++) {\n\t\t    const meta = metas[i];\n\t\t    if (meta.index === index) {\n\t\t      break;\n\t\t    }\n\t\t    if (!meta.hidden) {\n\t\t      below.unshift(meta.dataset);\n\t\t    }\n\t\t  }\n\t\t  return below;\n\t\t}\n\t\tfunction addPointsBelow(points, sourcePoint, linesBelow) {\n\t\t  const postponed = [];\n\t\t  for (let j = 0; j < linesBelow.length; j++) {\n\t\t    const line = linesBelow[j];\n\t\t    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\t\t    if (!point || (first && last)) {\n\t\t      continue;\n\t\t    }\n\t\t    if (first) {\n\t\t      postponed.unshift(point);\n\t\t    } else {\n\t\t      points.push(point);\n\t\t      if (!last) {\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  points.push(...postponed);\n\t\t}\n\t\tfunction findPoint(line, sourcePoint, property) {\n\t\t  const point = line.interpolate(sourcePoint, property);\n\t\t  if (!point) {\n\t\t    return {};\n\t\t  }\n\t\t  const pointValue = point[property];\n\t\t  const segments = line.segments;\n\t\t  const linePoints = line.points;\n\t\t  let first = false;\n\t\t  let last = false;\n\t\t  for (let i = 0; i < segments.length; i++) {\n\t\t    const segment = segments[i];\n\t\t    const firstValue = linePoints[segment.start][property];\n\t\t    const lastValue = linePoints[segment.end][property];\n\t\t    if (_isBetween(pointValue, firstValue, lastValue)) {\n\t\t      first = pointValue === firstValue;\n\t\t      last = pointValue === lastValue;\n\t\t      break;\n\t\t    }\n\t\t  }\n\t\t  return {first, last, point};\n\t\t}\n\t\tfunction getTarget(source) {\n\t\t  const {chart, fill, line} = source;\n\t\t  if (isNumberFinite(fill)) {\n\t\t    return getLineByIndex(chart, fill);\n\t\t  }\n\t\t  if (fill === 'stack') {\n\t\t    return buildStackLine(source);\n\t\t  }\n\t\t  if (fill === 'shape') {\n\t\t    return true;\n\t\t  }\n\t\t  const boundary = computeBoundary(source);\n\t\t  if (boundary instanceof simpleArc) {\n\t\t    return boundary;\n\t\t  }\n\t\t  return createBoundaryLine(boundary, line);\n\t\t}\n\t\tfunction createBoundaryLine(boundary, line) {\n\t\t  let points = [];\n\t\t  let _loop = false;\n\t\t  if (isArray(boundary)) {\n\t\t    _loop = true;\n\t\t    points = boundary;\n\t\t  } else {\n\t\t    points = pointsFromSegments(boundary, line);\n\t\t  }\n\t\t  return points.length ? new LineElement({\n\t\t    points,\n\t\t    options: {tension: 0},\n\t\t    _loop,\n\t\t    _fullLoop: _loop\n\t\t  }) : null;\n\t\t}\n\t\tfunction resolveTarget(sources, index, propagate) {\n\t\t  const source = sources[index];\n\t\t  let fill = source.fill;\n\t\t  const visited = [index];\n\t\t  let target;\n\t\t  if (!propagate) {\n\t\t    return fill;\n\t\t  }\n\t\t  while (fill !== false && visited.indexOf(fill) === -1) {\n\t\t    if (!isNumberFinite(fill)) {\n\t\t      return fill;\n\t\t    }\n\t\t    target = sources[fill];\n\t\t    if (!target) {\n\t\t      return false;\n\t\t    }\n\t\t    if (target.visible) {\n\t\t      return fill;\n\t\t    }\n\t\t    visited.push(fill);\n\t\t    fill = target.fill;\n\t\t  }\n\t\t  return false;\n\t\t}\n\t\tfunction _clip(ctx, target, clipY) {\n\t\t  const {segments, points} = target;\n\t\t  let first = true;\n\t\t  let lineLoop = false;\n\t\t  ctx.beginPath();\n\t\t  for (const segment of segments) {\n\t\t    const {start, end} = segment;\n\t\t    const firstPoint = points[start];\n\t\t    const lastPoint = points[findSegmentEnd(start, end, points)];\n\t\t    if (first) {\n\t\t      ctx.moveTo(firstPoint.x, firstPoint.y);\n\t\t      first = false;\n\t\t    } else {\n\t\t      ctx.lineTo(firstPoint.x, clipY);\n\t\t      ctx.lineTo(firstPoint.x, firstPoint.y);\n\t\t    }\n\t\t    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n\t\t    if (lineLoop) {\n\t\t      ctx.closePath();\n\t\t    } else {\n\t\t      ctx.lineTo(lastPoint.x, clipY);\n\t\t    }\n\t\t  }\n\t\t  ctx.lineTo(target.first().x, clipY);\n\t\t  ctx.closePath();\n\t\t  ctx.clip();\n\t\t}\n\t\tfunction getBounds(property, first, last, loop) {\n\t\t  if (loop) {\n\t\t    return;\n\t\t  }\n\t\t  let start = first[property];\n\t\t  let end = last[property];\n\t\t  if (property === 'angle') {\n\t\t    start = _normalizeAngle(start);\n\t\t    end = _normalizeAngle(end);\n\t\t  }\n\t\t  return {property, start, end};\n\t\t}\n\t\tfunction _getEdge(a, b, prop, fn) {\n\t\t  if (a && b) {\n\t\t    return fn(a[prop], b[prop]);\n\t\t  }\n\t\t  return a ? a[prop] : b ? b[prop] : 0;\n\t\t}\n\t\tfunction _segments(line, target, property) {\n\t\t  const segments = line.segments;\n\t\t  const points = line.points;\n\t\t  const tpoints = target.points;\n\t\t  const parts = [];\n\t\t  for (const segment of segments) {\n\t\t    let {start, end} = segment;\n\t\t    end = findSegmentEnd(start, end, points);\n\t\t    const bounds = getBounds(property, points[start], points[end], segment.loop);\n\t\t    if (!target.segments) {\n\t\t      parts.push({\n\t\t        source: segment,\n\t\t        target: bounds,\n\t\t        start: points[start],\n\t\t        end: points[end]\n\t\t      });\n\t\t      continue;\n\t\t    }\n\t\t    const targetSegments = _boundSegments(target, bounds);\n\t\t    for (const tgt of targetSegments) {\n\t\t      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n\t\t      const fillSources = _boundSegment(segment, points, subBounds);\n\t\t      for (const fillSource of fillSources) {\n\t\t        parts.push({\n\t\t          source: fillSource,\n\t\t          target: tgt,\n\t\t          start: {\n\t\t            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n\t\t          },\n\t\t          end: {\n\t\t            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return parts;\n\t\t}\n\t\tfunction clipBounds(ctx, scale, bounds) {\n\t\t  const {top, bottom} = scale.chart.chartArea;\n\t\t  const {property, start, end} = bounds || {};\n\t\t  if (property === 'x') {\n\t\t    ctx.beginPath();\n\t\t    ctx.rect(start, top, end - start, bottom - top);\n\t\t    ctx.clip();\n\t\t  }\n\t\t}\n\t\tfunction interpolatedLineTo(ctx, target, point, property) {\n\t\t  const interpolatedPoint = target.interpolate(point, property);\n\t\t  if (interpolatedPoint) {\n\t\t    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n\t\t  }\n\t\t}\n\t\tfunction _fill(ctx, cfg) {\n\t\t  const {line, target, property, color, scale} = cfg;\n\t\t  const segments = _segments(line, target, property);\n\t\t  for (const {source: src, target: tgt, start, end} of segments) {\n\t\t    const {style: {backgroundColor = color} = {}} = src;\n\t\t    const notShape = target !== true;\n\t\t    ctx.save();\n\t\t    ctx.fillStyle = backgroundColor;\n\t\t    clipBounds(ctx, scale, notShape && getBounds(property, start, end));\n\t\t    ctx.beginPath();\n\t\t    const lineLoop = !!line.pathSegment(ctx, src);\n\t\t    let loop;\n\t\t    if (notShape) {\n\t\t      if (lineLoop) {\n\t\t        ctx.closePath();\n\t\t      } else {\n\t\t        interpolatedLineTo(ctx, target, end, property);\n\t\t      }\n\t\t      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n\t\t      loop = lineLoop && targetLoop;\n\t\t      if (!loop) {\n\t\t        interpolatedLineTo(ctx, target, start, property);\n\t\t      }\n\t\t    }\n\t\t    ctx.closePath();\n\t\t    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\t\t    ctx.restore();\n\t\t  }\n\t\t}\n\t\tfunction doFill(ctx, cfg) {\n\t\t  const {line, target, above, below, area, scale} = cfg;\n\t\t  const property = line._loop ? 'angle' : cfg.axis;\n\t\t  ctx.save();\n\t\t  if (property === 'x' && below !== above) {\n\t\t    _clip(ctx, target, area.top);\n\t\t    _fill(ctx, {line, target, color: above, scale, property});\n\t\t    ctx.restore();\n\t\t    ctx.save();\n\t\t    _clip(ctx, target, area.bottom);\n\t\t  }\n\t\t  _fill(ctx, {line, target, color: below, scale, property});\n\t\t  ctx.restore();\n\t\t}\n\t\tfunction drawfill(ctx, source, area) {\n\t\t  const target = getTarget(source);\n\t\t  const {line, scale, axis} = source;\n\t\t  const lineOpts = line.options;\n\t\t  const fillOption = lineOpts.fill;\n\t\t  const color = lineOpts.backgroundColor;\n\t\t  const {above = color, below = color} = fillOption || {};\n\t\t  if (target && line.points.length) {\n\t\t    clipArea(ctx, area);\n\t\t    doFill(ctx, {line, target, above, below, area, scale, axis});\n\t\t    unclipArea(ctx);\n\t\t  }\n\t\t}\n\t\tvar plugin_filler = {\n\t\t  id: 'filler',\n\t\t  afterDatasetsUpdate(chart, _args, options) {\n\t\t    const count = (chart.data.datasets || []).length;\n\t\t    const sources = [];\n\t\t    let meta, i, line, source;\n\t\t    for (i = 0; i < count; ++i) {\n\t\t      meta = chart.getDatasetMeta(i);\n\t\t      line = meta.dataset;\n\t\t      source = null;\n\t\t      if (line && line.options && line instanceof LineElement) {\n\t\t        source = {\n\t\t          visible: chart.isDatasetVisible(i),\n\t\t          index: i,\n\t\t          fill: decodeFill(line, i, count),\n\t\t          chart,\n\t\t          axis: meta.controller.options.indexAxis,\n\t\t          scale: meta.vScale,\n\t\t          line,\n\t\t        };\n\t\t      }\n\t\t      meta.$filler = source;\n\t\t      sources.push(source);\n\t\t    }\n\t\t    for (i = 0; i < count; ++i) {\n\t\t      source = sources[i];\n\t\t      if (!source || source.fill === false) {\n\t\t        continue;\n\t\t      }\n\t\t      source.fill = resolveTarget(sources, i, options.propagate);\n\t\t    }\n\t\t  },\n\t\t  beforeDraw(chart, _args, options) {\n\t\t    const draw = options.drawTime === 'beforeDraw';\n\t\t    const metasets = chart.getSortedVisibleDatasetMetas();\n\t\t    const area = chart.chartArea;\n\t\t    for (let i = metasets.length - 1; i >= 0; --i) {\n\t\t      const source = metasets[i].$filler;\n\t\t      if (!source) {\n\t\t        continue;\n\t\t      }\n\t\t      source.line.updateControlPoints(area, source.axis);\n\t\t      if (draw) {\n\t\t        drawfill(chart.ctx, source, area);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  beforeDatasetsDraw(chart, _args, options) {\n\t\t    if (options.drawTime !== 'beforeDatasetsDraw') {\n\t\t      return;\n\t\t    }\n\t\t    const metasets = chart.getSortedVisibleDatasetMetas();\n\t\t    for (let i = metasets.length - 1; i >= 0; --i) {\n\t\t      const source = metasets[i].$filler;\n\t\t      if (source) {\n\t\t        drawfill(chart.ctx, source, chart.chartArea);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  beforeDatasetDraw(chart, args, options) {\n\t\t    const source = args.meta.$filler;\n\t\t    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {\n\t\t      return;\n\t\t    }\n\t\t    drawfill(chart.ctx, source, chart.chartArea);\n\t\t  },\n\t\t  defaults: {\n\t\t    propagate: true,\n\t\t    drawTime: 'beforeDatasetDraw'\n\t\t  }\n\t\t};\n\n\t\tconst getBoxSize = (labelOpts, fontSize) => {\n\t\t  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\t\t  if (labelOpts.usePointStyle) {\n\t\t    boxHeight = Math.min(boxHeight, fontSize);\n\t\t    boxWidth = Math.min(boxWidth, fontSize);\n\t\t  }\n\t\t  return {\n\t\t    boxWidth,\n\t\t    boxHeight,\n\t\t    itemHeight: Math.max(fontSize, boxHeight)\n\t\t  };\n\t\t};\n\t\tconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\t\tclass Legend extends Element {\n\t\t  constructor(config) {\n\t\t    super();\n\t\t    this._added = false;\n\t\t    this.legendHitBoxes = [];\n\t\t    this._hoveredItem = null;\n\t\t    this.doughnutMode = false;\n\t\t    this.chart = config.chart;\n\t\t    this.options = config.options;\n\t\t    this.ctx = config.ctx;\n\t\t    this.legendItems = undefined;\n\t\t    this.columnSizes = undefined;\n\t\t    this.lineWidths = undefined;\n\t\t    this.maxHeight = undefined;\n\t\t    this.maxWidth = undefined;\n\t\t    this.top = undefined;\n\t\t    this.bottom = undefined;\n\t\t    this.left = undefined;\n\t\t    this.right = undefined;\n\t\t    this.height = undefined;\n\t\t    this.width = undefined;\n\t\t    this._margins = undefined;\n\t\t    this.position = undefined;\n\t\t    this.weight = undefined;\n\t\t    this.fullSize = undefined;\n\t\t  }\n\t\t  update(maxWidth, maxHeight, margins) {\n\t\t    this.maxWidth = maxWidth;\n\t\t    this.maxHeight = maxHeight;\n\t\t    this._margins = margins;\n\t\t    this.setDimensions();\n\t\t    this.buildLabels();\n\t\t    this.fit();\n\t\t  }\n\t\t  setDimensions() {\n\t\t    if (this.isHorizontal()) {\n\t\t      this.width = this.maxWidth;\n\t\t      this.left = this._margins.left;\n\t\t      this.right = this.width;\n\t\t    } else {\n\t\t      this.height = this.maxHeight;\n\t\t      this.top = this._margins.top;\n\t\t      this.bottom = this.height;\n\t\t    }\n\t\t  }\n\t\t  buildLabels() {\n\t\t    const labelOpts = this.options.labels || {};\n\t\t    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\n\t\t    if (labelOpts.filter) {\n\t\t      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n\t\t    }\n\t\t    if (labelOpts.sort) {\n\t\t      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n\t\t    }\n\t\t    if (this.options.reverse) {\n\t\t      legendItems.reverse();\n\t\t    }\n\t\t    this.legendItems = legendItems;\n\t\t  }\n\t\t  fit() {\n\t\t    const {options, ctx} = this;\n\t\t    if (!options.display) {\n\t\t      this.width = this.height = 0;\n\t\t      return;\n\t\t    }\n\t\t    const labelOpts = options.labels;\n\t\t    const labelFont = toFont(labelOpts.font);\n\t\t    const fontSize = labelFont.size;\n\t\t    const titleHeight = this._computeTitleHeight();\n\t\t    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\t\t    let width, height;\n\t\t    ctx.font = labelFont.string;\n\t\t    if (this.isHorizontal()) {\n\t\t      width = this.maxWidth;\n\t\t      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n\t\t    } else {\n\t\t      height = this.maxHeight;\n\t\t      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n\t\t    }\n\t\t    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n\t\t    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n\t\t  }\n\t\t  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n\t\t    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n\t\t    const hitboxes = this.legendHitBoxes = [];\n\t\t    const lineWidths = this.lineWidths = [0];\n\t\t    const lineHeight = itemHeight + padding;\n\t\t    let totalHeight = titleHeight;\n\t\t    ctx.textAlign = 'left';\n\t\t    ctx.textBaseline = 'middle';\n\t\t    let row = -1;\n\t\t    let top = -lineHeight;\n\t\t    this.legendItems.forEach((legendItem, i) => {\n\t\t      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\t      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n\t\t        totalHeight += lineHeight;\n\t\t        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n\t\t        top += lineHeight;\n\t\t        row++;\n\t\t      }\n\t\t      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\t\t      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n\t\t    });\n\t\t    return totalHeight;\n\t\t  }\n\t\t  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n\t\t    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n\t\t    const hitboxes = this.legendHitBoxes = [];\n\t\t    const columnSizes = this.columnSizes = [];\n\t\t    const heightLimit = maxHeight - titleHeight;\n\t\t    let totalWidth = padding;\n\t\t    let currentColWidth = 0;\n\t\t    let currentColHeight = 0;\n\t\t    let left = 0;\n\t\t    let col = 0;\n\t\t    this.legendItems.forEach((legendItem, i) => {\n\t\t      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\t      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n\t\t        totalWidth += currentColWidth + padding;\n\t\t        columnSizes.push({width: currentColWidth, height: currentColHeight});\n\t\t        left += currentColWidth + padding;\n\t\t        col++;\n\t\t        currentColWidth = currentColHeight = 0;\n\t\t      }\n\t\t      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\t\t      currentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t      currentColHeight += itemHeight + padding;\n\t\t    });\n\t\t    totalWidth += currentColWidth;\n\t\t    columnSizes.push({width: currentColWidth, height: currentColHeight});\n\t\t    return totalWidth;\n\t\t  }\n\t\t  adjustHitBoxes() {\n\t\t    if (!this.options.display) {\n\t\t      return;\n\t\t    }\n\t\t    const titleHeight = this._computeTitleHeight();\n\t\t    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n\t\t    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n\t\t    if (this.isHorizontal()) {\n\t\t      let row = 0;\n\t\t      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n\t\t      for (const hitbox of hitboxes) {\n\t\t        if (row !== hitbox.row) {\n\t\t          row = hitbox.row;\n\t\t          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n\t\t        }\n\t\t        hitbox.top += this.top + titleHeight + padding;\n\t\t        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n\t\t        left += hitbox.width + padding;\n\t\t      }\n\t\t    } else {\n\t\t      let col = 0;\n\t\t      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n\t\t      for (const hitbox of hitboxes) {\n\t\t        if (hitbox.col !== col) {\n\t\t          col = hitbox.col;\n\t\t          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n\t\t        }\n\t\t        hitbox.top = top;\n\t\t        hitbox.left += this.left + padding;\n\t\t        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n\t\t        top += hitbox.height + padding;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  isHorizontal() {\n\t\t    return this.options.position === 'top' || this.options.position === 'bottom';\n\t\t  }\n\t\t  draw() {\n\t\t    if (this.options.display) {\n\t\t      const ctx = this.ctx;\n\t\t      clipArea(ctx, this);\n\t\t      this._draw();\n\t\t      unclipArea(ctx);\n\t\t    }\n\t\t  }\n\t\t  _draw() {\n\t\t    const {options: opts, columnSizes, lineWidths, ctx} = this;\n\t\t    const {align, labels: labelOpts} = opts;\n\t\t    const defaultColor = defaults.color;\n\t\t    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n\t\t    const labelFont = toFont(labelOpts.font);\n\t\t    const {color: fontColor, padding} = labelOpts;\n\t\t    const fontSize = labelFont.size;\n\t\t    const halfFontSize = fontSize / 2;\n\t\t    let cursor;\n\t\t    this.drawTitle();\n\t\t    ctx.textAlign = rtlHelper.textAlign('left');\n\t\t    ctx.textBaseline = 'middle';\n\t\t    ctx.lineWidth = 0.5;\n\t\t    ctx.font = labelFont.string;\n\t\t    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\t\t    const drawLegendBox = function(x, y, legendItem) {\n\t\t      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n\t\t        return;\n\t\t      }\n\t\t      ctx.save();\n\t\t      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n\t\t      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n\t\t      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n\t\t      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n\t\t      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n\t\t      ctx.lineWidth = lineWidth;\n\t\t      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\t\t      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\t\t      if (labelOpts.usePointStyle) {\n\t\t        const drawOptions = {\n\t\t          radius: boxWidth * Math.SQRT2 / 2,\n\t\t          pointStyle: legendItem.pointStyle,\n\t\t          rotation: legendItem.rotation,\n\t\t          borderWidth: lineWidth\n\t\t        };\n\t\t        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n\t\t        const centerY = y + halfFontSize;\n\t\t        drawPoint(ctx, drawOptions, centerX, centerY);\n\t\t      } else {\n\t\t        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n\t\t        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n\t\t        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\t\t        ctx.beginPath();\n\t\t        if (Object.values(borderRadius).some(v => v !== 0)) {\n\t\t          addRoundedRectPath(ctx, {\n\t\t            x: xBoxLeft,\n\t\t            y: yBoxTop,\n\t\t            w: boxWidth,\n\t\t            h: boxHeight,\n\t\t            radius: borderRadius,\n\t\t          });\n\t\t        } else {\n\t\t          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n\t\t        }\n\t\t        ctx.fill();\n\t\t        if (lineWidth !== 0) {\n\t\t          ctx.stroke();\n\t\t        }\n\t\t      }\n\t\t      ctx.restore();\n\t\t    };\n\t\t    const fillText = function(x, y, legendItem) {\n\t\t      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n\t\t        strikethrough: legendItem.hidden,\n\t\t        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n\t\t      });\n\t\t    };\n\t\t    const isHorizontal = this.isHorizontal();\n\t\t    const titleHeight = this._computeTitleHeight();\n\t\t    if (isHorizontal) {\n\t\t      cursor = {\n\t\t        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n\t\t        y: this.top + padding + titleHeight,\n\t\t        line: 0\n\t\t      };\n\t\t    } else {\n\t\t      cursor = {\n\t\t        x: this.left + padding,\n\t\t        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n\t\t        line: 0\n\t\t      };\n\t\t    }\n\t\t    overrideTextDirection(this.ctx, opts.textDirection);\n\t\t    const lineHeight = itemHeight + padding;\n\t\t    this.legendItems.forEach((legendItem, i) => {\n\t\t      ctx.strokeStyle = legendItem.fontColor || fontColor;\n\t\t      ctx.fillStyle = legendItem.fontColor || fontColor;\n\t\t      const textWidth = ctx.measureText(legendItem.text).width;\n\t\t      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n\t\t      const width = boxWidth + halfFontSize + textWidth;\n\t\t      let x = cursor.x;\n\t\t      let y = cursor.y;\n\t\t      rtlHelper.setWidth(this.width);\n\t\t      if (isHorizontal) {\n\t\t        if (i > 0 && x + width + padding > this.right) {\n\t\t          y = cursor.y += lineHeight;\n\t\t          cursor.line++;\n\t\t          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n\t\t        }\n\t\t      } else if (i > 0 && y + lineHeight > this.bottom) {\n\t\t        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n\t\t        cursor.line++;\n\t\t        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n\t\t      }\n\t\t      const realX = rtlHelper.x(x);\n\t\t      drawLegendBox(realX, y, legendItem);\n\t\t      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\t\t      fillText(rtlHelper.x(x), y, legendItem);\n\t\t      if (isHorizontal) {\n\t\t        cursor.x += width + padding;\n\t\t      } else {\n\t\t        cursor.y += lineHeight;\n\t\t      }\n\t\t    });\n\t\t    restoreTextDirection(this.ctx, opts.textDirection);\n\t\t  }\n\t\t  drawTitle() {\n\t\t    const opts = this.options;\n\t\t    const titleOpts = opts.title;\n\t\t    const titleFont = toFont(titleOpts.font);\n\t\t    const titlePadding = toPadding(titleOpts.padding);\n\t\t    if (!titleOpts.display) {\n\t\t      return;\n\t\t    }\n\t\t    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n\t\t    const ctx = this.ctx;\n\t\t    const position = titleOpts.position;\n\t\t    const halfFontSize = titleFont.size / 2;\n\t\t    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n\t\t    let y;\n\t\t    let left = this.left;\n\t\t    let maxWidth = this.width;\n\t\t    if (this.isHorizontal()) {\n\t\t      maxWidth = Math.max(...this.lineWidths);\n\t\t      y = this.top + topPaddingPlusHalfFontSize;\n\t\t      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n\t\t    } else {\n\t\t      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n\t\t      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n\t\t    }\n\t\t    const x = _alignStartEnd(position, left, left + maxWidth);\n\t\t    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n\t\t    ctx.textBaseline = 'middle';\n\t\t    ctx.strokeStyle = titleOpts.color;\n\t\t    ctx.fillStyle = titleOpts.color;\n\t\t    ctx.font = titleFont.string;\n\t\t    renderText(ctx, titleOpts.text, x, y, titleFont);\n\t\t  }\n\t\t  _computeTitleHeight() {\n\t\t    const titleOpts = this.options.title;\n\t\t    const titleFont = toFont(titleOpts.font);\n\t\t    const titlePadding = toPadding(titleOpts.padding);\n\t\t    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n\t\t  }\n\t\t  _getLegendItemAt(x, y) {\n\t\t    let i, hitBox, lh;\n\t\t    if (_isBetween(x, this.left, this.right)\n\t\t      && _isBetween(y, this.top, this.bottom)) {\n\t\t      lh = this.legendHitBoxes;\n\t\t      for (i = 0; i < lh.length; ++i) {\n\t\t        hitBox = lh[i];\n\t\t        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n\t\t          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n\t\t          return this.legendItems[i];\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return null;\n\t\t  }\n\t\t  handleEvent(e) {\n\t\t    const opts = this.options;\n\t\t    if (!isListened(e.type, opts)) {\n\t\t      return;\n\t\t    }\n\t\t    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\t\t    if (e.type === 'mousemove') {\n\t\t      const previous = this._hoveredItem;\n\t\t      const sameItem = itemsEqual(previous, hoveredItem);\n\t\t      if (previous && !sameItem) {\n\t\t        callback(opts.onLeave, [e, previous, this], this);\n\t\t      }\n\t\t      this._hoveredItem = hoveredItem;\n\t\t      if (hoveredItem && !sameItem) {\n\t\t        callback(opts.onHover, [e, hoveredItem, this], this);\n\t\t      }\n\t\t    } else if (hoveredItem) {\n\t\t      callback(opts.onClick, [e, hoveredItem, this], this);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction isListened(type, opts) {\n\t\t  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {\n\t\t    return true;\n\t\t  }\n\t\t  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n\t\t    return true;\n\t\t  }\n\t\t  return false;\n\t\t}\n\t\tvar plugin_legend = {\n\t\t  id: 'legend',\n\t\t  _element: Legend,\n\t\t  start(chart, _args, options) {\n\t\t    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n\t\t    layouts.configure(chart, legend, options);\n\t\t    layouts.addBox(chart, legend);\n\t\t  },\n\t\t  stop(chart) {\n\t\t    layouts.removeBox(chart, chart.legend);\n\t\t    delete chart.legend;\n\t\t  },\n\t\t  beforeUpdate(chart, _args, options) {\n\t\t    const legend = chart.legend;\n\t\t    layouts.configure(chart, legend, options);\n\t\t    legend.options = options;\n\t\t  },\n\t\t  afterUpdate(chart) {\n\t\t    const legend = chart.legend;\n\t\t    legend.buildLabels();\n\t\t    legend.adjustHitBoxes();\n\t\t  },\n\t\t  afterEvent(chart, args) {\n\t\t    if (!args.replay) {\n\t\t      chart.legend.handleEvent(args.event);\n\t\t    }\n\t\t  },\n\t\t  defaults: {\n\t\t    display: true,\n\t\t    position: 'top',\n\t\t    align: 'center',\n\t\t    fullSize: true,\n\t\t    reverse: false,\n\t\t    weight: 1000,\n\t\t    onClick(e, legendItem, legend) {\n\t\t      const index = legendItem.datasetIndex;\n\t\t      const ci = legend.chart;\n\t\t      if (ci.isDatasetVisible(index)) {\n\t\t        ci.hide(index);\n\t\t        legendItem.hidden = true;\n\t\t      } else {\n\t\t        ci.show(index);\n\t\t        legendItem.hidden = false;\n\t\t      }\n\t\t    },\n\t\t    onHover: null,\n\t\t    onLeave: null,\n\t\t    labels: {\n\t\t      color: (ctx) => ctx.chart.options.color,\n\t\t      boxWidth: 40,\n\t\t      padding: 10,\n\t\t      generateLabels(chart) {\n\t\t        const datasets = chart.data.datasets;\n\t\t        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n\t\t        return chart._getSortedDatasetMetas().map((meta) => {\n\t\t          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n\t\t          const borderWidth = toPadding(style.borderWidth);\n\t\t          return {\n\t\t            text: datasets[meta.index].label,\n\t\t            fillStyle: style.backgroundColor,\n\t\t            fontColor: color,\n\t\t            hidden: !meta.visible,\n\t\t            lineCap: style.borderCapStyle,\n\t\t            lineDash: style.borderDash,\n\t\t            lineDashOffset: style.borderDashOffset,\n\t\t            lineJoin: style.borderJoinStyle,\n\t\t            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n\t\t            strokeStyle: style.borderColor,\n\t\t            pointStyle: pointStyle || style.pointStyle,\n\t\t            rotation: style.rotation,\n\t\t            textAlign: textAlign || style.textAlign,\n\t\t            borderRadius: 0,\n\t\t            datasetIndex: meta.index\n\t\t          };\n\t\t        }, this);\n\t\t      }\n\t\t    },\n\t\t    title: {\n\t\t      color: (ctx) => ctx.chart.options.color,\n\t\t      display: false,\n\t\t      position: 'center',\n\t\t      text: '',\n\t\t    }\n\t\t  },\n\t\t  descriptors: {\n\t\t    _scriptable: (name) => !name.startsWith('on'),\n\t\t    labels: {\n\t\t      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n\t\t    }\n\t\t  },\n\t\t};\n\n\t\tclass Title extends Element {\n\t\t  constructor(config) {\n\t\t    super();\n\t\t    this.chart = config.chart;\n\t\t    this.options = config.options;\n\t\t    this.ctx = config.ctx;\n\t\t    this._padding = undefined;\n\t\t    this.top = undefined;\n\t\t    this.bottom = undefined;\n\t\t    this.left = undefined;\n\t\t    this.right = undefined;\n\t\t    this.width = undefined;\n\t\t    this.height = undefined;\n\t\t    this.position = undefined;\n\t\t    this.weight = undefined;\n\t\t    this.fullSize = undefined;\n\t\t  }\n\t\t  update(maxWidth, maxHeight) {\n\t\t    const opts = this.options;\n\t\t    this.left = 0;\n\t\t    this.top = 0;\n\t\t    if (!opts.display) {\n\t\t      this.width = this.height = this.right = this.bottom = 0;\n\t\t      return;\n\t\t    }\n\t\t    this.width = this.right = maxWidth;\n\t\t    this.height = this.bottom = maxHeight;\n\t\t    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n\t\t    this._padding = toPadding(opts.padding);\n\t\t    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\t\t    if (this.isHorizontal()) {\n\t\t      this.height = textSize;\n\t\t    } else {\n\t\t      this.width = textSize;\n\t\t    }\n\t\t  }\n\t\t  isHorizontal() {\n\t\t    const pos = this.options.position;\n\t\t    return pos === 'top' || pos === 'bottom';\n\t\t  }\n\t\t  _drawArgs(offset) {\n\t\t    const {top, left, bottom, right, options} = this;\n\t\t    const align = options.align;\n\t\t    let rotation = 0;\n\t\t    let maxWidth, titleX, titleY;\n\t\t    if (this.isHorizontal()) {\n\t\t      titleX = _alignStartEnd(align, left, right);\n\t\t      titleY = top + offset;\n\t\t      maxWidth = right - left;\n\t\t    } else {\n\t\t      if (options.position === 'left') {\n\t\t        titleX = left + offset;\n\t\t        titleY = _alignStartEnd(align, bottom, top);\n\t\t        rotation = PI * -0.5;\n\t\t      } else {\n\t\t        titleX = right - offset;\n\t\t        titleY = _alignStartEnd(align, top, bottom);\n\t\t        rotation = PI * 0.5;\n\t\t      }\n\t\t      maxWidth = bottom - top;\n\t\t    }\n\t\t    return {titleX, titleY, maxWidth, rotation};\n\t\t  }\n\t\t  draw() {\n\t\t    const ctx = this.ctx;\n\t\t    const opts = this.options;\n\t\t    if (!opts.display) {\n\t\t      return;\n\t\t    }\n\t\t    const fontOpts = toFont(opts.font);\n\t\t    const lineHeight = fontOpts.lineHeight;\n\t\t    const offset = lineHeight / 2 + this._padding.top;\n\t\t    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\t\t    renderText(ctx, opts.text, 0, 0, fontOpts, {\n\t\t      color: opts.color,\n\t\t      maxWidth,\n\t\t      rotation,\n\t\t      textAlign: _toLeftRightCenter(opts.align),\n\t\t      textBaseline: 'middle',\n\t\t      translation: [titleX, titleY],\n\t\t    });\n\t\t  }\n\t\t}\n\t\tfunction createTitle(chart, titleOpts) {\n\t\t  const title = new Title({\n\t\t    ctx: chart.ctx,\n\t\t    options: titleOpts,\n\t\t    chart\n\t\t  });\n\t\t  layouts.configure(chart, title, titleOpts);\n\t\t  layouts.addBox(chart, title);\n\t\t  chart.titleBlock = title;\n\t\t}\n\t\tvar plugin_title = {\n\t\t  id: 'title',\n\t\t  _element: Title,\n\t\t  start(chart, _args, options) {\n\t\t    createTitle(chart, options);\n\t\t  },\n\t\t  stop(chart) {\n\t\t    const titleBlock = chart.titleBlock;\n\t\t    layouts.removeBox(chart, titleBlock);\n\t\t    delete chart.titleBlock;\n\t\t  },\n\t\t  beforeUpdate(chart, _args, options) {\n\t\t    const title = chart.titleBlock;\n\t\t    layouts.configure(chart, title, options);\n\t\t    title.options = options;\n\t\t  },\n\t\t  defaults: {\n\t\t    align: 'center',\n\t\t    display: false,\n\t\t    font: {\n\t\t      weight: 'bold',\n\t\t    },\n\t\t    fullSize: true,\n\t\t    padding: 10,\n\t\t    position: 'top',\n\t\t    text: '',\n\t\t    weight: 2000\n\t\t  },\n\t\t  defaultRoutes: {\n\t\t    color: 'color'\n\t\t  },\n\t\t  descriptors: {\n\t\t    _scriptable: true,\n\t\t    _indexable: false,\n\t\t  },\n\t\t};\n\n\t\tconst map = new WeakMap();\n\t\tvar plugin_subtitle = {\n\t\t  id: 'subtitle',\n\t\t  start(chart, _args, options) {\n\t\t    const title = new Title({\n\t\t      ctx: chart.ctx,\n\t\t      options,\n\t\t      chart\n\t\t    });\n\t\t    layouts.configure(chart, title, options);\n\t\t    layouts.addBox(chart, title);\n\t\t    map.set(chart, title);\n\t\t  },\n\t\t  stop(chart) {\n\t\t    layouts.removeBox(chart, map.get(chart));\n\t\t    map.delete(chart);\n\t\t  },\n\t\t  beforeUpdate(chart, _args, options) {\n\t\t    const title = map.get(chart);\n\t\t    layouts.configure(chart, title, options);\n\t\t    title.options = options;\n\t\t  },\n\t\t  defaults: {\n\t\t    align: 'center',\n\t\t    display: false,\n\t\t    font: {\n\t\t      weight: 'normal',\n\t\t    },\n\t\t    fullSize: true,\n\t\t    padding: 0,\n\t\t    position: 'top',\n\t\t    text: '',\n\t\t    weight: 1500\n\t\t  },\n\t\t  defaultRoutes: {\n\t\t    color: 'color'\n\t\t  },\n\t\t  descriptors: {\n\t\t    _scriptable: true,\n\t\t    _indexable: false,\n\t\t  },\n\t\t};\n\n\t\tconst positioners = {\n\t\t  average(items) {\n\t\t    if (!items.length) {\n\t\t      return false;\n\t\t    }\n\t\t    let i, len;\n\t\t    let x = 0;\n\t\t    let y = 0;\n\t\t    let count = 0;\n\t\t    for (i = 0, len = items.length; i < len; ++i) {\n\t\t      const el = items[i].element;\n\t\t      if (el && el.hasValue()) {\n\t\t        const pos = el.tooltipPosition();\n\t\t        x += pos.x;\n\t\t        y += pos.y;\n\t\t        ++count;\n\t\t      }\n\t\t    }\n\t\t    return {\n\t\t      x: x / count,\n\t\t      y: y / count\n\t\t    };\n\t\t  },\n\t\t  nearest(items, eventPosition) {\n\t\t    if (!items.length) {\n\t\t      return false;\n\t\t    }\n\t\t    let x = eventPosition.x;\n\t\t    let y = eventPosition.y;\n\t\t    let minDistance = Number.POSITIVE_INFINITY;\n\t\t    let i, len, nearestElement;\n\t\t    for (i = 0, len = items.length; i < len; ++i) {\n\t\t      const el = items[i].element;\n\t\t      if (el && el.hasValue()) {\n\t\t        const center = el.getCenterPoint();\n\t\t        const d = distanceBetweenPoints(eventPosition, center);\n\t\t        if (d < minDistance) {\n\t\t          minDistance = d;\n\t\t          nearestElement = el;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    if (nearestElement) {\n\t\t      const tp = nearestElement.tooltipPosition();\n\t\t      x = tp.x;\n\t\t      y = tp.y;\n\t\t    }\n\t\t    return {\n\t\t      x,\n\t\t      y\n\t\t    };\n\t\t  }\n\t\t};\n\t\tfunction pushOrConcat(base, toPush) {\n\t\t  if (toPush) {\n\t\t    if (isArray(toPush)) {\n\t\t      Array.prototype.push.apply(base, toPush);\n\t\t    } else {\n\t\t      base.push(toPush);\n\t\t    }\n\t\t  }\n\t\t  return base;\n\t\t}\n\t\tfunction splitNewlines(str) {\n\t\t  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n\t\t    return str.split('\\n');\n\t\t  }\n\t\t  return str;\n\t\t}\n\t\tfunction createTooltipItem(chart, item) {\n\t\t  const {element, datasetIndex, index} = item;\n\t\t  const controller = chart.getDatasetMeta(datasetIndex).controller;\n\t\t  const {label, value} = controller.getLabelAndValue(index);\n\t\t  return {\n\t\t    chart,\n\t\t    label,\n\t\t    parsed: controller.getParsed(index),\n\t\t    raw: chart.data.datasets[datasetIndex].data[index],\n\t\t    formattedValue: value,\n\t\t    dataset: controller.getDataset(),\n\t\t    dataIndex: index,\n\t\t    datasetIndex,\n\t\t    element\n\t\t  };\n\t\t}\n\t\tfunction getTooltipSize(tooltip, options) {\n\t\t  const ctx = tooltip.chart.ctx;\n\t\t  const {body, footer, title} = tooltip;\n\t\t  const {boxWidth, boxHeight} = options;\n\t\t  const bodyFont = toFont(options.bodyFont);\n\t\t  const titleFont = toFont(options.titleFont);\n\t\t  const footerFont = toFont(options.footerFont);\n\t\t  const titleLineCount = title.length;\n\t\t  const footerLineCount = footer.length;\n\t\t  const bodyLineItemCount = body.length;\n\t\t  const padding = toPadding(options.padding);\n\t\t  let height = padding.height;\n\t\t  let width = 0;\n\t\t  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n\t\t  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\t\t  if (titleLineCount) {\n\t\t    height += titleLineCount * titleFont.lineHeight\n\t\t\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t\t\t+ options.titleMarginBottom;\n\t\t  }\n\t\t  if (combinedBodyLength) {\n\t\t    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n\t\t    height += bodyLineItemCount * bodyLineHeight\n\t\t\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n\t\t  }\n\t\t  if (footerLineCount) {\n\t\t    height += options.footerMarginTop\n\t\t\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n\t\t  }\n\t\t  let widthPadding = 0;\n\t\t  const maxLineWidth = function(line) {\n\t\t    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t  };\n\t\t  ctx.save();\n\t\t  ctx.font = titleFont.string;\n\t\t  each(tooltip.title, maxLineWidth);\n\t\t  ctx.font = bodyFont.string;\n\t\t  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\t\t  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n\t\t  each(body, (bodyItem) => {\n\t\t    each(bodyItem.before, maxLineWidth);\n\t\t    each(bodyItem.lines, maxLineWidth);\n\t\t    each(bodyItem.after, maxLineWidth);\n\t\t  });\n\t\t  widthPadding = 0;\n\t\t  ctx.font = footerFont.string;\n\t\t  each(tooltip.footer, maxLineWidth);\n\t\t  ctx.restore();\n\t\t  width += padding.width;\n\t\t  return {width, height};\n\t\t}\n\t\tfunction determineYAlign(chart, size) {\n\t\t  const {y, height} = size;\n\t\t  if (y < height / 2) {\n\t\t    return 'top';\n\t\t  } else if (y > (chart.height - height / 2)) {\n\t\t    return 'bottom';\n\t\t  }\n\t\t  return 'center';\n\t\t}\n\t\tfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n\t\t  const {x, width} = size;\n\t\t  const caret = options.caretSize + options.caretPadding;\n\t\t  if (xAlign === 'left' && x + width + caret > chart.width) {\n\t\t    return true;\n\t\t  }\n\t\t  if (xAlign === 'right' && x - width - caret < 0) {\n\t\t    return true;\n\t\t  }\n\t\t}\n\t\tfunction determineXAlign(chart, options, size, yAlign) {\n\t\t  const {x, width} = size;\n\t\t  const {width: chartWidth, chartArea: {left, right}} = chart;\n\t\t  let xAlign = 'center';\n\t\t  if (yAlign === 'center') {\n\t\t    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n\t\t  } else if (x <= width / 2) {\n\t\t    xAlign = 'left';\n\t\t  } else if (x >= chartWidth - width / 2) {\n\t\t    xAlign = 'right';\n\t\t  }\n\t\t  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n\t\t    xAlign = 'center';\n\t\t  }\n\t\t  return xAlign;\n\t\t}\n\t\tfunction determineAlignment(chart, options, size) {\n\t\t  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\t\t  return {\n\t\t    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n\t\t    yAlign\n\t\t  };\n\t\t}\n\t\tfunction alignX(size, xAlign) {\n\t\t  let {x, width} = size;\n\t\t  if (xAlign === 'right') {\n\t\t    x -= width;\n\t\t  } else if (xAlign === 'center') {\n\t\t    x -= (width / 2);\n\t\t  }\n\t\t  return x;\n\t\t}\n\t\tfunction alignY(size, yAlign, paddingAndSize) {\n\t\t  let {y, height} = size;\n\t\t  if (yAlign === 'top') {\n\t\t    y += paddingAndSize;\n\t\t  } else if (yAlign === 'bottom') {\n\t\t    y -= height + paddingAndSize;\n\t\t  } else {\n\t\t    y -= (height / 2);\n\t\t  }\n\t\t  return y;\n\t\t}\n\t\tfunction getBackgroundPoint(options, size, alignment, chart) {\n\t\t  const {caretSize, caretPadding, cornerRadius} = options;\n\t\t  const {xAlign, yAlign} = alignment;\n\t\t  const paddingAndSize = caretSize + caretPadding;\n\t\t  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\t\t  let x = alignX(size, xAlign);\n\t\t  const y = alignY(size, yAlign, paddingAndSize);\n\t\t  if (yAlign === 'center') {\n\t\t    if (xAlign === 'left') {\n\t\t      x += paddingAndSize;\n\t\t    } else if (xAlign === 'right') {\n\t\t      x -= paddingAndSize;\n\t\t    }\n\t\t  } else if (xAlign === 'left') {\n\t\t    x -= Math.max(topLeft, bottomLeft) + caretSize;\n\t\t  } else if (xAlign === 'right') {\n\t\t    x += Math.max(topRight, bottomRight) + caretSize;\n\t\t  }\n\t\t  return {\n\t\t    x: _limitValue(x, 0, chart.width - size.width),\n\t\t    y: _limitValue(y, 0, chart.height - size.height)\n\t\t  };\n\t\t}\n\t\tfunction getAlignedX(tooltip, align, options) {\n\t\t  const padding = toPadding(options.padding);\n\t\t  return align === 'center'\n\t\t    ? tooltip.x + tooltip.width / 2\n\t\t    : align === 'right'\n\t\t      ? tooltip.x + tooltip.width - padding.right\n\t\t      : tooltip.x + padding.left;\n\t\t}\n\t\tfunction getBeforeAfterBodyLines(callback) {\n\t\t  return pushOrConcat([], splitNewlines(callback));\n\t\t}\n\t\tfunction createTooltipContext(parent, tooltip, tooltipItems) {\n\t\t  return createContext(parent, {\n\t\t    tooltip,\n\t\t    tooltipItems,\n\t\t    type: 'tooltip'\n\t\t  });\n\t\t}\n\t\tfunction overrideCallbacks(callbacks, context) {\n\t\t  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n\t\t  return override ? callbacks.override(override) : callbacks;\n\t\t}\n\t\tclass Tooltip extends Element {\n\t\t  constructor(config) {\n\t\t    super();\n\t\t    this.opacity = 0;\n\t\t    this._active = [];\n\t\t    this._eventPosition = undefined;\n\t\t    this._size = undefined;\n\t\t    this._cachedAnimations = undefined;\n\t\t    this._tooltipItems = [];\n\t\t    this.$animations = undefined;\n\t\t    this.$context = undefined;\n\t\t    this.chart = config.chart || config._chart;\n\t\t    this._chart = this.chart;\n\t\t    this.options = config.options;\n\t\t    this.dataPoints = undefined;\n\t\t    this.title = undefined;\n\t\t    this.beforeBody = undefined;\n\t\t    this.body = undefined;\n\t\t    this.afterBody = undefined;\n\t\t    this.footer = undefined;\n\t\t    this.xAlign = undefined;\n\t\t    this.yAlign = undefined;\n\t\t    this.x = undefined;\n\t\t    this.y = undefined;\n\t\t    this.height = undefined;\n\t\t    this.width = undefined;\n\t\t    this.caretX = undefined;\n\t\t    this.caretY = undefined;\n\t\t    this.labelColors = undefined;\n\t\t    this.labelPointStyles = undefined;\n\t\t    this.labelTextColors = undefined;\n\t\t  }\n\t\t  initialize(options) {\n\t\t    this.options = options;\n\t\t    this._cachedAnimations = undefined;\n\t\t    this.$context = undefined;\n\t\t  }\n\t\t  _resolveAnimations() {\n\t\t    const cached = this._cachedAnimations;\n\t\t    if (cached) {\n\t\t      return cached;\n\t\t    }\n\t\t    const chart = this.chart;\n\t\t    const options = this.options.setContext(this.getContext());\n\t\t    const opts = options.enabled && chart.options.animation && options.animations;\n\t\t    const animations = new Animations(this.chart, opts);\n\t\t    if (opts._cacheable) {\n\t\t      this._cachedAnimations = Object.freeze(animations);\n\t\t    }\n\t\t    return animations;\n\t\t  }\n\t\t  getContext() {\n\t\t    return this.$context ||\n\t\t\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n\t\t  }\n\t\t  getTitle(context, options) {\n\t\t    const {callbacks} = options;\n\t\t    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n\t\t    const title = callbacks.title.apply(this, [context]);\n\t\t    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n\t\t    let lines = [];\n\t\t    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n\t\t    lines = pushOrConcat(lines, splitNewlines(title));\n\t\t    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\t\t    return lines;\n\t\t  }\n\t\t  getBeforeBody(tooltipItems, options) {\n\t\t    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n\t\t  }\n\t\t  getBody(tooltipItems, options) {\n\t\t    const {callbacks} = options;\n\t\t    const bodyItems = [];\n\t\t    each(tooltipItems, (context) => {\n\t\t      const bodyItem = {\n\t\t        before: [],\n\t\t        lines: [],\n\t\t        after: []\n\t\t      };\n\t\t      const scoped = overrideCallbacks(callbacks, context);\n\t\t      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n\t\t      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n\t\t      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n\t\t      bodyItems.push(bodyItem);\n\t\t    });\n\t\t    return bodyItems;\n\t\t  }\n\t\t  getAfterBody(tooltipItems, options) {\n\t\t    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n\t\t  }\n\t\t  getFooter(tooltipItems, options) {\n\t\t    const {callbacks} = options;\n\t\t    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n\t\t    const footer = callbacks.footer.apply(this, [tooltipItems]);\n\t\t    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n\t\t    let lines = [];\n\t\t    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n\t\t    lines = pushOrConcat(lines, splitNewlines(footer));\n\t\t    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\t\t    return lines;\n\t\t  }\n\t\t  _createItems(options) {\n\t\t    const active = this._active;\n\t\t    const data = this.chart.data;\n\t\t    const labelColors = [];\n\t\t    const labelPointStyles = [];\n\t\t    const labelTextColors = [];\n\t\t    let tooltipItems = [];\n\t\t    let i, len;\n\t\t    for (i = 0, len = active.length; i < len; ++i) {\n\t\t      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n\t\t    }\n\t\t    if (options.filter) {\n\t\t      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n\t\t    }\n\t\t    if (options.itemSort) {\n\t\t      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n\t\t    }\n\t\t    each(tooltipItems, (context) => {\n\t\t      const scoped = overrideCallbacks(options.callbacks, context);\n\t\t      labelColors.push(scoped.labelColor.call(this, context));\n\t\t      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n\t\t      labelTextColors.push(scoped.labelTextColor.call(this, context));\n\t\t    });\n\t\t    this.labelColors = labelColors;\n\t\t    this.labelPointStyles = labelPointStyles;\n\t\t    this.labelTextColors = labelTextColors;\n\t\t    this.dataPoints = tooltipItems;\n\t\t    return tooltipItems;\n\t\t  }\n\t\t  update(changed, replay) {\n\t\t    const options = this.options.setContext(this.getContext());\n\t\t    const active = this._active;\n\t\t    let properties;\n\t\t    let tooltipItems = [];\n\t\t    if (!active.length) {\n\t\t      if (this.opacity !== 0) {\n\t\t        properties = {\n\t\t          opacity: 0\n\t\t        };\n\t\t      }\n\t\t    } else {\n\t\t      const position = positioners[options.position].call(this, active, this._eventPosition);\n\t\t      tooltipItems = this._createItems(options);\n\t\t      this.title = this.getTitle(tooltipItems, options);\n\t\t      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n\t\t      this.body = this.getBody(tooltipItems, options);\n\t\t      this.afterBody = this.getAfterBody(tooltipItems, options);\n\t\t      this.footer = this.getFooter(tooltipItems, options);\n\t\t      const size = this._size = getTooltipSize(this, options);\n\t\t      const positionAndSize = Object.assign({}, position, size);\n\t\t      const alignment = determineAlignment(this.chart, options, positionAndSize);\n\t\t      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\t\t      this.xAlign = alignment.xAlign;\n\t\t      this.yAlign = alignment.yAlign;\n\t\t      properties = {\n\t\t        opacity: 1,\n\t\t        x: backgroundPoint.x,\n\t\t        y: backgroundPoint.y,\n\t\t        width: size.width,\n\t\t        height: size.height,\n\t\t        caretX: position.x,\n\t\t        caretY: position.y\n\t\t      };\n\t\t    }\n\t\t    this._tooltipItems = tooltipItems;\n\t\t    this.$context = undefined;\n\t\t    if (properties) {\n\t\t      this._resolveAnimations().update(this, properties);\n\t\t    }\n\t\t    if (changed && options.external) {\n\t\t      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n\t\t    }\n\t\t  }\n\t\t  drawCaret(tooltipPoint, ctx, size, options) {\n\t\t    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\t\t    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t  }\n\t\t  getCaretPosition(tooltipPoint, size, options) {\n\t\t    const {xAlign, yAlign} = this;\n\t\t    const {caretSize, cornerRadius} = options;\n\t\t    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\t\t    const {x: ptX, y: ptY} = tooltipPoint;\n\t\t    const {width, height} = size;\n\t\t    let x1, x2, x3, y1, y2, y3;\n\t\t    if (yAlign === 'center') {\n\t\t      y2 = ptY + (height / 2);\n\t\t      if (xAlign === 'left') {\n\t\t        x1 = ptX;\n\t\t        x2 = x1 - caretSize;\n\t\t        y1 = y2 + caretSize;\n\t\t        y3 = y2 - caretSize;\n\t\t      } else {\n\t\t        x1 = ptX + width;\n\t\t        x2 = x1 + caretSize;\n\t\t        y1 = y2 - caretSize;\n\t\t        y3 = y2 + caretSize;\n\t\t      }\n\t\t      x3 = x1;\n\t\t    } else {\n\t\t      if (xAlign === 'left') {\n\t\t        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n\t\t      } else if (xAlign === 'right') {\n\t\t        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n\t\t      } else {\n\t\t        x2 = this.caretX;\n\t\t      }\n\t\t      if (yAlign === 'top') {\n\t\t        y1 = ptY;\n\t\t        y2 = y1 - caretSize;\n\t\t        x1 = x2 - caretSize;\n\t\t        x3 = x2 + caretSize;\n\t\t      } else {\n\t\t        y1 = ptY + height;\n\t\t        y2 = y1 + caretSize;\n\t\t        x1 = x2 + caretSize;\n\t\t        x3 = x2 - caretSize;\n\t\t      }\n\t\t      y3 = y1;\n\t\t    }\n\t\t    return {x1, x2, x3, y1, y2, y3};\n\t\t  }\n\t\t  drawTitle(pt, ctx, options) {\n\t\t    const title = this.title;\n\t\t    const length = title.length;\n\t\t    let titleFont, titleSpacing, i;\n\t\t    if (length) {\n\t\t      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\t\t      pt.x = getAlignedX(this, options.titleAlign, options);\n\t\t      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n\t\t      ctx.textBaseline = 'middle';\n\t\t      titleFont = toFont(options.titleFont);\n\t\t      titleSpacing = options.titleSpacing;\n\t\t      ctx.fillStyle = options.titleColor;\n\t\t      ctx.font = titleFont.string;\n\t\t      for (i = 0; i < length; ++i) {\n\t\t        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n\t\t        pt.y += titleFont.lineHeight + titleSpacing;\n\t\t        if (i + 1 === length) {\n\t\t          pt.y += options.titleMarginBottom - titleSpacing;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n\t\t    const labelColors = this.labelColors[i];\n\t\t    const labelPointStyle = this.labelPointStyles[i];\n\t\t    const {boxHeight, boxWidth, boxPadding} = options;\n\t\t    const bodyFont = toFont(options.bodyFont);\n\t\t    const colorX = getAlignedX(this, 'left', options);\n\t\t    const rtlColorX = rtlHelper.x(colorX);\n\t\t    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n\t\t    const colorY = pt.y + yOffSet;\n\t\t    if (options.usePointStyle) {\n\t\t      const drawOptions = {\n\t\t        radius: Math.min(boxWidth, boxHeight) / 2,\n\t\t        pointStyle: labelPointStyle.pointStyle,\n\t\t        rotation: labelPointStyle.rotation,\n\t\t        borderWidth: 1\n\t\t      };\n\t\t      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n\t\t      const centerY = colorY + boxHeight / 2;\n\t\t      ctx.strokeStyle = options.multiKeyBackground;\n\t\t      ctx.fillStyle = options.multiKeyBackground;\n\t\t      drawPoint(ctx, drawOptions, centerX, centerY);\n\t\t      ctx.strokeStyle = labelColors.borderColor;\n\t\t      ctx.fillStyle = labelColors.backgroundColor;\n\t\t      drawPoint(ctx, drawOptions, centerX, centerY);\n\t\t    } else {\n\t\t      ctx.lineWidth = labelColors.borderWidth || 1;\n\t\t      ctx.strokeStyle = labelColors.borderColor;\n\t\t      ctx.setLineDash(labelColors.borderDash || []);\n\t\t      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n\t\t      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n\t\t      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n\t\t      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n\t\t      if (Object.values(borderRadius).some(v => v !== 0)) {\n\t\t        ctx.beginPath();\n\t\t        ctx.fillStyle = options.multiKeyBackground;\n\t\t        addRoundedRectPath(ctx, {\n\t\t          x: outerX,\n\t\t          y: colorY,\n\t\t          w: boxWidth,\n\t\t          h: boxHeight,\n\t\t          radius: borderRadius,\n\t\t        });\n\t\t        ctx.fill();\n\t\t        ctx.stroke();\n\t\t        ctx.fillStyle = labelColors.backgroundColor;\n\t\t        ctx.beginPath();\n\t\t        addRoundedRectPath(ctx, {\n\t\t          x: innerX,\n\t\t          y: colorY + 1,\n\t\t          w: boxWidth - 2,\n\t\t          h: boxHeight - 2,\n\t\t          radius: borderRadius,\n\t\t        });\n\t\t        ctx.fill();\n\t\t      } else {\n\t\t        ctx.fillStyle = options.multiKeyBackground;\n\t\t        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n\t\t        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n\t\t        ctx.fillStyle = labelColors.backgroundColor;\n\t\t        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n\t\t      }\n\t\t    }\n\t\t    ctx.fillStyle = this.labelTextColors[i];\n\t\t  }\n\t\t  drawBody(pt, ctx, options) {\n\t\t    const {body} = this;\n\t\t    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n\t\t    const bodyFont = toFont(options.bodyFont);\n\t\t    let bodyLineHeight = bodyFont.lineHeight;\n\t\t    let xLinePadding = 0;\n\t\t    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\t\t    const fillLineOfText = function(line) {\n\t\t      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n\t\t      pt.y += bodyLineHeight + bodySpacing;\n\t\t    };\n\t\t    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n\t\t    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\t\t    ctx.textAlign = bodyAlign;\n\t\t    ctx.textBaseline = 'middle';\n\t\t    ctx.font = bodyFont.string;\n\t\t    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\t\t    ctx.fillStyle = options.bodyColor;\n\t\t    each(this.beforeBody, fillLineOfText);\n\t\t    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n\t\t      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n\t\t      : 0;\n\t\t    for (i = 0, ilen = body.length; i < ilen; ++i) {\n\t\t      bodyItem = body[i];\n\t\t      textColor = this.labelTextColors[i];\n\t\t      ctx.fillStyle = textColor;\n\t\t      each(bodyItem.before, fillLineOfText);\n\t\t      lines = bodyItem.lines;\n\t\t      if (displayColors && lines.length) {\n\t\t        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n\t\t        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n\t\t      }\n\t\t      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n\t\t        fillLineOfText(lines[j]);\n\t\t        bodyLineHeight = bodyFont.lineHeight;\n\t\t      }\n\t\t      each(bodyItem.after, fillLineOfText);\n\t\t    }\n\t\t    xLinePadding = 0;\n\t\t    bodyLineHeight = bodyFont.lineHeight;\n\t\t    each(this.afterBody, fillLineOfText);\n\t\t    pt.y -= bodySpacing;\n\t\t  }\n\t\t  drawFooter(pt, ctx, options) {\n\t\t    const footer = this.footer;\n\t\t    const length = footer.length;\n\t\t    let footerFont, i;\n\t\t    if (length) {\n\t\t      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\t\t      pt.x = getAlignedX(this, options.footerAlign, options);\n\t\t      pt.y += options.footerMarginTop;\n\t\t      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n\t\t      ctx.textBaseline = 'middle';\n\t\t      footerFont = toFont(options.footerFont);\n\t\t      ctx.fillStyle = options.footerColor;\n\t\t      ctx.font = footerFont.string;\n\t\t      for (i = 0; i < length; ++i) {\n\t\t        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n\t\t        pt.y += footerFont.lineHeight + options.footerSpacing;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  drawBackground(pt, ctx, tooltipSize, options) {\n\t\t    const {xAlign, yAlign} = this;\n\t\t    const {x, y} = pt;\n\t\t    const {width, height} = tooltipSize;\n\t\t    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\t\t    ctx.fillStyle = options.backgroundColor;\n\t\t    ctx.strokeStyle = options.borderColor;\n\t\t    ctx.lineWidth = options.borderWidth;\n\t\t    ctx.beginPath();\n\t\t    ctx.moveTo(x + topLeft, y);\n\t\t    if (yAlign === 'top') {\n\t\t      this.drawCaret(pt, ctx, tooltipSize, options);\n\t\t    }\n\t\t    ctx.lineTo(x + width - topRight, y);\n\t\t    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n\t\t    if (yAlign === 'center' && xAlign === 'right') {\n\t\t      this.drawCaret(pt, ctx, tooltipSize, options);\n\t\t    }\n\t\t    ctx.lineTo(x + width, y + height - bottomRight);\n\t\t    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n\t\t    if (yAlign === 'bottom') {\n\t\t      this.drawCaret(pt, ctx, tooltipSize, options);\n\t\t    }\n\t\t    ctx.lineTo(x + bottomLeft, y + height);\n\t\t    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n\t\t    if (yAlign === 'center' && xAlign === 'left') {\n\t\t      this.drawCaret(pt, ctx, tooltipSize, options);\n\t\t    }\n\t\t    ctx.lineTo(x, y + topLeft);\n\t\t    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n\t\t    ctx.closePath();\n\t\t    ctx.fill();\n\t\t    if (options.borderWidth > 0) {\n\t\t      ctx.stroke();\n\t\t    }\n\t\t  }\n\t\t  _updateAnimationTarget(options) {\n\t\t    const chart = this.chart;\n\t\t    const anims = this.$animations;\n\t\t    const animX = anims && anims.x;\n\t\t    const animY = anims && anims.y;\n\t\t    if (animX || animY) {\n\t\t      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n\t\t      if (!position) {\n\t\t        return;\n\t\t      }\n\t\t      const size = this._size = getTooltipSize(this, options);\n\t\t      const positionAndSize = Object.assign({}, position, this._size);\n\t\t      const alignment = determineAlignment(chart, options, positionAndSize);\n\t\t      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n\t\t      if (animX._to !== point.x || animY._to !== point.y) {\n\t\t        this.xAlign = alignment.xAlign;\n\t\t        this.yAlign = alignment.yAlign;\n\t\t        this.width = size.width;\n\t\t        this.height = size.height;\n\t\t        this.caretX = position.x;\n\t\t        this.caretY = position.y;\n\t\t        this._resolveAnimations().update(this, point);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  draw(ctx) {\n\t\t    const options = this.options.setContext(this.getContext());\n\t\t    let opacity = this.opacity;\n\t\t    if (!opacity) {\n\t\t      return;\n\t\t    }\n\t\t    this._updateAnimationTarget(options);\n\t\t    const tooltipSize = {\n\t\t      width: this.width,\n\t\t      height: this.height\n\t\t    };\n\t\t    const pt = {\n\t\t      x: this.x,\n\t\t      y: this.y\n\t\t    };\n\t\t    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\t\t    const padding = toPadding(options.padding);\n\t\t    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\t\t    if (options.enabled && hasTooltipContent) {\n\t\t      ctx.save();\n\t\t      ctx.globalAlpha = opacity;\n\t\t      this.drawBackground(pt, ctx, tooltipSize, options);\n\t\t      overrideTextDirection(ctx, options.textDirection);\n\t\t      pt.y += padding.top;\n\t\t      this.drawTitle(pt, ctx, options);\n\t\t      this.drawBody(pt, ctx, options);\n\t\t      this.drawFooter(pt, ctx, options);\n\t\t      restoreTextDirection(ctx, options.textDirection);\n\t\t      ctx.restore();\n\t\t    }\n\t\t  }\n\t\t  getActiveElements() {\n\t\t    return this._active || [];\n\t\t  }\n\t\t  setActiveElements(activeElements, eventPosition) {\n\t\t    const lastActive = this._active;\n\t\t    const active = activeElements.map(({datasetIndex, index}) => {\n\t\t      const meta = this.chart.getDatasetMeta(datasetIndex);\n\t\t      if (!meta) {\n\t\t        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n\t\t      }\n\t\t      return {\n\t\t        datasetIndex,\n\t\t        element: meta.data[index],\n\t\t        index,\n\t\t      };\n\t\t    });\n\t\t    const changed = !_elementsEqual(lastActive, active);\n\t\t    const positionChanged = this._positionChanged(active, eventPosition);\n\t\t    if (changed || positionChanged) {\n\t\t      this._active = active;\n\t\t      this._eventPosition = eventPosition;\n\t\t      this._ignoreReplayEvents = true;\n\t\t      this.update(true);\n\t\t    }\n\t\t  }\n\t\t  handleEvent(e, replay, inChartArea = true) {\n\t\t    if (replay && this._ignoreReplayEvents) {\n\t\t      return false;\n\t\t    }\n\t\t    this._ignoreReplayEvents = false;\n\t\t    const options = this.options;\n\t\t    const lastActive = this._active || [];\n\t\t    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\t\t    const positionChanged = this._positionChanged(active, e);\n\t\t    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\t\t    if (changed) {\n\t\t      this._active = active;\n\t\t      if (options.enabled || options.external) {\n\t\t        this._eventPosition = {\n\t\t          x: e.x,\n\t\t          y: e.y\n\t\t        };\n\t\t        this.update(true, replay);\n\t\t      }\n\t\t    }\n\t\t    return changed;\n\t\t  }\n\t\t  _getActiveElements(e, lastActive, replay, inChartArea) {\n\t\t    const options = this.options;\n\t\t    if (e.type === 'mouseout') {\n\t\t      return [];\n\t\t    }\n\t\t    if (!inChartArea) {\n\t\t      return lastActive;\n\t\t    }\n\t\t    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\t\t    if (options.reverse) {\n\t\t      active.reverse();\n\t\t    }\n\t\t    return active;\n\t\t  }\n\t\t  _positionChanged(active, e) {\n\t\t    const {caretX, caretY, options} = this;\n\t\t    const position = positioners[options.position].call(this, active, e);\n\t\t    return position !== false && (caretX !== position.x || caretY !== position.y);\n\t\t  }\n\t\t}\n\t\tTooltip.positioners = positioners;\n\t\tvar plugin_tooltip = {\n\t\t  id: 'tooltip',\n\t\t  _element: Tooltip,\n\t\t  positioners,\n\t\t  afterInit(chart, _args, options) {\n\t\t    if (options) {\n\t\t      chart.tooltip = new Tooltip({chart, options});\n\t\t    }\n\t\t  },\n\t\t  beforeUpdate(chart, _args, options) {\n\t\t    if (chart.tooltip) {\n\t\t      chart.tooltip.initialize(options);\n\t\t    }\n\t\t  },\n\t\t  reset(chart, _args, options) {\n\t\t    if (chart.tooltip) {\n\t\t      chart.tooltip.initialize(options);\n\t\t    }\n\t\t  },\n\t\t  afterDraw(chart) {\n\t\t    const tooltip = chart.tooltip;\n\t\t    const args = {\n\t\t      tooltip\n\t\t    };\n\t\t    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n\t\t      return;\n\t\t    }\n\t\t    if (tooltip) {\n\t\t      tooltip.draw(chart.ctx);\n\t\t    }\n\t\t    chart.notifyPlugins('afterTooltipDraw', args);\n\t\t  },\n\t\t  afterEvent(chart, args) {\n\t\t    if (chart.tooltip) {\n\t\t      const useFinalPosition = args.replay;\n\t\t      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n\t\t        args.changed = true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  defaults: {\n\t\t    enabled: true,\n\t\t    external: null,\n\t\t    position: 'average',\n\t\t    backgroundColor: 'rgba(0,0,0,0.8)',\n\t\t    titleColor: '#fff',\n\t\t    titleFont: {\n\t\t      weight: 'bold',\n\t\t    },\n\t\t    titleSpacing: 2,\n\t\t    titleMarginBottom: 6,\n\t\t    titleAlign: 'left',\n\t\t    bodyColor: '#fff',\n\t\t    bodySpacing: 2,\n\t\t    bodyFont: {\n\t\t    },\n\t\t    bodyAlign: 'left',\n\t\t    footerColor: '#fff',\n\t\t    footerSpacing: 2,\n\t\t    footerMarginTop: 6,\n\t\t    footerFont: {\n\t\t      weight: 'bold',\n\t\t    },\n\t\t    footerAlign: 'left',\n\t\t    padding: 6,\n\t\t    caretPadding: 2,\n\t\t    caretSize: 5,\n\t\t    cornerRadius: 6,\n\t\t    boxHeight: (ctx, opts) => opts.bodyFont.size,\n\t\t    boxWidth: (ctx, opts) => opts.bodyFont.size,\n\t\t    multiKeyBackground: '#fff',\n\t\t    displayColors: true,\n\t\t    boxPadding: 0,\n\t\t    borderColor: 'rgba(0,0,0,0)',\n\t\t    borderWidth: 0,\n\t\t    animation: {\n\t\t      duration: 400,\n\t\t      easing: 'easeOutQuart',\n\t\t    },\n\t\t    animations: {\n\t\t      numbers: {\n\t\t        type: 'number',\n\t\t        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n\t\t      },\n\t\t      opacity: {\n\t\t        easing: 'linear',\n\t\t        duration: 200\n\t\t      }\n\t\t    },\n\t\t    callbacks: {\n\t\t      beforeTitle: noop,\n\t\t      title(tooltipItems) {\n\t\t        if (tooltipItems.length > 0) {\n\t\t          const item = tooltipItems[0];\n\t\t          const labels = item.chart.data.labels;\n\t\t          const labelCount = labels ? labels.length : 0;\n\t\t          if (this && this.options && this.options.mode === 'dataset') {\n\t\t            return item.dataset.label || '';\n\t\t          } else if (item.label) {\n\t\t            return item.label;\n\t\t          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n\t\t            return labels[item.dataIndex];\n\t\t          }\n\t\t        }\n\t\t        return '';\n\t\t      },\n\t\t      afterTitle: noop,\n\t\t      beforeBody: noop,\n\t\t      beforeLabel: noop,\n\t\t      label(tooltipItem) {\n\t\t        if (this && this.options && this.options.mode === 'dataset') {\n\t\t          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n\t\t        }\n\t\t        let label = tooltipItem.dataset.label || '';\n\t\t        if (label) {\n\t\t          label += ': ';\n\t\t        }\n\t\t        const value = tooltipItem.formattedValue;\n\t\t        if (!isNullOrUndef(value)) {\n\t\t          label += value;\n\t\t        }\n\t\t        return label;\n\t\t      },\n\t\t      labelColor(tooltipItem) {\n\t\t        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n\t\t        return {\n\t\t          borderColor: options.borderColor,\n\t\t          backgroundColor: options.backgroundColor,\n\t\t          borderWidth: options.borderWidth,\n\t\t          borderDash: options.borderDash,\n\t\t          borderDashOffset: options.borderDashOffset,\n\t\t          borderRadius: 0,\n\t\t        };\n\t\t      },\n\t\t      labelTextColor() {\n\t\t        return this.options.bodyColor;\n\t\t      },\n\t\t      labelPointStyle(tooltipItem) {\n\t\t        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n\t\t        return {\n\t\t          pointStyle: options.pointStyle,\n\t\t          rotation: options.rotation,\n\t\t        };\n\t\t      },\n\t\t      afterLabel: noop,\n\t\t      afterBody: noop,\n\t\t      beforeFooter: noop,\n\t\t      footer: noop,\n\t\t      afterFooter: noop\n\t\t    }\n\t\t  },\n\t\t  defaultRoutes: {\n\t\t    bodyFont: 'font',\n\t\t    footerFont: 'font',\n\t\t    titleFont: 'font'\n\t\t  },\n\t\t  descriptors: {\n\t\t    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n\t\t    _indexable: false,\n\t\t    callbacks: {\n\t\t      _scriptable: false,\n\t\t      _indexable: false,\n\t\t    },\n\t\t    animation: {\n\t\t      _fallback: false\n\t\t    },\n\t\t    animations: {\n\t\t      _fallback: 'animation'\n\t\t    }\n\t\t  },\n\t\t  additionalOptionScopes: ['interaction']\n\t\t};\n\n\t\tvar plugins = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tDecimation: plugin_decimation,\n\t\tFiller: plugin_filler,\n\t\tLegend: plugin_legend,\n\t\tSubTitle: plugin_subtitle,\n\t\tTitle: plugin_title,\n\t\tTooltip: plugin_tooltip\n\t\t});\n\n\t\tconst addIfString = (labels, raw, index, addedLabels) => {\n\t\t  if (typeof raw === 'string') {\n\t\t    index = labels.push(raw) - 1;\n\t\t    addedLabels.unshift({index, label: raw});\n\t\t  } else if (isNaN(raw)) {\n\t\t    index = null;\n\t\t  }\n\t\t  return index;\n\t\t};\n\t\tfunction findOrAddLabel(labels, raw, index, addedLabels) {\n\t\t  const first = labels.indexOf(raw);\n\t\t  if (first === -1) {\n\t\t    return addIfString(labels, raw, index, addedLabels);\n\t\t  }\n\t\t  const last = labels.lastIndexOf(raw);\n\t\t  return first !== last ? index : first;\n\t\t}\n\t\tconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\t\tclass CategoryScale extends Scale {\n\t\t  constructor(cfg) {\n\t\t    super(cfg);\n\t\t    this._startValue = undefined;\n\t\t    this._valueRange = 0;\n\t\t    this._addedLabels = [];\n\t\t  }\n\t\t  init(scaleOptions) {\n\t\t    const added = this._addedLabels;\n\t\t    if (added.length) {\n\t\t      const labels = this.getLabels();\n\t\t      for (const {index, label} of added) {\n\t\t        if (labels[index] === label) {\n\t\t          labels.splice(index, 1);\n\t\t        }\n\t\t      }\n\t\t      this._addedLabels = [];\n\t\t    }\n\t\t    super.init(scaleOptions);\n\t\t  }\n\t\t  parse(raw, index) {\n\t\t    if (isNullOrUndef(raw)) {\n\t\t      return null;\n\t\t    }\n\t\t    const labels = this.getLabels();\n\t\t    index = isFinite(index) && labels[index] === raw ? index\n\t\t      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n\t\t    return validIndex(index, labels.length - 1);\n\t\t  }\n\t\t  determineDataLimits() {\n\t\t    const {minDefined, maxDefined} = this.getUserBounds();\n\t\t    let {min, max} = this.getMinMax(true);\n\t\t    if (this.options.bounds === 'ticks') {\n\t\t      if (!minDefined) {\n\t\t        min = 0;\n\t\t      }\n\t\t      if (!maxDefined) {\n\t\t        max = this.getLabels().length - 1;\n\t\t      }\n\t\t    }\n\t\t    this.min = min;\n\t\t    this.max = max;\n\t\t  }\n\t\t  buildTicks() {\n\t\t    const min = this.min;\n\t\t    const max = this.max;\n\t\t    const offset = this.options.offset;\n\t\t    const ticks = [];\n\t\t    let labels = this.getLabels();\n\t\t    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\t\t    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n\t\t    this._startValue = this.min - (offset ? 0.5 : 0);\n\t\t    for (let value = min; value <= max; value++) {\n\t\t      ticks.push({value});\n\t\t    }\n\t\t    return ticks;\n\t\t  }\n\t\t  getLabelForValue(value) {\n\t\t    const labels = this.getLabels();\n\t\t    if (value >= 0 && value < labels.length) {\n\t\t      return labels[value];\n\t\t    }\n\t\t    return value;\n\t\t  }\n\t\t  configure() {\n\t\t    super.configure();\n\t\t    if (!this.isHorizontal()) {\n\t\t      this._reversePixels = !this._reversePixels;\n\t\t    }\n\t\t  }\n\t\t  getPixelForValue(value) {\n\t\t    if (typeof value !== 'number') {\n\t\t      value = this.parse(value);\n\t\t    }\n\t\t    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n\t\t  }\n\t\t  getPixelForTick(index) {\n\t\t    const ticks = this.ticks;\n\t\t    if (index < 0 || index > ticks.length - 1) {\n\t\t      return null;\n\t\t    }\n\t\t    return this.getPixelForValue(ticks[index].value);\n\t\t  }\n\t\t  getValueForPixel(pixel) {\n\t\t    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n\t\t  }\n\t\t  getBasePixel() {\n\t\t    return this.bottom;\n\t\t  }\n\t\t}\n\t\tCategoryScale.id = 'category';\n\t\tCategoryScale.defaults = {\n\t\t  ticks: {\n\t\t    callback: CategoryScale.prototype.getLabelForValue\n\t\t  }\n\t\t};\n\n\t\tfunction generateTicks$1(generationOptions, dataRange) {\n\t\t  const ticks = [];\n\t\t  const MIN_SPACING = 1e-14;\n\t\t  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n\t\t  const unit = step || 1;\n\t\t  const maxSpaces = maxTicks - 1;\n\t\t  const {min: rmin, max: rmax} = dataRange;\n\t\t  const minDefined = !isNullOrUndef(min);\n\t\t  const maxDefined = !isNullOrUndef(max);\n\t\t  const countDefined = !isNullOrUndef(count);\n\t\t  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n\t\t  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n\t\t  let factor, niceMin, niceMax, numSpaces;\n\t\t  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n\t\t    return [{value: rmin}, {value: rmax}];\n\t\t  }\n\t\t  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\t\t  if (numSpaces > maxSpaces) {\n\t\t    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n\t\t  }\n\t\t  if (!isNullOrUndef(precision)) {\n\t\t    factor = Math.pow(10, precision);\n\t\t    spacing = Math.ceil(spacing * factor) / factor;\n\t\t  }\n\t\t  if (bounds === 'ticks') {\n\t\t    niceMin = Math.floor(rmin / spacing) * spacing;\n\t\t    niceMax = Math.ceil(rmax / spacing) * spacing;\n\t\t  } else {\n\t\t    niceMin = rmin;\n\t\t    niceMax = rmax;\n\t\t  }\n\t\t  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n\t\t    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n\t\t    spacing = (max - min) / numSpaces;\n\t\t    niceMin = min;\n\t\t    niceMax = max;\n\t\t  } else if (countDefined) {\n\t\t    niceMin = minDefined ? min : niceMin;\n\t\t    niceMax = maxDefined ? max : niceMax;\n\t\t    numSpaces = count - 1;\n\t\t    spacing = (niceMax - niceMin) / numSpaces;\n\t\t  } else {\n\t\t    numSpaces = (niceMax - niceMin) / spacing;\n\t\t    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t      numSpaces = Math.round(numSpaces);\n\t\t    } else {\n\t\t      numSpaces = Math.ceil(numSpaces);\n\t\t    }\n\t\t  }\n\t\t  const decimalPlaces = Math.max(\n\t\t    _decimalPlaces(spacing),\n\t\t    _decimalPlaces(niceMin)\n\t\t  );\n\t\t  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n\t\t  niceMin = Math.round(niceMin * factor) / factor;\n\t\t  niceMax = Math.round(niceMax * factor) / factor;\n\t\t  let j = 0;\n\t\t  if (minDefined) {\n\t\t    if (includeBounds && niceMin !== min) {\n\t\t      ticks.push({value: min});\n\t\t      if (niceMin < min) {\n\t\t        j++;\n\t\t      }\n\t\t      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n\t\t        j++;\n\t\t      }\n\t\t    } else if (niceMin < min) {\n\t\t      j++;\n\t\t    }\n\t\t  }\n\t\t  for (; j < numSpaces; ++j) {\n\t\t    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n\t\t  }\n\t\t  if (maxDefined && includeBounds && niceMax !== max) {\n\t\t    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n\t\t      ticks[ticks.length - 1].value = max;\n\t\t    } else {\n\t\t      ticks.push({value: max});\n\t\t    }\n\t\t  } else if (!maxDefined || niceMax === max) {\n\t\t    ticks.push({value: niceMax});\n\t\t  }\n\t\t  return ticks;\n\t\t}\n\t\tfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n\t\t  const rad = toRadians(minRotation);\n\t\t  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n\t\t  const length = 0.75 * minSpacing * ('' + value).length;\n\t\t  return Math.min(minSpacing / ratio, length);\n\t\t}\n\t\tclass LinearScaleBase extends Scale {\n\t\t  constructor(cfg) {\n\t\t    super(cfg);\n\t\t    this.start = undefined;\n\t\t    this.end = undefined;\n\t\t    this._startValue = undefined;\n\t\t    this._endValue = undefined;\n\t\t    this._valueRange = 0;\n\t\t  }\n\t\t  parse(raw, index) {\n\t\t    if (isNullOrUndef(raw)) {\n\t\t      return null;\n\t\t    }\n\t\t    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n\t\t      return null;\n\t\t    }\n\t\t    return +raw;\n\t\t  }\n\t\t  handleTickRangeOptions() {\n\t\t    const {beginAtZero} = this.options;\n\t\t    const {minDefined, maxDefined} = this.getUserBounds();\n\t\t    let {min, max} = this;\n\t\t    const setMin = v => (min = minDefined ? min : v);\n\t\t    const setMax = v => (max = maxDefined ? max : v);\n\t\t    if (beginAtZero) {\n\t\t      const minSign = sign(min);\n\t\t      const maxSign = sign(max);\n\t\t      if (minSign < 0 && maxSign < 0) {\n\t\t        setMax(0);\n\t\t      } else if (minSign > 0 && maxSign > 0) {\n\t\t        setMin(0);\n\t\t      }\n\t\t    }\n\t\t    if (min === max) {\n\t\t      let offset = 1;\n\t\t      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n\t\t        offset = Math.abs(max * 0.05);\n\t\t      }\n\t\t      setMax(max + offset);\n\t\t      if (!beginAtZero) {\n\t\t        setMin(min - offset);\n\t\t      }\n\t\t    }\n\t\t    this.min = min;\n\t\t    this.max = max;\n\t\t  }\n\t\t  getTickLimit() {\n\t\t    const tickOpts = this.options.ticks;\n\t\t    let {maxTicksLimit, stepSize} = tickOpts;\n\t\t    let maxTicks;\n\t\t    if (stepSize) {\n\t\t      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n\t\t      if (maxTicks > 1000) {\n\t\t        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n\t\t        maxTicks = 1000;\n\t\t      }\n\t\t    } else {\n\t\t      maxTicks = this.computeTickLimit();\n\t\t      maxTicksLimit = maxTicksLimit || 11;\n\t\t    }\n\t\t    if (maxTicksLimit) {\n\t\t      maxTicks = Math.min(maxTicksLimit, maxTicks);\n\t\t    }\n\t\t    return maxTicks;\n\t\t  }\n\t\t  computeTickLimit() {\n\t\t    return Number.POSITIVE_INFINITY;\n\t\t  }\n\t\t  buildTicks() {\n\t\t    const opts = this.options;\n\t\t    const tickOpts = opts.ticks;\n\t\t    let maxTicks = this.getTickLimit();\n\t\t    maxTicks = Math.max(2, maxTicks);\n\t\t    const numericGeneratorOptions = {\n\t\t      maxTicks,\n\t\t      bounds: opts.bounds,\n\t\t      min: opts.min,\n\t\t      max: opts.max,\n\t\t      precision: tickOpts.precision,\n\t\t      step: tickOpts.stepSize,\n\t\t      count: tickOpts.count,\n\t\t      maxDigits: this._maxDigits(),\n\t\t      horizontal: this.isHorizontal(),\n\t\t      minRotation: tickOpts.minRotation || 0,\n\t\t      includeBounds: tickOpts.includeBounds !== false\n\t\t    };\n\t\t    const dataRange = this._range || this;\n\t\t    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n\t\t    if (opts.bounds === 'ticks') {\n\t\t      _setMinAndMaxByKey(ticks, this, 'value');\n\t\t    }\n\t\t    if (opts.reverse) {\n\t\t      ticks.reverse();\n\t\t      this.start = this.max;\n\t\t      this.end = this.min;\n\t\t    } else {\n\t\t      this.start = this.min;\n\t\t      this.end = this.max;\n\t\t    }\n\t\t    return ticks;\n\t\t  }\n\t\t  configure() {\n\t\t    const ticks = this.ticks;\n\t\t    let start = this.min;\n\t\t    let end = this.max;\n\t\t    super.configure();\n\t\t    if (this.options.offset && ticks.length) {\n\t\t      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n\t\t      start -= offset;\n\t\t      end += offset;\n\t\t    }\n\t\t    this._startValue = start;\n\t\t    this._endValue = end;\n\t\t    this._valueRange = end - start;\n\t\t  }\n\t\t  getLabelForValue(value) {\n\t\t    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n\t\t  }\n\t\t}\n\n\t\tclass LinearScale extends LinearScaleBase {\n\t\t  determineDataLimits() {\n\t\t    const {min, max} = this.getMinMax(true);\n\t\t    this.min = isNumberFinite(min) ? min : 0;\n\t\t    this.max = isNumberFinite(max) ? max : 1;\n\t\t    this.handleTickRangeOptions();\n\t\t  }\n\t\t  computeTickLimit() {\n\t\t    const horizontal = this.isHorizontal();\n\t\t    const length = horizontal ? this.width : this.height;\n\t\t    const minRotation = toRadians(this.options.ticks.minRotation);\n\t\t    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n\t\t    const tickFont = this._resolveTickFontOptions(0);\n\t\t    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n\t\t  }\n\t\t  getPixelForValue(value) {\n\t\t    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n\t\t  }\n\t\t  getValueForPixel(pixel) {\n\t\t    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n\t\t  }\n\t\t}\n\t\tLinearScale.id = 'linear';\n\t\tLinearScale.defaults = {\n\t\t  ticks: {\n\t\t    callback: Ticks.formatters.numeric\n\t\t  }\n\t\t};\n\n\t\tfunction isMajor(tickVal) {\n\t\t  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\n\t\t  return remain === 1;\n\t\t}\n\t\tfunction generateTicks(generationOptions, dataRange) {\n\t\t  const endExp = Math.floor(log10(dataRange.max));\n\t\t  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\t  const ticks = [];\n\t\t  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n\t\t  let exp = Math.floor(log10(tickVal));\n\t\t  let significand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\t\t  do {\n\t\t    ticks.push({value: tickVal, major: isMajor(tickVal)});\n\t\t    ++significand;\n\t\t    if (significand === 10) {\n\t\t      significand = 1;\n\t\t      ++exp;\n\t\t      precision = exp >= 0 ? 1 : precision;\n\t\t    }\n\t\t    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t\t  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n\t\t  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n\t\t  ticks.push({value: lastTick, major: isMajor(tickVal)});\n\t\t  return ticks;\n\t\t}\n\t\tclass LogarithmicScale extends Scale {\n\t\t  constructor(cfg) {\n\t\t    super(cfg);\n\t\t    this.start = undefined;\n\t\t    this.end = undefined;\n\t\t    this._startValue = undefined;\n\t\t    this._valueRange = 0;\n\t\t  }\n\t\t  parse(raw, index) {\n\t\t    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n\t\t    if (value === 0) {\n\t\t      this._zero = true;\n\t\t      return undefined;\n\t\t    }\n\t\t    return isNumberFinite(value) && value > 0 ? value : null;\n\t\t  }\n\t\t  determineDataLimits() {\n\t\t    const {min, max} = this.getMinMax(true);\n\t\t    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n\t\t    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n\t\t    if (this.options.beginAtZero) {\n\t\t      this._zero = true;\n\t\t    }\n\t\t    this.handleTickRangeOptions();\n\t\t  }\n\t\t  handleTickRangeOptions() {\n\t\t    const {minDefined, maxDefined} = this.getUserBounds();\n\t\t    let min = this.min;\n\t\t    let max = this.max;\n\t\t    const setMin = v => (min = minDefined ? min : v);\n\t\t    const setMax = v => (max = maxDefined ? max : v);\n\t\t    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n\t\t    if (min === max) {\n\t\t      if (min <= 0) {\n\t\t        setMin(1);\n\t\t        setMax(10);\n\t\t      } else {\n\t\t        setMin(exp(min, -1));\n\t\t        setMax(exp(max, +1));\n\t\t      }\n\t\t    }\n\t\t    if (min <= 0) {\n\t\t      setMin(exp(max, -1));\n\t\t    }\n\t\t    if (max <= 0) {\n\t\t      setMax(exp(min, +1));\n\t\t    }\n\t\t    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n\t\t      setMin(exp(min, -1));\n\t\t    }\n\t\t    this.min = min;\n\t\t    this.max = max;\n\t\t  }\n\t\t  buildTicks() {\n\t\t    const opts = this.options;\n\t\t    const generationOptions = {\n\t\t      min: this._userMin,\n\t\t      max: this._userMax\n\t\t    };\n\t\t    const ticks = generateTicks(generationOptions, this);\n\t\t    if (opts.bounds === 'ticks') {\n\t\t      _setMinAndMaxByKey(ticks, this, 'value');\n\t\t    }\n\t\t    if (opts.reverse) {\n\t\t      ticks.reverse();\n\t\t      this.start = this.max;\n\t\t      this.end = this.min;\n\t\t    } else {\n\t\t      this.start = this.min;\n\t\t      this.end = this.max;\n\t\t    }\n\t\t    return ticks;\n\t\t  }\n\t\t  getLabelForValue(value) {\n\t\t    return value === undefined\n\t\t      ? '0'\n\t\t      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n\t\t  }\n\t\t  configure() {\n\t\t    const start = this.min;\n\t\t    super.configure();\n\t\t    this._startValue = log10(start);\n\t\t    this._valueRange = log10(this.max) - log10(start);\n\t\t  }\n\t\t  getPixelForValue(value) {\n\t\t    if (value === undefined || value === 0) {\n\t\t      value = this.min;\n\t\t    }\n\t\t    if (value === null || isNaN(value)) {\n\t\t      return NaN;\n\t\t    }\n\t\t    return this.getPixelForDecimal(value === this.min\n\t\t      ? 0\n\t\t      : (log10(value) - this._startValue) / this._valueRange);\n\t\t  }\n\t\t  getValueForPixel(pixel) {\n\t\t    const decimal = this.getDecimalForPixel(pixel);\n\t\t    return Math.pow(10, this._startValue + decimal * this._valueRange);\n\t\t  }\n\t\t}\n\t\tLogarithmicScale.id = 'logarithmic';\n\t\tLogarithmicScale.defaults = {\n\t\t  ticks: {\n\t\t    callback: Ticks.formatters.logarithmic,\n\t\t    major: {\n\t\t      enabled: true\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tfunction getTickBackdropHeight(opts) {\n\t\t  const tickOpts = opts.ticks;\n\t\t  if (tickOpts.display && opts.display) {\n\t\t    const padding = toPadding(tickOpts.backdropPadding);\n\t\t    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n\t\t  }\n\t\t  return 0;\n\t\t}\n\t\tfunction measureLabelSize(ctx, font, label) {\n\t\t  label = isArray(label) ? label : [label];\n\t\t  return {\n\t\t    w: _longestText(ctx, font.string, label),\n\t\t    h: label.length * font.lineHeight\n\t\t  };\n\t\t}\n\t\tfunction determineLimits(angle, pos, size, min, max) {\n\t\t  if (angle === min || angle === max) {\n\t\t    return {\n\t\t      start: pos - (size / 2),\n\t\t      end: pos + (size / 2)\n\t\t    };\n\t\t  } else if (angle < min || angle > max) {\n\t\t    return {\n\t\t      start: pos - size,\n\t\t      end: pos\n\t\t    };\n\t\t  }\n\t\t  return {\n\t\t    start: pos,\n\t\t    end: pos + size\n\t\t  };\n\t\t}\n\t\tfunction fitWithPointLabels(scale) {\n\t\t  const orig = {\n\t\t    l: scale.left + scale._padding.left,\n\t\t    r: scale.right - scale._padding.right,\n\t\t    t: scale.top + scale._padding.top,\n\t\t    b: scale.bottom - scale._padding.bottom\n\t\t  };\n\t\t  const limits = Object.assign({}, orig);\n\t\t  const labelSizes = [];\n\t\t  const padding = [];\n\t\t  const valueCount = scale._pointLabels.length;\n\t\t  const pointLabelOpts = scale.options.pointLabels;\n\t\t  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\t\t  for (let i = 0; i < valueCount; i++) {\n\t\t    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n\t\t    padding[i] = opts.padding;\n\t\t    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n\t\t    const plFont = toFont(opts.font);\n\t\t    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n\t\t    labelSizes[i] = textSize;\n\t\t    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n\t\t    const angle = Math.round(toDegrees(angleRadians));\n\t\t    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\t\t    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n\t\t  }\n\t\t  scale.setCenterPoint(\n\t\t    orig.l - limits.l,\n\t\t    limits.r - orig.r,\n\t\t    orig.t - limits.t,\n\t\t    limits.b - orig.b\n\t\t  );\n\t\t  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n\t\t}\n\t\tfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n\t\t  const sin = Math.abs(Math.sin(angle));\n\t\t  const cos = Math.abs(Math.cos(angle));\n\t\t  let x = 0;\n\t\t  let y = 0;\n\t\t  if (hLimits.start < orig.l) {\n\t\t    x = (orig.l - hLimits.start) / sin;\n\t\t    limits.l = Math.min(limits.l, orig.l - x);\n\t\t  } else if (hLimits.end > orig.r) {\n\t\t    x = (hLimits.end - orig.r) / sin;\n\t\t    limits.r = Math.max(limits.r, orig.r + x);\n\t\t  }\n\t\t  if (vLimits.start < orig.t) {\n\t\t    y = (orig.t - vLimits.start) / cos;\n\t\t    limits.t = Math.min(limits.t, orig.t - y);\n\t\t  } else if (vLimits.end > orig.b) {\n\t\t    y = (vLimits.end - orig.b) / cos;\n\t\t    limits.b = Math.max(limits.b, orig.b + y);\n\t\t  }\n\t\t}\n\t\tfunction buildPointLabelItems(scale, labelSizes, padding) {\n\t\t  const items = [];\n\t\t  const valueCount = scale._pointLabels.length;\n\t\t  const opts = scale.options;\n\t\t  const extra = getTickBackdropHeight(opts) / 2;\n\t\t  const outerDistance = scale.drawingArea;\n\t\t  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\n\t\t  for (let i = 0; i < valueCount; i++) {\n\t\t    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n\t\t    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n\t\t    const size = labelSizes[i];\n\t\t    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n\t\t    const textAlign = getTextAlignForAngle(angle);\n\t\t    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n\t\t    items.push({\n\t\t      x: pointLabelPosition.x,\n\t\t      y,\n\t\t      textAlign,\n\t\t      left,\n\t\t      top: y,\n\t\t      right: left + size.w,\n\t\t      bottom: y + size.h\n\t\t    });\n\t\t  }\n\t\t  return items;\n\t\t}\n\t\tfunction getTextAlignForAngle(angle) {\n\t\t  if (angle === 0 || angle === 180) {\n\t\t    return 'center';\n\t\t  } else if (angle < 180) {\n\t\t    return 'left';\n\t\t  }\n\t\t  return 'right';\n\t\t}\n\t\tfunction leftForTextAlign(x, w, align) {\n\t\t  if (align === 'right') {\n\t\t    x -= w;\n\t\t  } else if (align === 'center') {\n\t\t    x -= (w / 2);\n\t\t  }\n\t\t  return x;\n\t\t}\n\t\tfunction yForAngle(y, h, angle) {\n\t\t  if (angle === 90 || angle === 270) {\n\t\t    y -= (h / 2);\n\t\t  } else if (angle > 270 || angle < 90) {\n\t\t    y -= h;\n\t\t  }\n\t\t  return y;\n\t\t}\n\t\tfunction drawPointLabels(scale, labelCount) {\n\t\t  const {ctx, options: {pointLabels}} = scale;\n\t\t  for (let i = labelCount - 1; i >= 0; i--) {\n\t\t    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n\t\t    const plFont = toFont(optsAtIndex.font);\n\t\t    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n\t\t    const {backdropColor} = optsAtIndex;\n\t\t    if (!isNullOrUndef(backdropColor)) {\n\t\t      const padding = toPadding(optsAtIndex.backdropPadding);\n\t\t      ctx.fillStyle = backdropColor;\n\t\t      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);\n\t\t    }\n\t\t    renderText(\n\t\t      ctx,\n\t\t      scale._pointLabels[i],\n\t\t      x,\n\t\t      y + (plFont.lineHeight / 2),\n\t\t      plFont,\n\t\t      {\n\t\t        color: optsAtIndex.color,\n\t\t        textAlign: textAlign,\n\t\t        textBaseline: 'middle'\n\t\t      }\n\t\t    );\n\t\t  }\n\t\t}\n\t\tfunction pathRadiusLine(scale, radius, circular, labelCount) {\n\t\t  const {ctx} = scale;\n\t\t  if (circular) {\n\t\t    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n\t\t  } else {\n\t\t    let pointPosition = scale.getPointPosition(0, radius);\n\t\t    ctx.moveTo(pointPosition.x, pointPosition.y);\n\t\t    for (let i = 1; i < labelCount; i++) {\n\t\t      pointPosition = scale.getPointPosition(i, radius);\n\t\t      ctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n\t\t  const ctx = scale.ctx;\n\t\t  const circular = gridLineOpts.circular;\n\t\t  const {color, lineWidth} = gridLineOpts;\n\t\t  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n\t\t    return;\n\t\t  }\n\t\t  ctx.save();\n\t\t  ctx.strokeStyle = color;\n\t\t  ctx.lineWidth = lineWidth;\n\t\t  ctx.setLineDash(gridLineOpts.borderDash);\n\t\t  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n\t\t  ctx.beginPath();\n\t\t  pathRadiusLine(scale, radius, circular, labelCount);\n\t\t  ctx.closePath();\n\t\t  ctx.stroke();\n\t\t  ctx.restore();\n\t\t}\n\t\tfunction createPointLabelContext(parent, index, label) {\n\t\t  return createContext(parent, {\n\t\t    label,\n\t\t    index,\n\t\t    type: 'pointLabel'\n\t\t  });\n\t\t}\n\t\tclass RadialLinearScale extends LinearScaleBase {\n\t\t  constructor(cfg) {\n\t\t    super(cfg);\n\t\t    this.xCenter = undefined;\n\t\t    this.yCenter = undefined;\n\t\t    this.drawingArea = undefined;\n\t\t    this._pointLabels = [];\n\t\t    this._pointLabelItems = [];\n\t\t  }\n\t\t  setDimensions() {\n\t\t    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n\t\t    const w = this.width = this.maxWidth - padding.width;\n\t\t    const h = this.height = this.maxHeight - padding.height;\n\t\t    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n\t\t    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n\t\t    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n\t\t  }\n\t\t  determineDataLimits() {\n\t\t    const {min, max} = this.getMinMax(false);\n\t\t    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n\t\t    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n\t\t    this.handleTickRangeOptions();\n\t\t  }\n\t\t  computeTickLimit() {\n\t\t    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n\t\t  }\n\t\t  generateTickLabels(ticks) {\n\t\t    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\t\t    this._pointLabels = this.getLabels()\n\t\t      .map((value, index) => {\n\t\t        const label = callback(this.options.pointLabels.callback, [value, index], this);\n\t\t        return label || label === 0 ? label : '';\n\t\t      })\n\t\t      .filter((v, i) => this.chart.getDataVisibility(i));\n\t\t  }\n\t\t  fit() {\n\t\t    const opts = this.options;\n\t\t    if (opts.display && opts.pointLabels.display) {\n\t\t      fitWithPointLabels(this);\n\t\t    } else {\n\t\t      this.setCenterPoint(0, 0, 0, 0);\n\t\t    }\n\t\t  }\n\t\t  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n\t\t    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n\t\t    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n\t\t  }\n\t\t  getIndexAngle(index) {\n\t\t    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n\t\t    const startAngle = this.options.startAngle || 0;\n\t\t    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n\t\t  }\n\t\t  getDistanceFromCenterForValue(value) {\n\t\t    if (isNullOrUndef(value)) {\n\t\t      return NaN;\n\t\t    }\n\t\t    const scalingFactor = this.drawingArea / (this.max - this.min);\n\t\t    if (this.options.reverse) {\n\t\t      return (this.max - value) * scalingFactor;\n\t\t    }\n\t\t    return (value - this.min) * scalingFactor;\n\t\t  }\n\t\t  getValueForDistanceFromCenter(distance) {\n\t\t    if (isNullOrUndef(distance)) {\n\t\t      return NaN;\n\t\t    }\n\t\t    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n\t\t    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n\t\t  }\n\t\t  getPointLabelContext(index) {\n\t\t    const pointLabels = this._pointLabels || [];\n\t\t    if (index >= 0 && index < pointLabels.length) {\n\t\t      const pointLabel = pointLabels[index];\n\t\t      return createPointLabelContext(this.getContext(), index, pointLabel);\n\t\t    }\n\t\t  }\n\t\t  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n\t\t    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n\t\t    return {\n\t\t      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n\t\t      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n\t\t      angle\n\t\t    };\n\t\t  }\n\t\t  getPointPositionForValue(index, value) {\n\t\t    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t  }\n\t\t  getBasePosition(index) {\n\t\t    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n\t\t  }\n\t\t  getPointLabelPosition(index) {\n\t\t    const {left, top, right, bottom} = this._pointLabelItems[index];\n\t\t    return {\n\t\t      left,\n\t\t      top,\n\t\t      right,\n\t\t      bottom,\n\t\t    };\n\t\t  }\n\t\t  drawBackground() {\n\t\t    const {backgroundColor, grid: {circular}} = this.options;\n\t\t    if (backgroundColor) {\n\t\t      const ctx = this.ctx;\n\t\t      ctx.save();\n\t\t      ctx.beginPath();\n\t\t      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n\t\t      ctx.closePath();\n\t\t      ctx.fillStyle = backgroundColor;\n\t\t      ctx.fill();\n\t\t      ctx.restore();\n\t\t    }\n\t\t  }\n\t\t  drawGrid() {\n\t\t    const ctx = this.ctx;\n\t\t    const opts = this.options;\n\t\t    const {angleLines, grid} = opts;\n\t\t    const labelCount = this._pointLabels.length;\n\t\t    let i, offset, position;\n\t\t    if (opts.pointLabels.display) {\n\t\t      drawPointLabels(this, labelCount);\n\t\t    }\n\t\t    if (grid.display) {\n\t\t      this.ticks.forEach((tick, index) => {\n\t\t        if (index !== 0) {\n\t\t          offset = this.getDistanceFromCenterForValue(tick.value);\n\t\t          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n\t\t          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t    if (angleLines.display) {\n\t\t      ctx.save();\n\t\t      for (i = labelCount - 1; i >= 0; i--) {\n\t\t        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n\t\t        const {color, lineWidth} = optsAtIndex;\n\t\t        if (!lineWidth || !color) {\n\t\t          continue;\n\t\t        }\n\t\t        ctx.lineWidth = lineWidth;\n\t\t        ctx.strokeStyle = color;\n\t\t        ctx.setLineDash(optsAtIndex.borderDash);\n\t\t        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\t\t        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n\t\t        position = this.getPointPosition(i, offset);\n\t\t        ctx.beginPath();\n\t\t        ctx.moveTo(this.xCenter, this.yCenter);\n\t\t        ctx.lineTo(position.x, position.y);\n\t\t        ctx.stroke();\n\t\t      }\n\t\t      ctx.restore();\n\t\t    }\n\t\t  }\n\t\t  drawBorder() {}\n\t\t  drawLabels() {\n\t\t    const ctx = this.ctx;\n\t\t    const opts = this.options;\n\t\t    const tickOpts = opts.ticks;\n\t\t    if (!tickOpts.display) {\n\t\t      return;\n\t\t    }\n\t\t    const startAngle = this.getIndexAngle(0);\n\t\t    let offset, width;\n\t\t    ctx.save();\n\t\t    ctx.translate(this.xCenter, this.yCenter);\n\t\t    ctx.rotate(startAngle);\n\t\t    ctx.textAlign = 'center';\n\t\t    ctx.textBaseline = 'middle';\n\t\t    this.ticks.forEach((tick, index) => {\n\t\t      if (index === 0 && !opts.reverse) {\n\t\t        return;\n\t\t      }\n\t\t      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n\t\t      const tickFont = toFont(optsAtIndex.font);\n\t\t      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\t\t      if (optsAtIndex.showLabelBackdrop) {\n\t\t        ctx.font = tickFont.string;\n\t\t        width = ctx.measureText(tick.label).width;\n\t\t        ctx.fillStyle = optsAtIndex.backdropColor;\n\t\t        const padding = toPadding(optsAtIndex.backdropPadding);\n\t\t        ctx.fillRect(\n\t\t          -width / 2 - padding.left,\n\t\t          -offset - tickFont.size / 2 - padding.top,\n\t\t          width + padding.width,\n\t\t          tickFont.size + padding.height\n\t\t        );\n\t\t      }\n\t\t      renderText(ctx, tick.label, 0, -offset, tickFont, {\n\t\t        color: optsAtIndex.color,\n\t\t      });\n\t\t    });\n\t\t    ctx.restore();\n\t\t  }\n\t\t  drawTitle() {}\n\t\t}\n\t\tRadialLinearScale.id = 'radialLinear';\n\t\tRadialLinearScale.defaults = {\n\t\t  display: true,\n\t\t  animate: true,\n\t\t  position: 'chartArea',\n\t\t  angleLines: {\n\t\t    display: true,\n\t\t    lineWidth: 1,\n\t\t    borderDash: [],\n\t\t    borderDashOffset: 0.0\n\t\t  },\n\t\t  grid: {\n\t\t    circular: false\n\t\t  },\n\t\t  startAngle: 0,\n\t\t  ticks: {\n\t\t    showLabelBackdrop: true,\n\t\t    callback: Ticks.formatters.numeric\n\t\t  },\n\t\t  pointLabels: {\n\t\t    backdropColor: undefined,\n\t\t    backdropPadding: 2,\n\t\t    display: true,\n\t\t    font: {\n\t\t      size: 10\n\t\t    },\n\t\t    callback(label) {\n\t\t      return label;\n\t\t    },\n\t\t    padding: 5,\n\t\t    centerPointLabels: false\n\t\t  }\n\t\t};\n\t\tRadialLinearScale.defaultRoutes = {\n\t\t  'angleLines.color': 'borderColor',\n\t\t  'pointLabels.color': 'color',\n\t\t  'ticks.color': 'color'\n\t\t};\n\t\tRadialLinearScale.descriptors = {\n\t\t  angleLines: {\n\t\t    _fallback: 'grid'\n\t\t  }\n\t\t};\n\n\t\tconst INTERVALS = {\n\t\t  millisecond: {common: true, size: 1, steps: 1000},\n\t\t  second: {common: true, size: 1000, steps: 60},\n\t\t  minute: {common: true, size: 60000, steps: 60},\n\t\t  hour: {common: true, size: 3600000, steps: 24},\n\t\t  day: {common: true, size: 86400000, steps: 30},\n\t\t  week: {common: false, size: 604800000, steps: 4},\n\t\t  month: {common: true, size: 2.628e9, steps: 12},\n\t\t  quarter: {common: false, size: 7.884e9, steps: 4},\n\t\t  year: {common: true, size: 3.154e10}\n\t\t};\n\t\tconst UNITS = (Object.keys(INTERVALS));\n\t\tfunction sorter(a, b) {\n\t\t  return a - b;\n\t\t}\n\t\tfunction parse(scale, input) {\n\t\t  if (isNullOrUndef(input)) {\n\t\t    return null;\n\t\t  }\n\t\t  const adapter = scale._adapter;\n\t\t  const {parser, round, isoWeekday} = scale._parseOpts;\n\t\t  let value = input;\n\t\t  if (typeof parser === 'function') {\n\t\t    value = parser(value);\n\t\t  }\n\t\t  if (!isNumberFinite(value)) {\n\t\t    value = typeof parser === 'string'\n\t\t      ? adapter.parse(value, parser)\n\t\t      : adapter.parse(value);\n\t\t  }\n\t\t  if (value === null) {\n\t\t    return null;\n\t\t  }\n\t\t  if (round) {\n\t\t    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n\t\t      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n\t\t      : adapter.startOf(value, round);\n\t\t  }\n\t\t  return +value;\n\t\t}\n\t\tfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\t\t  const ilen = UNITS.length;\n\t\t  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\t    const interval = INTERVALS[UNITS[i]];\n\t\t    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\t\t    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t      return UNITS[i];\n\t\t    }\n\t\t  }\n\t\t  return UNITS[ilen - 1];\n\t\t}\n\t\tfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n\t\t  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\t    const unit = UNITS[i];\n\t\t    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n\t\t      return unit;\n\t\t    }\n\t\t  }\n\t\t  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n\t\t}\n\t\tfunction determineMajorUnit(unit) {\n\t\t  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\t    if (INTERVALS[UNITS[i]].common) {\n\t\t      return UNITS[i];\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction addTick(ticks, time, timestamps) {\n\t\t  if (!timestamps) {\n\t\t    ticks[time] = true;\n\t\t  } else if (timestamps.length) {\n\t\t    const {lo, hi} = _lookup(timestamps, time);\n\t\t    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n\t\t    ticks[timestamp] = true;\n\t\t  }\n\t\t}\n\t\tfunction setMajorTicks(scale, ticks, map, majorUnit) {\n\t\t  const adapter = scale._adapter;\n\t\t  const first = +adapter.startOf(ticks[0].value, majorUnit);\n\t\t  const last = ticks[ticks.length - 1].value;\n\t\t  let major, index;\n\t\t  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n\t\t    index = map[major];\n\t\t    if (index >= 0) {\n\t\t      ticks[index].major = true;\n\t\t    }\n\t\t  }\n\t\t  return ticks;\n\t\t}\n\t\tfunction ticksFromTimestamps(scale, values, majorUnit) {\n\t\t  const ticks = [];\n\t\t  const map = {};\n\t\t  const ilen = values.length;\n\t\t  let i, value;\n\t\t  for (i = 0; i < ilen; ++i) {\n\t\t    value = values[i];\n\t\t    map[value] = i;\n\t\t    ticks.push({\n\t\t      value,\n\t\t      major: false\n\t\t    });\n\t\t  }\n\t\t  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n\t\t}\n\t\tclass TimeScale extends Scale {\n\t\t  constructor(props) {\n\t\t    super(props);\n\t\t    this._cache = {\n\t\t      data: [],\n\t\t      labels: [],\n\t\t      all: []\n\t\t    };\n\t\t    this._unit = 'day';\n\t\t    this._majorUnit = undefined;\n\t\t    this._offsets = {};\n\t\t    this._normalized = false;\n\t\t    this._parseOpts = undefined;\n\t\t  }\n\t\t  init(scaleOpts, opts) {\n\t\t    const time = scaleOpts.time || (scaleOpts.time = {});\n\t\t    const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);\n\t\t    mergeIf(time.displayFormats, adapter.formats());\n\t\t    this._parseOpts = {\n\t\t      parser: time.parser,\n\t\t      round: time.round,\n\t\t      isoWeekday: time.isoWeekday\n\t\t    };\n\t\t    super.init(scaleOpts);\n\t\t    this._normalized = opts.normalized;\n\t\t  }\n\t\t  parse(raw, index) {\n\t\t    if (raw === undefined) {\n\t\t      return null;\n\t\t    }\n\t\t    return parse(this, raw);\n\t\t  }\n\t\t  beforeLayout() {\n\t\t    super.beforeLayout();\n\t\t    this._cache = {\n\t\t      data: [],\n\t\t      labels: [],\n\t\t      all: []\n\t\t    };\n\t\t  }\n\t\t  determineDataLimits() {\n\t\t    const options = this.options;\n\t\t    const adapter = this._adapter;\n\t\t    const unit = options.time.unit || 'day';\n\t\t    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\t\t    function _applyBounds(bounds) {\n\t\t      if (!minDefined && !isNaN(bounds.min)) {\n\t\t        min = Math.min(min, bounds.min);\n\t\t      }\n\t\t      if (!maxDefined && !isNaN(bounds.max)) {\n\t\t        max = Math.max(max, bounds.max);\n\t\t      }\n\t\t    }\n\t\t    if (!minDefined || !maxDefined) {\n\t\t      _applyBounds(this._getLabelBounds());\n\t\t      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n\t\t        _applyBounds(this.getMinMax(false));\n\t\t      }\n\t\t    }\n\t\t    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n\t\t    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\t\t    this.min = Math.min(min, max - 1);\n\t\t    this.max = Math.max(min + 1, max);\n\t\t  }\n\t\t  _getLabelBounds() {\n\t\t    const arr = this.getLabelTimestamps();\n\t\t    let min = Number.POSITIVE_INFINITY;\n\t\t    let max = Number.NEGATIVE_INFINITY;\n\t\t    if (arr.length) {\n\t\t      min = arr[0];\n\t\t      max = arr[arr.length - 1];\n\t\t    }\n\t\t    return {min, max};\n\t\t  }\n\t\t  buildTicks() {\n\t\t    const options = this.options;\n\t\t    const timeOpts = options.time;\n\t\t    const tickOpts = options.ticks;\n\t\t    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\t\t    if (options.bounds === 'ticks' && timestamps.length) {\n\t\t      this.min = this._userMin || timestamps[0];\n\t\t      this.max = this._userMax || timestamps[timestamps.length - 1];\n\t\t    }\n\t\t    const min = this.min;\n\t\t    const max = this.max;\n\t\t    const ticks = _filterBetween(timestamps, min, max);\n\t\t    this._unit = timeOpts.unit || (tickOpts.autoSkip\n\t\t      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n\t\t      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n\t\t    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n\t\t      : determineMajorUnit(this._unit);\n\t\t    this.initOffsets(timestamps);\n\t\t    if (options.reverse) {\n\t\t      ticks.reverse();\n\t\t    }\n\t\t    return ticksFromTimestamps(this, ticks, this._majorUnit);\n\t\t  }\n\t\t  initOffsets(timestamps) {\n\t\t    let start = 0;\n\t\t    let end = 0;\n\t\t    let first, last;\n\t\t    if (this.options.offset && timestamps.length) {\n\t\t      first = this.getDecimalForValue(timestamps[0]);\n\t\t      if (timestamps.length === 1) {\n\t\t        start = 1 - first;\n\t\t      } else {\n\t\t        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n\t\t      }\n\t\t      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n\t\t      if (timestamps.length === 1) {\n\t\t        end = last;\n\t\t      } else {\n\t\t        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n\t\t      }\n\t\t    }\n\t\t    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n\t\t    start = _limitValue(start, 0, limit);\n\t\t    end = _limitValue(end, 0, limit);\n\t\t    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n\t\t  }\n\t\t  _generate() {\n\t\t    const adapter = this._adapter;\n\t\t    const min = this.min;\n\t\t    const max = this.max;\n\t\t    const options = this.options;\n\t\t    const timeOpts = options.time;\n\t\t    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n\t\t    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n\t\t    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\t\t    const hasWeekday = isNumber(weekday) || weekday === true;\n\t\t    const ticks = {};\n\t\t    let first = min;\n\t\t    let time, count;\n\t\t    if (hasWeekday) {\n\t\t      first = +adapter.startOf(first, 'isoWeek', weekday);\n\t\t    }\n\t\t    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\t\t    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n\t\t      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n\t\t    }\n\t\t    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n\t\t    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n\t\t      addTick(ticks, time, timestamps);\n\t\t    }\n\t\t    if (time === max || options.bounds === 'ticks' || count === 1) {\n\t\t      addTick(ticks, time, timestamps);\n\t\t    }\n\t\t    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n\t\t  }\n\t\t  getLabelForValue(value) {\n\t\t    const adapter = this._adapter;\n\t\t    const timeOpts = this.options.time;\n\t\t    if (timeOpts.tooltipFormat) {\n\t\t      return adapter.format(value, timeOpts.tooltipFormat);\n\t\t    }\n\t\t    return adapter.format(value, timeOpts.displayFormats.datetime);\n\t\t  }\n\t\t  _tickFormatFunction(time, index, ticks, format) {\n\t\t    const options = this.options;\n\t\t    const formats = options.time.displayFormats;\n\t\t    const unit = this._unit;\n\t\t    const majorUnit = this._majorUnit;\n\t\t    const minorFormat = unit && formats[unit];\n\t\t    const majorFormat = majorUnit && formats[majorUnit];\n\t\t    const tick = ticks[index];\n\t\t    const major = majorUnit && majorFormat && tick && tick.major;\n\t\t    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n\t\t    const formatter = options.ticks.callback;\n\t\t    return formatter ? callback(formatter, [label, index, ticks], this) : label;\n\t\t  }\n\t\t  generateTickLabels(ticks) {\n\t\t    let i, ilen, tick;\n\t\t    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t      tick = ticks[i];\n\t\t      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n\t\t    }\n\t\t  }\n\t\t  getDecimalForValue(value) {\n\t\t    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n\t\t  }\n\t\t  getPixelForValue(value) {\n\t\t    const offsets = this._offsets;\n\t\t    const pos = this.getDecimalForValue(value);\n\t\t    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n\t\t  }\n\t\t  getValueForPixel(pixel) {\n\t\t    const offsets = this._offsets;\n\t\t    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n\t\t    return this.min + pos * (this.max - this.min);\n\t\t  }\n\t\t  _getLabelSize(label) {\n\t\t    const ticksOpts = this.options.ticks;\n\t\t    const tickLabelWidth = this.ctx.measureText(label).width;\n\t\t    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n\t\t    const cosRotation = Math.cos(angle);\n\t\t    const sinRotation = Math.sin(angle);\n\t\t    const tickFontSize = this._resolveTickFontOptions(0).size;\n\t\t    return {\n\t\t      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n\t\t      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n\t\t    };\n\t\t  }\n\t\t  _getLabelCapacity(exampleTime) {\n\t\t    const timeOpts = this.options.time;\n\t\t    const displayFormats = timeOpts.displayFormats;\n\t\t    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n\t\t    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n\t\t    const size = this._getLabelSize(exampleLabel);\n\t\t    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n\t\t    return capacity > 0 ? capacity : 1;\n\t\t  }\n\t\t  getDataTimestamps() {\n\t\t    let timestamps = this._cache.data || [];\n\t\t    let i, ilen;\n\t\t    if (timestamps.length) {\n\t\t      return timestamps;\n\t\t    }\n\t\t    const metas = this.getMatchingVisibleMetas();\n\t\t    if (this._normalized && metas.length) {\n\t\t      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n\t\t    }\n\t\t    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n\t\t      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n\t\t    }\n\t\t    return (this._cache.data = this.normalize(timestamps));\n\t\t  }\n\t\t  getLabelTimestamps() {\n\t\t    const timestamps = this._cache.labels || [];\n\t\t    let i, ilen;\n\t\t    if (timestamps.length) {\n\t\t      return timestamps;\n\t\t    }\n\t\t    const labels = this.getLabels();\n\t\t    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t      timestamps.push(parse(this, labels[i]));\n\t\t    }\n\t\t    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n\t\t  }\n\t\t  normalize(values) {\n\t\t    return _arrayUnique(values.sort(sorter));\n\t\t  }\n\t\t}\n\t\tTimeScale.id = 'time';\n\t\tTimeScale.defaults = {\n\t\t  bounds: 'data',\n\t\t  adapters: {},\n\t\t  time: {\n\t\t    parser: false,\n\t\t    unit: false,\n\t\t    round: false,\n\t\t    isoWeekday: false,\n\t\t    minUnit: 'millisecond',\n\t\t    displayFormats: {}\n\t\t  },\n\t\t  ticks: {\n\t\t    source: 'auto',\n\t\t    major: {\n\t\t      enabled: false\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\tfunction interpolate(table, val, reverse) {\n\t\t  let lo = 0;\n\t\t  let hi = table.length - 1;\n\t\t  let prevSource, nextSource, prevTarget, nextTarget;\n\t\t  if (reverse) {\n\t\t    if (val >= table[lo].pos && val <= table[hi].pos) {\n\t\t      ({lo, hi} = _lookupByKey(table, 'pos', val));\n\t\t    }\n\t\t    ({pos: prevSource, time: prevTarget} = table[lo]);\n\t\t    ({pos: nextSource, time: nextTarget} = table[hi]);\n\t\t  } else {\n\t\t    if (val >= table[lo].time && val <= table[hi].time) {\n\t\t      ({lo, hi} = _lookupByKey(table, 'time', val));\n\t\t    }\n\t\t    ({time: prevSource, pos: prevTarget} = table[lo]);\n\t\t    ({time: nextSource, pos: nextTarget} = table[hi]);\n\t\t  }\n\t\t  const span = nextSource - prevSource;\n\t\t  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n\t\t}\n\t\tclass TimeSeriesScale extends TimeScale {\n\t\t  constructor(props) {\n\t\t    super(props);\n\t\t    this._table = [];\n\t\t    this._minPos = undefined;\n\t\t    this._tableRange = undefined;\n\t\t  }\n\t\t  initOffsets() {\n\t\t    const timestamps = this._getTimestampsForTable();\n\t\t    const table = this._table = this.buildLookupTable(timestamps);\n\t\t    this._minPos = interpolate(table, this.min);\n\t\t    this._tableRange = interpolate(table, this.max) - this._minPos;\n\t\t    super.initOffsets(timestamps);\n\t\t  }\n\t\t  buildLookupTable(timestamps) {\n\t\t    const {min, max} = this;\n\t\t    const items = [];\n\t\t    const table = [];\n\t\t    let i, ilen, prev, curr, next;\n\t\t    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t      curr = timestamps[i];\n\t\t      if (curr >= min && curr <= max) {\n\t\t        items.push(curr);\n\t\t      }\n\t\t    }\n\t\t    if (items.length < 2) {\n\t\t      return [\n\t\t        {time: min, pos: 0},\n\t\t        {time: max, pos: 1}\n\t\t      ];\n\t\t    }\n\t\t    for (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t      next = items[i + 1];\n\t\t      prev = items[i - 1];\n\t\t      curr = items[i];\n\t\t      if (Math.round((next + prev) / 2) !== curr) {\n\t\t        table.push({time: curr, pos: i / (ilen - 1)});\n\t\t      }\n\t\t    }\n\t\t    return table;\n\t\t  }\n\t\t  _getTimestampsForTable() {\n\t\t    let timestamps = this._cache.all || [];\n\t\t    if (timestamps.length) {\n\t\t      return timestamps;\n\t\t    }\n\t\t    const data = this.getDataTimestamps();\n\t\t    const label = this.getLabelTimestamps();\n\t\t    if (data.length && label.length) {\n\t\t      timestamps = this.normalize(data.concat(label));\n\t\t    } else {\n\t\t      timestamps = data.length ? data : label;\n\t\t    }\n\t\t    timestamps = this._cache.all = timestamps;\n\t\t    return timestamps;\n\t\t  }\n\t\t  getDecimalForValue(value) {\n\t\t    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n\t\t  }\n\t\t  getValueForPixel(pixel) {\n\t\t    const offsets = this._offsets;\n\t\t    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n\t\t    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n\t\t  }\n\t\t}\n\t\tTimeSeriesScale.id = 'timeseries';\n\t\tTimeSeriesScale.defaults = TimeScale.defaults;\n\n\t\tvar scales = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tCategoryScale: CategoryScale,\n\t\tLinearScale: LinearScale,\n\t\tLogarithmicScale: LogarithmicScale,\n\t\tRadialLinearScale: RadialLinearScale,\n\t\tTimeScale: TimeScale,\n\t\tTimeSeriesScale: TimeSeriesScale\n\t\t});\n\n\t\tChart.register(controllers, scales, elements, plugins);\n\t\tChart.helpers = {...helpers};\n\t\tChart._adapters = _adapters;\n\t\tChart.Animation = Animation;\n\t\tChart.Animations = Animations;\n\t\tChart.animator = animator;\n\t\tChart.controllers = registry.controllers.items;\n\t\tChart.DatasetController = DatasetController;\n\t\tChart.Element = Element;\n\t\tChart.elements = elements;\n\t\tChart.Interaction = Interaction;\n\t\tChart.layouts = layouts;\n\t\tChart.platforms = platforms;\n\t\tChart.Scale = Scale;\n\t\tChart.Ticks = Ticks;\n\t\tObject.assign(Chart, controllers, scales, elements, plugins, platforms);\n\t\tChart.Chart = Chart;\n\t\tif (typeof window !== 'undefined') {\n\t\t  window.Chart = Chart;\n\t\t}\n\n\t\treturn Chart;\n\n\t\t})); \n\t} (chart));\n\n\tvar chartExports = chart.exports;\n\n\tvar auto = chartExports;\n\n\tlet exp = auto?.default || auto || { __emptyModule: true };try { Object.defineProperty(exp, \"__\" + \"esModule\", { value: true }); exp.default = exp; } catch (ex) {}\n\n\treturn exp;\n\n}));\n"
    },
    {
      "name": "@datagrok/dendrogram/dist/79",
      "path": "/home/user/projects/project1/node_modules/@datagrok/dendrogram/dist/79.js",
      "lastModified": 1733394545974,
      "type": "module",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n\t(()=>{var t,e={944:(t,e)=>{e.Vb=void 0,e.Vb=function(t,e,n){var r=function(t,e,n){if(0===t.length||0===e.length)return 0;if(n&&!n.caseSensitive&&(t=t.toUpperCase(),e=e.toUpperCase()),t===e)return 1;for(var r=0,i=t.length,s=e.length,o=Math.floor(Math.max(i,s)/2)-1,h=new Array(i),a=new Array(s),l=0;l<i;l++)for(var u=Math.max(0,l-o);u<=Math.min(s,l+o+1);u++)if(!h[l]&&!a[u]&&t[l]===e[u]){++r,h[l]=a[u]=!0;break}if(0===r)return 0;var c=0,g=0;for(l=0;l<i;l++)if(h[l]){for(;!a[g];)g++;t.charAt(l)!==e.charAt(g++)&&c++;}return (r/i+r/s+(r-(c/=2))/r)/3}(t,e,n),i=0;if(r>.7){for(var s=Math.min(t.length,e.length),o=0;t[o]===e[o]&&o<4&&o<s;)++i,o++;r+=.1*i*(1-r);}return r};}},n={};!function(t){t.EUCLIDEAN=\"EUCLIDEAN\",t.MANHATTAN=\"MANHATTAN\";}(t||(t={}));const r=t=>null==t;var i,s,o,h,a,l,u;!function(t){t.Levenshtein=\"Levenshtein\",t.JaroWinkler=\"Jaro-Winkler\",t.Manhattan=\"Manhattan\",t.Onehot=\"One-Hot\";}(i||(i={})),function(t){t.Euclidean=\"Euclidean\";}(s||(s={})),function(t){t.Tanimoto=\"Tanimoto\",t.Dice=\"Dice\",t.Asymmetric=\"Asymmetric\",t.BraunBlanquet=\"Braun-Blanquet\",t.Cosine=\"Cosine\",t.Kulczynski=\"Kulczynski\",t.McConnaughey=\"Mc-Connaughey\",t.RogotGoldberg=\"Rogot-Goldberg\",t.Russel=\"Russel\",t.Sokal=\"Sokal\",t.Hamming=\"Hamming\",t.Euclidean=\"Euclidean\";}(o||(o={})),function(t){t.TanimotoIntArray=\"TanimotoIntArray\";}(h||(h={})),function(t){t.Vector=\"Vector\",t.String=\"String\",t.BitArray=\"BitArray\",t.MacroMolecule=\"MacroMolecule\",t.Number=\"Number\",t.IntArray=\"IntArray\",t.NumberArray=\"NumberArray\";}(a||(a={})),function(t){t.Difference=\"Difference\";}(l||(l={})),function(t){t.CommonItems=\"Common Items\";}(u||(u={}));const c=new Uint32Array(65536),g=(t,e)=>{if(t.length<e.length){const n=e;e=t,t=n;}return 0===e.length?t.length:t.length<=32?((t,e)=>{const n=t.length,r=e.length,i=1<<n-1;let s=-1,o=0,h=n,a=n;for(;a--;)c[t.charCodeAt(a)]|=1<<a;for(a=0;a<r;a++){let t=c[e.charCodeAt(a)];const n=t|o;t|=(t&s)+s^s,o|=~(t|s),s&=t,o&i&&h++,s&i&&h--,o=o<<1|1,s=s<<1|~(n|o),o&=n;}for(a=n;a--;)c[t.charCodeAt(a)]=0;return h})(t,e):((t,e)=>{const n=e.length,r=t.length,i=[],s=[],o=Math.ceil(n/32),h=Math.ceil(r/32);for(let t=0;t<o;t++)s[t]=-1,i[t]=0;let a=0;for(;a<h-1;a++){let o=0,h=-1;const l=32*a,u=Math.min(32,r)+l;for(let e=l;e<u;e++)c[t.charCodeAt(e)]|=1<<e;for(let t=0;t<n;t++){const n=c[e.charCodeAt(t)],r=s[t/32|0]>>>t&1,a=i[t/32|0]>>>t&1,l=n|o,u=((n|a)&h)+h^h|n|a;let g=o|~(u|h),f=h&u;g>>>31^r&&(s[t/32|0]^=1<<t),f>>>31^a&&(i[t/32|0]^=1<<t),g=g<<1|r,f=f<<1|a,h=f|~(l|g),o=g&l;}for(let e=l;e<u;e++)c[t.charCodeAt(e)]=0;}let l=0,u=-1;const g=32*a,f=Math.min(32,r-g)+g;for(let e=g;e<f;e++)c[t.charCodeAt(e)]|=1<<e;let _=r;for(let t=0;t<n;t++){const n=c[e.charCodeAt(t)],o=s[t/32|0]>>>t&1,h=i[t/32|0]>>>t&1,a=n|l,g=((n|h)&u)+u^u|n|h;let f=l|~(g|u),d=u&g;_+=f>>>r-1&1,_-=d>>>r-1&1,f>>>31^o&&(s[t/32|0]^=1<<t),d>>>31^h&&(i[t/32|0]^=1<<t),f=f<<1|o,d=d<<1|h,u=d|~(a|f),l=f&a;}for(let e=g;e<f;e++)c[t.charCodeAt(e)]=0;return _})(t,e)};var f=function t(r){var i=n[r];if(void 0!==i)return i.exports;var s=n[r]={exports:{}};return e[r](s,s.exports,t),s.exports}(944);class _{constructor(t,e=!1){if(this._length=0,this._version=0,this._updateLevel=0,this._selectedCount=0,this._selectedCountVersion=-1,this._selectedIndexesVersion=-1,this._versionedName=\"\",this._versionedNameVersion=-1,this.SHRINK_THRESHOLD=256,\"number\"==typeof t){const n=t,r=_._createBuffer(n);if(e)for(let t=0;t<r.length;t++)r[t]=-1;this._data=r,this._length=n;}else {if(!(t instanceof Uint32Array))throw new Error(\"Invalid constructor\");this._data=t,this._length=e;}}getRawData(){return this._data}assureGoez(t,e){if(t<0)throw new Error(`${e} should be greater than zero`)}assureInRange(t,e,n,r){if(t<e||t>n)throw new Error(`Argument ${r} (${t}) out of range (${e}, ${n})`)}copy(t,e,n){for(let r=0;r<n;r++)e[r]=t[r];}copyFrom(t){if(this._length!=t._length)throw new Error(`Lengths differ (${this._length} != ${t._length})`);this.copy(t._data,this._data,this.lengthInInts),this._version++;}get length(){return this._length}get buffer(){return this._data}set buffer(t){this._data=t,this._version++;}get version(){return this._version}set version(t){this._version=t;}incrementVersion(t=!0){this._version++;}get lengthInInts(){return Math.floor((this._length+31)/32)}get versionedName(){return this._version==this._versionedNameVersion?this._versionedName:\"\"}set versionedName(t){this._versionedName=t,this._versionedNameVersion=this._version;}get self(){return this}setLength(t){if(t<0)throw new Error(\"should be >= 0\");if(t==this._length)return;const e=Math.floor((t+31)/32);if(e>this._data.length||e+this.SHRINK_THRESHOLD<this._data.length){const t=new Uint32Array(e);this.copy(this._data,t,e>this._data.length?this._data.length:e),this._data=t;}t>this._length&&(this._length%32>0&&(this._data[this.lengthInInts-1]&=(1<<(this._length%32&31))-1),this._data.fill(0,this.lengthInInts,e)),this._length=t,this._version++;}static fromAnd(t,e){if(t._length!=e._length)throw new Error(`Lengths differ (${t._length} != ${e._length})`);const n=new _(t._length);n._length=t._length,n._data=_._createBuffer(n._length),n._version=0;const r=t.lengthInInts;for(let i=0;i<r;i++)n._data[i]=t._data[i]&e._data[i];return n}static _createBuffer(t){return new Uint32Array(Math.floor((t+31)/32))}static fromValues(t){const e=new _(t.length);e._version=0;for(let n=0;n<e._length;n++)t[n]&&(e._data[Math.floor(n/32)]|=1<<(n%32&31));return e}static fromSeq(t,e){const n=new _(t);for(let r=0;r<t;++r)n.setBit(r,e(r));return n._version=0,n}static fromString(t){return _.fromSeq(t.length,(e=>\"1\"==t.charAt(e)))}static fromUint32Array(t,e){const n=new _(t);return n._data=e,n}static fromBytes(t){const e=t.length,n=new _(8*e);n._data=new Uint32Array(Math.floor((e+3)/4)),n._length=8*e;let r=0,i=0;for(;e-i>=4;)n._data[r++]=255&t[i]|(255&t[i+1])<<8|(255&t[i+2])<<16|(255&t[i+3])<<24,i+=4;return e-i==3&&(n._data[r]=(255&t[i+2])<<16),e-i==2&&(n._data[r]|=(255&t[i+1])<<8),e-i==1&&(n._data[r]|=255&t[i]),n._version=0,n}toString(){return `${this._length} bits, ${this.countBits(!0)} set`}equals(t){if(this==t)return !0;if(null==t)return !1;if(this._length!=t._length)return !1;if(0==this._length)return !0;for(let e=0;e<this._data.length-1;e++)if(this._data[e]!=t._data[e])return !1;for(let e=8*(this._data.length-1);e<this._length;e++)if(this.getBit(e)!=t.getBit(e))return !1;return !0}clone(){const t=new _(0,!1);return t._data=Uint32Array.from(this._data),t._length=this._length,t._version=this._version,t}init(t,e){this.setAll(!1,!1);for(let e=0;e<this._length;e++)t(e)&&(this._data[Math.floor(e/32)]|=1<<(e%32&31));return this.incrementVersion(e),this}invert(t=!0){for(let t=0;t<this._data.length;t++)this._data[t]^=-1;this.incrementVersion(t);}setAll(t,e=!1){const n=t?-1:0,r=this.lengthInInts;for(let t=0;t<r;t++)this._data[t]=n;this.incrementVersion(e);}setIndexes(t,e=!0,n=!0,r=!0){n&&this.setAll(!e,!1);for(const n of t)this.setFast(n,e);this.incrementVersion(r);}everyIndex(t,e=!0){for(const n of t)if(this.getBit(n)!=e)return !1;return !0}anyIndex(t,e=!0){for(const n of t)if(this.getBit(n)==e)return !0;return !1}setWhere(t,e=!0,n=!0,r=!0,i=!0){if(n&&i&&this.setAll(!e,!1),i)for(let n=0;n<this._length;n++)t(n)&&this.setFast(n,e);else for(let n=0;n<this._length;n++)this.setFast(n,t(n)?e:!e);this.incrementVersion(r);}getRange(t,e){this.assureInRange(t,0,this._length-1,\"from\"),this.assureInRange(e,0,this._length,\"to\");const n=[];for(let r=t;r<e;++r)n.push(this.getBit(r));return _.fromValues(n)}getRangeAsList(t,e){this.assureInRange(t,0,this._length-1,\"from\"),this.assureInRange(e,0,this._length,\"to\");const n=[];for(let r=t;r<e;++r)n.push(this.getBit(r));return n}setRange(t,e,n,r=!0){this.assureInRange(t,0,this._length-1,\"from\"),this.assureInRange(e,0,this._length-1,\"to\");const i=Math.min(t,e),s=Math.max(t,e);if(n)for(let t=i;t<=s;t++)this.setTrue(t);else for(let t=i;t<=s;t++)this.setFalse(t);return this.incrementVersion(r),this}setRandom(t,e,n=!0){if(t<0||t>this._length)throw new Error(\"n must be >= 0 && <= Count\");t>this._length/2&&this.setRandom(this._length-t,!e),this.setAll(!e);for(let n=0;n<t;){const t=Math.floor(Math.random()*this._length);this.getBit(t)!=e&&(this.setFast(t,e),n++);}this.incrementVersion(n);}and(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]&=t._data[e];return this.incrementVersion(e),this}andNot(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");const n=this.lengthInInts;for(let e=0;e<n;e++)this._data[e]&=~t._data[e];return this.incrementVersion(e),this}notAnd(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]=~this._data[e]&t._data[e];return this.incrementVersion(e),this}not(t=!0){for(let t=0,e=this.lengthInInts;t<e;t++)this._data[t]=~this._data[t];return this.incrementVersion(t),this}or(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]|=t._data[e];return this.incrementVersion(e),this}xor(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]^=t._data[e];return this.incrementVersion(e),this}insertAt(t,e,n=!1){if(this.assureInRange(t,0,this._length,\"pos\"),0==e)return;const r=this._length;this.setLength(this._length+e);for(let n=r-1;n>=t;n--)this.setBit(n+e,this.getBit(n));for(let r=t;r<t+e;r++)this.setBit(r,n);}removeAt(t,e=1){if(e<0)throw new Error(\"n cannot be negative\");if(this.assureInRange(t,0,this._length-e,\"pos\"),this.contains(!0))for(let n=t;n<this._length-e;n++)this.setBit(n,this.getBit(n+e));this.setLength(this._length-e);}removeByMask(t,e=!0){if(this._length!=t.length)throw new Error(\"length != mask.length\");if(t==this)this.setLength(t.countBits(!e)),this.setAll(!e);else {let n=0;for(let r=-1;-1!=(r=t.findNext(r,!e));)this.setFast(n++,this.getBit(r));this._length=n,this._version++;}return this}getBit(t){return !!(this._data[Math.floor(t/32)]&1<<(31&t))}setBit(t,e,n=!0){this.setFast(t,e),this._version++;}setFast(t,e){e?this._data[Math.floor(t/32)]|=1<<(31&t):this._data[Math.floor(t/32)]&=~(1<<(31&t));}setTrue(t){this._data[Math.floor(t/32)]|=1<<(31&t);}setFalse(t){this._data[Math.floor(t/32)]&=~(1<<(31&t));}trueCount(){return this.countBits(!0)}falseCount(){return this.countBits(!1)}countBits(t){if(0==this._length)return 0;if(this._selectedCountVersion!=this._version){this._selectedCount=0;const t=this.lengthInInts;let e=0;for(;e<t-1;e++)for(let t=this._data[e];0!=t;t>>>=8)this._selectedCount+=_._onBitCount[255&t];let n=this._data[e];const r=31&this._length;for(0!=r&&(n&=~(4294967295<<r));0!=n;n>>>=8)this._selectedCount+=_._onBitCount[255&n];this._selectedCountVersion=this._version;}return t?this._selectedCount:this._length-this._selectedCount}countWhere(t){let e=0;if(this.trueCount()==this._length)for(let n=0;n<this._length;n++)e+=t(n)?1:0;else for(let n=-1;-1!=(n=this.findNext(n,!0));)e+=t(n)?1:0;return e}andWithCountBits(t,e){if(0==this._length)return 0;let n=0;const r=this.lengthInInts;let i=0;for(;i<r-1;i++)for(let e=this._data[i]&t._data[i];0!=e;e>>>=8)n+=_._onBitCount[255&e];let s=this._data[i]&t._data[i];const o=31&this._length;for(0!=o&&(s&=~(4294967295<<o));0!=s;s>>>=8)n+=_._onBitCount[255&s];return e?n:this._length-n}clear(){this.setLength(0);}contains(t){return this.findNext(-1,t)>=0}get allTrue(){return this.countBits(!0)==this._length}get allFalse(){return this.countBits(!1)==this._length}get anyTrue(){return this.countBits(!0)>0}get anyFalse(){return this.countBits(!1)>0}findNext(t,e=!0){if(this.assureInRange(t,-1,this._length,\"index\"),t>=this._length-1)return -1;let n=31&(t=t<0?0:t+1);const r=this.lengthInInts;for(let i=Math.floor(t/32);i<r;i++){let r=e?this._data[i]:~this._data[i];if(0!=n)r&=4294967295<<n&4294967295,n=0;else if(!e&&-4294967296==r)continue;for(let e=0;0!=r;e+=8,r>>>=8){const n=_._firstOnBit[255&r];if(n>=0)return (t=n+32*i+e)>=this._length?-1:t}}return -1}findPrev(t,e=!0){if(0==t)return -1;this.assureInRange(t,-1,this._length,\"index\");let n=1+(t=t<0?this._length-1:t-1)&31;for(let r=Math.floor(t/32);r>=0;r--){let t=e?this._data[r]:~this._data[r];0!=n&&(t&=~(4294967295<<n),n=0);for(let e=24;0!=t;e-=8,t<<=8){const n=_._lastOnBit[t>>>24];if(n>=0)return n+32*r+e}}return -1}}function d(t={}){const e=function(){if(!t||!t.scoringMatrix||!t.alphabetIndexes)return (t,e)=>t===e?0:1;if(t.scoringMatrix.length!==Object.keys(t.alphabetIndexes).length)throw new Error(\"Scoring matrix and alphabet indexes should have the same length\");const e=t.alphabetIndexes,n=t.scoringMatrix,r=Math.min(...Object.keys(e).map((t=>t.charCodeAt(0))))+1,i=new Float32Array((n.length+r)*(n.length+r));return Object.entries(e).forEach((([t,r])=>{const s=n[r];Object.entries(e).forEach((([e,r])=>{i[t.charCodeAt(0)*n.length+e.charCodeAt(0)]=s[r];}));})),(t,e)=>1-i[t.charCodeAt(0)*n.length+e.charCodeAt(0)]}(),n=t?.threshold??0;return (t,r)=>{let i=0;const s=t.length,o=r.length,h=Math.ceil(Math.max(s,o)*(1-n));s!==o&&(i=Math.abs(s-o));let a=0;for(let n=0;n<Math.min(s,o);n++)if(t[n]!==r[n]&&(a+=e(t[n],r[n]),a>h))return 1;return a+=i,a/=Math.max(s,o),a}}_._onBitCount=Int8Array.from([0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8]),_._firstOnBit=Int8Array.from([-1,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]),_._lastOnBit=Int8Array.from([-1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]);const m={gapOpen:1,gapExtend:.6,scoringMatrix:[[4,-1,-2,-2,0,-1,-1,0,-2,-1,-1,-1,-1,-2,-1,1,0,-3,-2,0,-2,-1,0,-4],[-1,5,0,-2,-3,1,0,-2,0,-3,-2,2,-1,-3,-2,-1,-1,-3,-2,-3,-1,0,-1,-4],[-2,0,6,1,-3,0,0,0,1,-3,-3,0,-2,-3,-2,1,0,-4,-2,-3,3,0,-1,-4],[-2,-2,1,6,-3,0,2,-1,-1,-3,-4,-1,-3,-3,-1,0,-1,-4,-3,-3,4,1,-1,-4],[0,-3,-3,-3,9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-3,-3,-2,-4],[-1,1,0,0,-3,5,2,-2,0,-3,-2,1,0,-3,-1,0,-1,-2,-1,-2,0,3,-1,-4],[-1,0,0,2,-4,2,5,-2,0,-3,-3,1,-2,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4],[0,-2,0,-1,-3,-2,-2,6,-2,-4,-4,-2,-3,-3,-2,0,-2,-2,-3,-3,-1,-2,-1,-4],[-2,0,1,-1,-3,0,0,-2,8,-3,-3,-1,-2,-1,-2,-1,-2,-2,2,-3,0,0,-1,-4],[-1,-3,-3,-3,-1,-3,-3,-4,-3,4,2,-3,1,0,-3,-2,-1,-3,-1,3,-3,-3,-1,-4],[-1,-2,-3,-4,-1,-2,-3,-4,-3,2,4,-2,2,0,-3,-2,-1,-2,-1,1,-4,-3,-1,-4],[-1,2,0,-1,-3,1,1,-2,-1,-3,-2,5,-1,-3,-1,0,-1,-3,-2,-2,0,1,-1,-4],[-1,-1,-2,-3,-1,0,-2,-3,-2,1,2,-1,5,0,-2,-1,-1,-1,-1,1,-3,-1,-1,-4],[-2,-3,-3,-3,-2,-3,-3,-3,-1,0,0,-3,0,6,-4,-2,-2,1,3,-1,-3,-3,-1,-4],[-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4,7,-1,-1,-4,-3,-2,-2,-1,-2,-4],[1,-1,1,0,-1,0,0,0,-1,-2,-2,0,-1,-2,-1,4,1,-3,-2,-2,0,0,0,-4],[0,-1,0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1,1,5,-2,-2,0,-1,-1,0,-4],[-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1,1,-4,-3,-2,11,2,-3,-4,-3,-2,-4],[-2,-2,-2,-3,-2,-1,-2,-3,2,-1,-1,-2,-1,3,-3,-2,-2,2,7,-1,-3,-2,-1,-4],[0,-3,-3,-3,-1,-2,-2,-3,-3,3,1,-2,1,-1,-2,-2,0,-3,-1,4,-3,-2,-1,-4],[-2,-1,3,4,-3,0,1,-1,0,-3,-4,0,-3,-3,-2,0,-1,-4,-3,-3,4,1,-1,-4],[-1,0,0,1,-3,3,4,-2,0,-3,-3,1,-1,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4],[0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2,0,0,-2,-1,-1,-1,-1,-1,-4],[-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,1]],alphabetIndexes:{A:0,R:1,N:2,D:3,C:4,Q:5,E:6,G:7,H:8,I:9,L:10,K:11,M:12,F:13,P:14,S:15,T:16,W:17,Y:18,V:19,B:20,Z:21,X:22,\"*\":23}};var C;!function(t){t.HAMMING=\"Hamming\",t.LEVENSHTEIN=\"Levenshtein\",t.NEEDLEMANN_WUNSCH=\"Needlemann-Wunsch\",t.MONOMER_CHEMICAL_DISTANCE=\"Monomer chemical distance\";}(C||(C={}));const A={[C.HAMMING]:d,[C.LEVENSHTEIN]:function(){return (t,e)=>g(t,e)/Math.max(t.length,e.length)},[C.NEEDLEMANN_WUNSCH]:function(t){const e=new Uint16Array(65536),{gapOpen:n,gapExtend:r,scoringMatrix:i,alphabetIndexes:s}={...m,...t};Object.entries(s).forEach((([t,n])=>e[t.charCodeAt(0)]=n));const o=[new Float32Array(1e4),new Float32Array(1e4)];return (t,s)=>{const h=new Array(t.length+1).fill(!1),a=new Array(t.length+1).fill(!1);let l=0,u=1;for(let e=1;e<t.length+1;e++)o[0][e]=-r-(e-1)*r,o[1][e]=0;o[0][0]=0;for(let c=1;c<s.length+1;c++){o[u][0]=-r-(c-1)*r;for(let g=1;g<t.length+1;g++){const f=o[l][g-1]+i[e[t.charCodeAt(g-1)]][e[s.charCodeAt(c-1)]],_=o[l][g]-(h[g]||1===c||c===s.length?r:n),d=o[u][g-1]-(a[g-1]||1===g||g===t.length?r:n);o[u][g]=Math.max(f,d,_),o[u][g]===f?(h[g]=!1,a[g]=!1):o[u][g]===d?(h[g]=!1,a[g]=!0):(h[g]=!0,a[g]=!1);}l=u,u=(u+1)%2;}const c=Math.min(t.length,s.length);return (c-o[l][t.length])/c}},[C.MONOMER_CHEMICAL_DISTANCE]:d};function M(t,e){const n=t.trueCount()+e.trueCount();if(0==n)return 1;const r=t.andWithCountBits(e,!0);return r/(n-r)}function y(t){return 0===t?3402823e32:1/t-1}o.Tanimoto,o.Dice,o.Asymmetric,o.BraunBlanquet,o.Cosine,o.Kulczynski,o.McConnaughey,o.RogotGoldberg,o.Russel,o.Sokal,o.Hamming,o.Euclidean,o.Tanimoto,o.Dice,o.Asymmetric,o.BraunBlanquet,o.Cosine,o.Kulczynski,o.McConnaughey,o.RogotGoldberg,o.Russel,o.Sokal,o.Hamming,o.Euclidean,o.Tanimoto,o.Dice,o.Cosine,o.Tanimoto,o.Asymmetric,o.Cosine,o.Sokal,C.HAMMING,C.LEVENSHTEIN,C.MONOMER_CHEMICAL_DISTANCE,C.NEEDLEMANN_WUNSCH;const I={[s.Euclidean]:function(t,e){let n=0;const r=t.length;if(r!==e.length)throw new Error(\"The dimensionality of the vectors must match\");for(let i=0;i<r;++i)n+=Math.pow(t[i]-e[i],2);return Math.sqrt(n)}},E={[i.Levenshtein]:g,[i.JaroWinkler]:f.Vb,[i.Manhattan]:function(t,e){if(t.length!==e.length)return 1;{let n=0;for(let r=1;r<t.length;r++)n+=t[r]==e[r]?0:1;return n/t.length}},[i.Onehot]:function(t,e){return t===e?0:1}},N={[o.Tanimoto]:function(t,e){return 1-M(t,e)},[o.Dice]:function(t,e){return 1-function(t,e){const n=t.trueCount()+e.trueCount();return 0==n?0:2*t.andWithCountBits(e,!0)/n}(t,e)},[o.Asymmetric]:function(t,e){return 1-function(t,e){const n=Math.min(t.trueCount(),e.trueCount());return 0==n?0:t.andWithCountBits(e,!0)/n}(t,e)},[o.BraunBlanquet]:function(t,e){return y(function(t,e){const n=Math.max(t.trueCount(),e.trueCount());return 0==n?0:t.andWithCountBits(e,!0)/n}(t,e))},[o.Cosine]:function(t,e){return 1-function(t,e){const n=t.trueCount()*e.trueCount();return 0==n?0:t.andWithCountBits(e,!0)/Math.sqrt(n)}(t,e)},[o.Kulczynski]:function(t,e){return y(function(t,e){const n=t.trueCount()+e.trueCount(),r=t.trueCount()*e.trueCount();return 0==r?0:t.andWithCountBits(e,!0)*n/(2*r)}(t,e))},[o.McConnaughey]:function(t,e){return y(function(t,e){const n=t.trueCount()+e.trueCount(),r=t.trueCount()*e.trueCount();return 0==r?0:(t.andWithCountBits(e,!0)*n-r)/r}(t,e))},[o.RogotGoldberg]:function(t,e){return y(function(t,e){const n=t.andWithCountBits(e,!0),r=t.countBits(!0)+e.countBits(!0),i=t.length,s=i-r+n;return n==i||s==i?1:n/r+s/(2*i-r)}(t,e))},[o.Russel]:function(t,e){return y(function(t,e){return 0==t.length?0:t.andWithCountBits(e,!0)/t.length}(t,e))},[o.Sokal]:function(t,e){return 1-function(t,e){const n=t.trueCount()+e.trueCount(),r=t.andWithCountBits(e,!0);return r/(2*n-3*r)}(t,e)},[o.Hamming]:function(t,e){return t.trueCount()+e.trueCount()-2*t.andWithCountBits(e,!0)},[o.Euclidean]:function(t,e){return Math.sqrt(t.trueCount()+e.trueCount()-2*t.andWithCountBits(e,!0))}},B={[h.TanimotoIntArray]:function(t,e){return y(M(new _(t,32*t.length),new _(e,32*e.length)))}},w={[l.Difference]:function(t){if(t&&null!=t.range&&t.range>0){const e=t.range;return (t,n)=>Math.abs(t-n)/e}return (t,e)=>Math.abs(t-e)}},v={[u.CommonItems]:function(t){const e=function(t){const e=t?.mostCommon??new Set;return (t,n)=>{const r=t.length,i=n.length;let s=0,o=0,h=0;for(;o<r&&h<i;)t[o]===n[h]?(e?.has(t[o])||++s,++o,++h):t[o]<n[h]?++o:++h;return s}}(t);return (t,n)=>0===n.length||0===t.length?1e4:Math.min(t.length,n.length)/(e(t,n)+1e-4)}},b={[a.Vector]:{[s.Euclidean]:I[s.Euclidean]},[a.String]:{[i.Levenshtein]:E[i.Levenshtein],[i.JaroWinkler]:E[i.JaroWinkler],[i.Manhattan]:E[i.Manhattan],[i.Onehot]:E[i.Onehot]},[a.BitArray]:{[o.Tanimoto]:N[o.Tanimoto],[o.Dice]:N[o.Dice],[o.Asymmetric]:N[o.Asymmetric],[o.BraunBlanquet]:N[o.BraunBlanquet],[o.Cosine]:N[o.Cosine],[o.Kulczynski]:N[o.Kulczynski],[o.McConnaughey]:N[o.McConnaughey],[o.RogotGoldberg]:N[o.RogotGoldberg],[o.Russel]:N[o.Russel],[o.Sokal]:N[o.Sokal]},[a.MacroMolecule]:{[C.HAMMING]:A[C.HAMMING],[C.LEVENSHTEIN]:A[C.LEVENSHTEIN],[C.NEEDLEMANN_WUNSCH]:A[C.NEEDLEMANN_WUNSCH],[C.MONOMER_CHEMICAL_DISTANCE]:A[C.MONOMER_CHEMICAL_DISTANCE]},[a.Number]:{[l.Difference]:w[l.Difference]},[a.IntArray]:{[h.TanimotoIntArray]:B[h.TanimotoIntArray]},[a.NumberArray]:{[u.CommonItems]:v[u.CommonItems]}},p=Object.keys(b).reduce(((t,e)=>{for(const n of Object.keys(b[e]))t[n]=e;return t}),{});class T{constructor(t){this.method=t,this.dataType=p[t];}metricNeedsArgs(t){return p[t]==a.MacroMolecule.toString()||p[t]==a.Number.toString()||function(t){return p[t]==a.NumberArray.toString()}(t)}getMeasure(t){const e=b;if(!e.hasOwnProperty(this.dataType)||!e[this.dataType].hasOwnProperty(this.method))throw new Error(`Unknown measure ${this.method} for data type ${this.dataType}`);return this.metricNeedsArgs(this.method)?e[this.dataType][this.method](t):e[this.dataType][this.method]}static getMetricByDataType(t){return Object.keys(b[t])}static get availableMeasures(){return Object.keys(b)}}onmessage=e=>{const{values:n,fnNames:i,startRow:s,startCol:o,chunckSize:h,opts:a,weights:l,aggregationMethod:u}=e.data,c={};try{let e=s,g=o,f=0,d=0,m=Number.MIN_VALUE;const C=function(e,n){return e===t.MANHATTAN?t=>t.reduce(((t,e,r)=>t+e*n[r]),0):t=>{const e=t.reduce(((t,e,r)=>t+(e*n[r])**2),0);return Math.sqrt(e)}}(u,l);n.forEach(((t,e)=>{if(s=i[e],\"BitArray\"==p[s])for(let i=0;i<t.length;++i)r(t[i])||(n[e][i]=new _(n[e][i]._data,n[e][i]._length));var s;}));const A=new Array(i.length).fill(null).map(((t,e)=>new T(i[e]).getMeasure(a[e]))),M=new Float32Array(h);for(;f<h;){const t=A.map(((t,i)=>r(n[i][e])||r(n[i][g])?1:t(n[i][e],n[i][g]))),i=1===t.length?t[0]:C(t);M[f]=i,i<d&&(d=i),i>m&&(m=i),f++,g++,g===n[0].length&&(e++,g=e+1);}c.distanceMatrixData=M,c.min=d,c.max=m;}catch(t){c.error=t;}postMessage(c);};})();\n\n\tconst __esModule = true;\n\n\texports.__esModule = __esModule;\n\n}));\n"
    },
    {
      "name": "@datagrok/dendrogram/dist/package",
      "path": "/home/user/projects/project1/node_modules/@datagrok/dendrogram/dist/package.js",
      "lastModified": 1733394546318,
      "type": "module",
      "code": "sap.ui.define((function () { 'use strict';\n\n\tvar _package = {};\n\n\t(function (exports) {\n\t(()=>{var t={1058:(t,e,n)=>{n.d(e,{Et:()=>r,LX:()=>h,gp:()=>s,h_:()=>l,u_:()=>o,uf:()=>a});var i=n(6082);const r=\";\";var s,o,a,l;!function(t){t.NEWICK=\".newick\",t.NEWICK_JSON=\".newick_json\",t.OBJECTS=\".newick_objects\",t.NEWICK_LEAF_COL_NAME=\".newickLeafColumn\";}(s||(s={})),function(t){t.Main=\"Main\",t.Light=\"Light\",t.Current=\"Current\",t.MouseOver=\"MouseOver\",t.Selection=\"Selection\";}(o||(o={})),function(t){t.Euclidean=\"euclidean\",t.Manhattan=\"manhattan\";}(a||(a={})),function(t){t.Single=\"single\",t.Complete=\"complete\",t.Average=\"average\",t.Weighted=\"weighted\",t.Centroid=\"centroid\",t.Median=\"median\",t.Ward=\"ward\";}(l||(l={}));const h={[o.Main]:i.Color.categoricalPalette[12],[o.Light]:i.Color.categoricalPalette[13],[o.Current]:i.Color.currentRow,[o.MouseOver]:i.Color.mouseOverRows,[o.Selection]:i.Color.selectedRows};},4622:(t,e,n)=>{n.d(e,{uf:()=>i.uf,h_:()=>i.h_,gp:()=>i.gp,u_:()=>i.u_,LX:()=>i.LX,xe:()=>r});var i=n(1058);function r(t){return !t.children||0==t.children.length}},6806:(t,e,n)=>{n.d(e,{TX:()=>i,Z$:()=>r});const i=\"[root]\";function r(t){const e=[];let n={name:\"\"};const r=t.split(/\\s*(;|\\(|\\)|,|:)\\s*/);for(let t=0;t<r.length;t++){const i=r[t];switch(i){case\"(\":{const t={name:\"\"};n.children=[t],e.push(n),n=t;}break;case\",\":{const t={name:\"\"};e[e.length-1].children.push(t),n=t;}break;case\")\":n=e.pop();break;case\":\":break;default:const s=r[t-1];\")\"==s||\"(\"==s||\",\"==s?n.name=i:\":\"==s&&(n.branch_length=parseFloat(i));}}return n.name||(n.name=i),n}},439:(t,e,n)=>{n.d(e,{B5:()=>l,Hi:()=>i,YI:()=>r,gp:()=>s,q7:()=>c,z1:()=>a});var i,r,s,o=n(2738);!function(t){t.FASTA=\"fasta\",t.SEPARATOR=\"separator\",t.HELM=\"helm\";}(i||(i={})),function(t){t.DNA=\"DNA\",t.RNA=\"RNA\",t.PT=\"PT\",t.UN=\"UN\";}(r||(r={})),function(t){t.aligned=\"aligned\",t.alphabet=\"alphabet\",t.alphabetSize=\".alphabetSize\",t.alphabetIsMultichar=\".alphabetIsMultichar\",t.separator=\"separator\",t.isHelmCompatible=\".isHelmCompatible\",t.positionNames=\".positionNames\",t.positionLabels=\".positionLabels\",t.regions=\".regions\";}(s||(s={}));const a=\", \",l=/(?:\\[([A-Za-z0-9_\\-,()]+)\\])|([A-Za-z\\-])/g,h=new class{constructor(){this.fasta={peptide:new Set([\"G\",\"L\",\"Y\",\"S\",\"E\",\"Q\",\"D\",\"N\",\"F\",\"A\",\"K\",\"R\",\"H\",\"C\",\"V\",\"P\",\"W\",\"I\",\"M\",\"T\"]),dna:new Set([\"A\",\"C\",\"G\",\"T\"]),rna:new Set([\"A\",\"C\",\"G\",\"U\"])};}},c=[new o.aD(r.PT,h.fasta.peptide,.5),new o.aD(r.DNA,h.fasta.dna,.55),new o.aD(r.RNA,h.fasta.rna,.55)];},2003:(t,e,n)=>{n.d(e,{Hi:()=>i.Hi,J9:()=>r.J9,YI:()=>i.YI,dh:()=>r.dh,gp:()=>i.gp,q7:()=>i.q7,qp:()=>r.qp,z1:()=>i.z1});var i=n(439),r=n(4906);},2738:(t,e,n)=>{n.d(e,{XN:()=>s,_S:()=>i,aD:()=>r});const i=\"\";class r{constructor(t,e,n){this.name=t,this.alphabet=e,this.cutoff=n;}}class s extends r{constructor(t,e,n){super(t.name,t.alphabet,t.cutoff),this.freq=e,this.similarity=n;}}},4906:(t,e,n)=>{n.d(e,{Mu:()=>w,pc:()=>E,dh:()=>y,J9:()=>_,tm:()=>v,qp:()=>T});var i=n(6082),r=n(1991),s=n.n(r),o=n(2738),a=n(439),l=n(7493);class h extends Float32Array{}var c=n(3629);class u{static makePalette(t,e=!1,n=u){const i={};return t.forEach((t=>{const n=t[0],r=t[1];n.forEach(((t,n)=>{i[t]=this.colourPalette[r][e?0:n];}));})),new n(i)}constructor(t){this._palette=t;}get(t){return this._palette[t]}}u.undefinedColor=\"rgb(100,100,100)\",u.colourPalette={orange:[\"rgb(255,187,120)\",\"rgb(245,167,100)\",\"rgb(235,137,70)\",\"rgb(205, 111, 71)\"],all_green:[\"rgb(44,160,44)\",\"rgb(74,160,74)\",\"rgb(23,103,57)\",\"rgb(30,110,96)\",\"rgb(60,131,95)\",\"rgb(24,110,79)\",\"rgb(152,223,138)\",\"rgb(182, 223, 138)\",\"rgb(152, 193, 138)\"],all_blue:[\"rgb(31,119,180)\",\"rgb(23,190,207)\",\"rgb(122, 102, 189)\",\"rgb(158,218,229)\",\"rgb(141, 124, 217)\",\"rgb(31, 120, 150)\"],magenta:[\"rgb(162,106,192)\",\"rgb(197,165,224)\",\"rgb(208,113,218)\"],red:[\"rgb(214,39,40)\",\"rgb(255,152,150)\"],st_blue:[\"rgb(23,190,207)\",\"rgb(158,218,229)\",\"rgb(31,119,180)\"],dark_blue:[\"rgb(31,119,180)\",\"rgb(31, 120, 150)\"],light_blue:[\"rgb(23,190,207)\",\"rgb(158,218,229)\",\"rgb(108, 218, 229)\",\"rgb(23,190,227)\"],lilac_blue:[\"rgb(124,102,211)\",\"rgb(149,134,217)\",\"rgb(97, 81, 150)\"],dark_green:[\"rgb(23,103,57)\",\"rgb(30,110,96)\",\"rgb(60,131,95)\",\"rgb(24,110,79)\"],green:[\"rgb(44,160,44)\",\"rgb(74,160,74)\"],light_green:[\"rgb(152,223,138)\",\"rgb(182, 223, 138)\",\"rgb(152, 193, 138)\"],st_green:[\"rgb(44,160,44)\",\"rgb(152,223,138)\",\"rgb(39, 174, 96)\",\"rgb(74,160,74)\"],pink:[\"rgb(247,182,210)\"],brown:[\"rgb(140,86,75)\",\"rgb(102, 62, 54)\"],gray:[\"rgb(127,127,127)\",\"rgb(199,199,199)\",\"rgb(196,156,148)\",\"rgb(222, 222, 180)\"],yellow:[\"rgb(188,189,34)\"],white:[\"rgb(230,230,230)\"]};class d extends u{static get Lesk(){return void 0===this.lesk&&(this.lesk=this.makePalette([[[\"G\",\"A\",\"S\",\"T\"],\"orange\"],[[\"C\",\"V\",\"I\",\"L\",\"P\",\"F\",\"Y\",\"M\",\"W\"],\"all_green\"],[[\"N\",\"Q\",\"H\"],\"magenta\"],[[\"D\",\"E\"],\"red\"],[[\"K\",\"R\"],\"all_blue\"]],!1,d)),this.lesk}static get GrokGroups(){return void 0===this.grokGroups&&(this.grokGroups=this.makePalette([[[\"C\",\"U\"],\"yellow\"],[[\"G\",\"P\"],\"red\"],[[\"A\",\"V\",\"I\",\"L\",\"M\",\"F\",\"Y\",\"W\"],\"all_green\"],[[\"R\",\"H\",\"K\"],\"light_blue\"],[[\"D\",\"E\"],\"dark_blue\"],[[\"S\",\"T\",\"N\",\"Q\"],\"orange\"]],!1,d)),this.grokGroups}static get RasMol(){return void 0===this.rasMol&&(this.rasMol=new d({D:\"#E60A0A\",E:\"#E60A0A\",C:\"#E6E600\",M:\"#E6E600\",K:\"#145AFF\",R:\"#145AFF\",S:\"#FA9600\",T:\"#FA9600\",F:\"#3232AA\",Y:\"#3232AA\",N:\"#00DCDC\",Q:\"#00DCDC\",G:\"#EBEBEB\",L:\"#0F820F\",V:\"#0F820F\",I:\"#0F820F\",A:\"#C8C8C8\",W:\"#B45AB4\",H:\"#8282D2\",P:\"#DC9682\",others:\"#BEA06E\"})),this.rasMol}get(t){const e=t in d.aaSynonyms?d.aaSynonyms[t]:t;return super.get(e)}}d.aaSynonyms={MeNle:\"L\",MeA:\"A\",MeG:\"G\",MeF:\"F\"};class m{static hashCode(t){let e=0;if(0===t.length)return e;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n),e|=0;return e}}class p{}class C extends p{static buildPalette(){return [].concat(...Object.values(u.colourPalette))}get(t){const e=m.hashCode(t)%C.palette.length;return function(t){if(null==t)return \"rgb(100,100,100)\";const e=i.Color.fromHtml(t),n=i.Color.g(e),r=i.Color.r(e),s=i.Color.b(e),o=Math.sqrt(Math.pow(0-r,2)+Math.pow(0-n,2)+Math.pow(0-s,2));return o>210?`rgb(${r/o*210},${n/o*210},${s/o*210})`:i.Color.toRgb(e)}(C.palette[e])}}C.palette=C.buildPalette();class w{get length(){return this.mList.length}get canonicals(){return this.mList}get originals(){return this.mList}isGap(t){return this.getOriginal(t)===this.gapOriginalMonomer}getCanonical(t){if(this.length<=t)throw new Error(\"Index out of bounds\");return this.mList[t]}getOriginal(t){if(this.length<=t)throw new Error(\"Index out of bounds\");return this.mList[t]}constructor(t,e){this.mList=t,this.gapOriginalMonomer=e;}}class b{get length(){return this.seqS.length}get canonicals(){return this.seqS}get originals(){return this.seqS}isGap(t){return this.getOriginal(t)===l.b9[a.Hi.FASTA]}getCanonical(t){if(this.length<=t)throw new Error(\"Index out of bounds\");return this.isGap(t)?o._S:this.seqS[t]}getOriginal(t){if(this.length<=t)throw new Error(\"Index out of bounds\");return this.seqS[t]}constructor(t){this.seqS=t;}}const _=t=>{const e=s()(t.toString().matchAll(a.B5)).map((t=>t[2]??t[1])).toArray();return new w(e,l.b9[a.Hi.FASTA])},v=t=>t?new b(t):new w([],l.b9[a.Hi.FASTA]);function y(t,e=void 0){return n=>{if(n){let i;const r=new RegExp(String.raw`\"-\"|'-'|[^${t}]+`,\"g\");if(void 0!==e){r.lastIndex=0,i=new Array(Math.ceil(e));let t=null,s=0;for(;null!==(t=r.exec(n))&&s<e;)i[s++]=t[0].replace('\"-\"',\"\").replace(\"'-'\",\"\");i.splice(s);}else i=n.replaceAll('\"-\"',\"\").replaceAll(\"'-'\",\"\").split(t,e);return new w(i,l.b9[a.Hi.SEPARATOR])}return new w([],l.b9[a.Hi.SEPARATOR])}}const A=/(PEPTIDE1|DNA1|RNA1)\\{([^}]+)}/g,S=/\\[([^\\[\\]]+)]/g,T=t=>{A.lastIndex=0;const e=A.exec(t.toString()),n=e?e[2]:null,i=n?n.split(\".\"):[];return new w(i.map((t=>{S.lastIndex=0;const e=S.exec(t);return e&&e.length>=2?e[1]:t})),l.b9[a.Hi.HELM])};function E(t,e,n=\"-\"){const i=e.map((e=>{const i=function(t,e,n=\"-\"){const i=new Set([...new Set(Object.keys(t)),...e]);i.delete(n);const r=[],s=[];for(const n of i)r.push(n in t?t[n]:0),s.push(e.has(n)?1:0);const o=new h(r),a=new h(s);return (0, c.KE)(o,a)/((0, c.wQ)(o)*(0, c.wQ)(a))}(t,e.alphabet,n);return new o.XN(e,t,i)}));let r;const s=Math.max(...i.map((t=>t.similarity>t.cutoff?t.similarity:-1)));return r=s>0?i.find((t=>t.similarity===s)).name:a.YI.UN,r}},7493:(t,e,n)=>{n.d(e,{b9:()=>g,GO:()=>f});var i=n(6082),r=n(1991),s=n.n(r),o=n(2003),a=n(2738),l=n(4906),h=n(4572);n(4328),n(6295);const c=\"p\",u=new RegExp(`[rd]\\\\((\\\\w)\\\\)${c}?`,\"g\");const d=new class{constructor(){this.seqHandler=\"seq-handler\",this.notationProvider=\"seq-handler.notation-provider\";}},g={[o.Hi.FASTA]:\"-\",[o.Hi.SEPARATOR]:\"\",[o.Hi.HELM]:\"*\"};class f{constructor(t){if(this._splitter=null,this.cached=!0,this._splitted=null,this.columnVersion=null,this._stats=null,this._maxLength=null,this._posList=null,this._joiner=void 0,t.type!==i.TYPE.STRING)throw new Error(`Unexpected column type '${t.type}', must be '${i.TYPE.STRING}'.`);this._column=t;const e=this._column.meta.units;if(null==e)throw new Error(\"Units are not specified in column\");if(this._units=e,this._notation=this.getNotation(),this._defaultGapOriginal=this.isFasta()?g[o.Hi.FASTA]:this.isHelm()?g[o.Hi.HELM]:g[o.Hi.SEPARATOR],!this.column.tags.has(o.gp.aligned)||!this.column.tags.has(o.gp.alphabet)||!this.column.tags.has(o.gp.alphabetIsMultichar)&&!this.isHelm()&&this.alphabet===o.YI.UN)if(this.isFasta())f.setUnitsToFastaColumn(this);else if(this.isSeparator()){const e=t.getTag(o.gp.separator);f.setUnitsToSeparatorColumn(this,e);}else {if(!this.isHelm())throw new Error(`Unexpected units '${this.column.meta.units}'.`);f.setUnitsToHelmColumn(this);}if(!this.column.tags.has(o.gp.alphabetIsMultichar))if(this.isHelm())this.column.setTag(o.gp.alphabetIsMultichar,\"true\");else if([\"UN\"].includes(this.alphabet))throw new Error(`For column '${this.column.name}' of alphabet '${this.alphabet}' tag '${o.gp.alphabetIsMultichar}' is mandatory.`);this.notationProvider=this.column.temp[d.notationProvider]??null,this.columnVersion=this.column.version;}static setUnitsToFastaColumn(t){if(t.column.semType!==i.SEMTYPE.MACROMOLECULE||t.column.meta.units!==o.Hi.FASTA)throw new Error(`The column of notation '${o.Hi.FASTA}' must be '${i.SEMTYPE.MACROMOLECULE}'.`);t.column.meta.units=o.Hi.FASTA,f.setTags(t);}static setUnitsToSeparatorColumn(t,e){if(t.column.semType!==i.SEMTYPE.MACROMOLECULE||t.column.meta.units!==o.Hi.SEPARATOR)throw new Error(`The column of notation '${o.Hi.SEPARATOR}' must be '${i.SEMTYPE.MACROMOLECULE}'.`);if(!e)throw new Error(`The column of notation '${o.Hi.SEPARATOR}' must have the separator tag.`);t.column.meta.units=o.Hi.SEPARATOR,t.column.setTag(o.gp.separator,e),f.setTags(t);}static setUnitsToHelmColumn(t){if(t.column.semType!==i.SEMTYPE.MACROMOLECULE)throw new Error(`The column of notation '${o.Hi.HELM}' must be '${i.SEMTYPE.MACROMOLECULE}'`);t.column.meta.units=o.Hi.HELM,f.setTags(t);}static setTags(t){const e=t.column.meta.units;if([o.Hi.FASTA,o.Hi.SEPARATOR].includes(e)){if(!t.column.getTag(o.gp.alphabet)&&0===Object.keys(t.stats.freq).length)throw new Error(\"Alphabet is empty and not annotated.\");let e=t.column.getTag(o.gp.aligned);null===e&&(e=t.stats.sameLength?\"SEQ.MSA\":\"SEQ\",t.column.setTag(o.gp.aligned,e));let n=t.column.getTag(o.gp.alphabet);if(null===n&&(n=(0, l.pc)(t.stats.freq,o.q7),t.column.setTag(o.gp.alphabet,n)),n===o.YI.UN){const e=Object.keys(t.stats.freq).length,n=Object.keys(t.stats.freq).some((t=>t.length>1));t.column.setTag(o.gp.alphabetSize,e.toString()),t.column.setTag(o.gp.alphabetIsMultichar,n?\"true\":\"false\");}}}get column(){return this._column}get length(){return this._column.length}get units(){return this._units}get notation(){return this._notation}get defaultGapOriginal(){return this._defaultGapOriginal}get separator(){const t=this.column.getTag(o.gp.separator)??void 0;if(this.notation===o.Hi.SEPARATOR&&void 0===t)throw new Error(`Separator is mandatory  for column '${this.column.name}' of notation '${this.notation}'.`);return t}get aligned(){const t=this.column.getTag(o.gp.aligned);if(!t&&(this.isFasta()||this.isSeparator()))throw new Error(\"Tag aligned not set\");return t}get alphabet(){const t=this.column.getTag(o.gp.alphabet);if(!t&&(this.isFasta()||this.isSeparator()))throw new Error(\"Tag alphabet not set\");return t}get helmCompatible(){return this.column.getTag(o.gp.isHelmCompatible)}getAlphabetSize(){if(this.notation==o.Hi.HELM||this.alphabet==o.YI.UN){const t=this.column.getTag(o.gp.alphabetSize);let e;if(t)e=parseInt(t);else {const t=this.stats;e=Object.keys(t.freq).length;}return e}switch(this.alphabet){case o.YI.PT:return 20;case o.YI.DNA:case o.YI.RNA:return 4;case\"NT\":return console.warn(\"Unexpected alphabet 'NT'.\"),4;default:throw new Error(`Unexpected alphabet '${this.alphabet}'.`)}}getAlphabetIsMultichar(){return this.notation===o.Hi.HELM||this.alphabet===o.YI.UN&&\"true\"===this.column.getTag(o.gp.alphabetIsMultichar)}getSplitted(t,e){if(this.cached&&void 0===e){this.column.version===this.columnVersion&&null!==this._splitted||(this.columnVersion=this.column.version,this._splitted=new Array(this.column.length));let e=this._splitted[t]?this._splitted[t].deref():void 0;if(!e){const n=this.column.get(t);e=this.splitter(n),this._splitted[t]=new WeakRef(e);}return e}{const n=this.column.get(t);return this.getSplitter(e)(n)}}async getHelm(t,e){const n=this.column.get(t);return this.notationProvider?(await this.notationProvider.getHelm(this.column,e)).get(t):this.convertToHelm(n)}get stats(){if(null===this._stats){const t={};let e=!0,n=null;const i=this.column.length;for(let r=0;r<i;++r){const i=this.getSplitted(r);null==n?n=i.length:i.length!==n&&(e=!1);for(const e of i.canonicals)e in t||(t[e]=0),t[e]+=1;}this._stats={freq:t,sameLength:e};}return this._stats}get maxLength(){return null===this._maxLength&&(this._maxLength=0===this.column.length?0:Math.max(...s().count(0).take(this.column.length).map((t=>this.getSplitted(t).length)))),this._maxLength}get posList(){if(null===this._posList){const t=this.column.getTag(o.gp.positionNames);this._posList=t?t.split(o.z1).map((t=>t.trim())):s().count(1).take(this.maxLength).map((t=>t.toString())).toArray();}return this._posList}isFasta(){return this.notation===o.Hi.FASTA}isSeparator(){return this.notation===o.Hi.SEPARATOR}isHelm(){return this.notation===o.Hi.HELM}isRna(){return this.alphabet===o.YI.RNA}isDna(){return this.alphabet===o.YI.DNA}isPeptide(){return this.alphabet===o.YI.PT}isMsa(){return !!this.aligned&&this.aligned.toUpperCase().includes(\"MSA\")}isHelmCompatible(){return \"true\"===this.helmCompatible}isGap(t){return !t||t===this._defaultGapOriginal}getNotation(){if(this.units.toLowerCase().startsWith(o.Hi.FASTA))return o.Hi.FASTA;if(this.units.toLowerCase().startsWith(o.Hi.SEPARATOR))return o.Hi.SEPARATOR;if(this.units.toLowerCase().startsWith(o.Hi.HELM))return o.Hi.HELM;throw new Error(`Column '${this.column.name}' has unexpected notation '${this.units}'.`)}getHelmWrappers(){return [this.isDna()||this.isRna()||this.isHelmCompatible()?\"RNA1{\":\"PEPTIDE1{\",this.isDna()?\"d(\":this.isRna()?\"r(\":\"\",this.isDna()||this.isRna()?\")p\":\"\",\"}$$$$\"]}getNewColumn(t,e,n,r){const s=this.column,a=t.toLowerCase()+\"(\"+s.name+\")\",l=n??s.dataFrame.columns.getUnusedName(a),h=i.Column.fromList(\"string\",l,r??new Array(this.column.length).fill(\"\"));if(h.semType=i.SEMTYPE.MACROMOLECULE,h.meta.units=t,t===o.Hi.SEPARATOR){if(!e)throw new Error(`Notation '${o.Hi.SEPARATOR}' requires separator value.`);h.setTag(o.gp.separator,e);}h.setTag(i.TAGS.CELL_RENDERER,t===o.Hi.HELM?\"helm\":\"sequence\");const c=s.getTag(o.gp.aligned);c&&h.setTag(o.gp.aligned,c);let u=s.getTag(o.gp.alphabet);u||this.notation!==o.Hi.HELM||t===o.Hi.HELM||(u=o.YI.UN),null!=u&&h.setTag(o.gp.alphabet,u);let d=s.getTag(o.gp.alphabetSize);null!=u&&d&&h.setTag(o.gp.alphabetSize,d);const g=s.getTag(o.gp.alphabetIsMultichar);return null!=u&&void 0!==g&&h.setTag(o.gp.alphabetIsMultichar,g),t==o.Hi.HELM&&(d=this.getAlphabetSize().toString(),h.setTag(o.gp.alphabetSize,d)),h}getNewColumnFromList(t,e){return this.getNewColumn(this.notation,this.separator,t,e)}static getNewColumn(t){const e=f.forColumn(t),n=e.notation;return e.getNewColumn(n)}static unitsStringIsValid(t){return t=t.toLowerCase(),[o.Hi.FASTA,o.Hi.SEPARATOR,o.Hi.HELM].some((e=>t.startsWith(e.toLowerCase())))}static getNewColumnFromParams(t,e,n){if(!f.unitsStringIsValid(n))throw new Error(\"Invalid format of 'units' parameter\");const r=i.Column.fromList(\"string\",e,new Array(t).fill(\"\"));return r.semType=i.SEMTYPE.MACROMOLECULE,r.meta.units=n,r}getSplitter(t){let e=null;if(e=this.notationProvider?this.notationProvider.splitter:null,e)return e;if(this.units.toLowerCase().startsWith(o.Hi.FASTA))return null===this.column.getTag(o.gp.alphabet)||this.getAlphabetIsMultichar()?o.J9:l.tm;if(this.units.toLowerCase().startsWith(o.Hi.SEPARATOR))return (0, o.dh)(this.separator,t);if(this.units.toLowerCase().startsWith(o.Hi.HELM))return o.qp;throw new Error(`Unexpected units ${this.units} .`)}split(t){return this.splitter(t)}getDistanceFunctionName(){if(!this.isFasta())throw new Error(\"Only FASTA notation is supported\");if(this.isMsa())return h.Z.HAMMING;switch(this.alphabet){case o.YI.DNA:case o.YI.RNA:case o.YI.PT:}return h.Z.LEVENSHTEIN}getDistanceFunction(){return h.V[this.getDistanceFunctionName()]()}async checkHelmCompatibility(){if(this.column.tags.has(o.gp.isHelmCompatible))return \"true\"===this.column.getTag(o.gp.isHelmCompatible);const t=(await async function(){const t=i.Func.find({package:\"Bio\",name:\"getMonomerLibHelper\"});if(0===t.length)throw new Error('Package \"Bio\" must be installed for MonomerLibHelper.');return (await t[0].prepare().call()).getOutputParamValue()}()).getMonomerLib().getMonomerSymbolsByType(\"PEPTIDE\"),e=new Set(t),n=((0, o.dh)(this.separator),new Set),r=this.column.length,s=this.column.getRawData();for(let t=0;t<r;++t){const i=s[t];if(!(i in n)){n.add(i);const r=this.getSplitted(t);for(const t of r.canonicals)if(!e.has(t))return this.column.setTag(o.gp.isHelmCompatible,\"false\"),!1}}return this.column.setTag(o.gp.isHelmCompatible,\"true\"),!0}get splitter(){return null===this._splitter&&(this._splitter=this.getSplitter()),this._splitter}toFasta(t){return t===o.Hi.FASTA}toSeparator(t){return t===o.Hi.SEPARATOR}toHelm(t){return t===o.Hi.HELM}convertHelmToFastaSeparator(t,e,n,i){i||(i=this.toFasta(e)?g[o.Hi.FASTA]:g[o.Hi.SEPARATOR]),n||(n=this.toFasta(e)?\"\":this.separator);const r=t.startsWith(\"RNA\"),s=this.splitter(t),a=[];for(let t=0;t<s.length;++t){let n=s.getOriginal(t);if(r&&(n=n.replace(u,\"\")),n===g[o.Hi.HELM])a.push(i);else if(this.toFasta(e)&&n.length>1){const t=\"[\"+n+\"]\";a.push(t);}else a.push(n);}return a.join(n)}convert(t,e){const n=this.getJoiner({notation:t,separator:e}),i=this.getNewColumn(t,e);return i.init((t=>{const e=this.getSplitted(t);return n(e)})),i}getRegion(t,e,n){const i=this.getNewColumn(this.notation,this.separator);i.name=n;const r=t??0,s=e??this.maxLength-1,a=this.getJoiner(),h=s-r+1,c=g[this.notation];i.init((t=>{const e=this.getSplitted(t),n=new Array(h);for(let t=0;t<h;++t){const i=r+t;n[t]=i<e.length?e.getOriginal(i):c;}return a(new l.Mu(n,c))}));const u=t=>{const e=t.split(\",\").map((t=>t.trim())),n=new Array(h);for(let t=0;t<h;++t){const i=r+t;n[t]=i<e.length?e[i]:\"?\";}return n.join(o.z1)},d=this.column.getTag(o.gp.positionNames);d&&i.setTag(o.gp.positionNames,u(d));const f=this.column.getTag(o.gp.positionLabels);return f&&i.setTag(o.gp.positionLabels,u(f)),i}get joiner(){return this._joiner||(this._joiner=this.getJoiner()),this._joiner}getJoiner(t){const e=t?t.notation:this.notation,n=t?t.separator:this.separator;let i;const r=this;switch(e){case o.Hi.FASTA:i=function(t){return r.joinToFasta(t,r.isHelm())};break;case o.Hi.SEPARATOR:if(!n)throw new Error(`Separator is mandatory for notation '${e}'.`);i=function(t){return m(t,n,r.isHelm())};break;case o.Hi.HELM:{const t=r.alphabet===o.YI.DNA||r.alphabet===o.YI.RNA,e=r.getHelmWrappers();i=function(n){return p(n,e,t)};break}default:throw new Error(`Unexpected notation '${e}'.`)}return i}getConverter(t,e=void 0){if(t===o.Hi.SEPARATOR&&!e)throw new Error(`Target separator is not specified for target units '${o.Hi.SEPARATOR}'.`);const n=this;if(t===o.Hi.FASTA)return function(t){return n.convertToFasta(t)};if(t===o.Hi.HELM)return function(t){return n.convertToHelm(t)};if(t===o.Hi.SEPARATOR)return function(t){return n.convertToSeparator(t,e)};throw new Error}static forColumn(t){let e=t.temp[d.seqHandler];return e&&e.columnVersion===t.version||(e=t.temp[d.seqHandler]=new f(t)),e}joinToFasta(t,e){const n=new Array(t.length);for(let i=0;i<t.length;++i){const r=t.getOriginal(i);let s=t.getOriginal(i);e&&(s=s.replace(u,\"$1\")),r===a._S?s=g[o.Hi.FASTA]:r===c?s=\"\":s.length>1&&(s=\"[\"+s+\"]\"),n[i]=s;}return n.join(\"\")}convertToFasta(t){const e=this.splitter,n=this.isHelm()?this.splitterAsHelmNucl(t):e(t);return this.joinToFasta(n,this.isHelm())}convertToSeparator(t,e){return m(this.isHelm()?this.splitterAsHelmNucl(t):this.splitter(t),e,this.isHelm())}convertToHelm(t){if(this.notation==o.Hi.HELM)return t;const e=this.getHelmWrappers(),n=t.startsWith(\"DNA\")||t.startsWith(\"RNA\");return p(this.splitter(t),e,n)}splitterAsHelmNucl(t){const e=this.splitter(t),n=new Array(e.length),i=t.startsWith(\"DNA\"),r=t.startsWith(\"RNA\");for(let t=0;t<e.length;++t){let s=e.getOriginal(t);(i||r)&&(s=s.replace(u,\"$1\"),s=s===c?null:s),n[t]=s||null;}return new l.Mu(n.filter((t=>!!t)),g[o.Hi.HELM])}}function m(t,e,n){const i=new Array(t.length);for(let e=0;e<t.length;++e){const r=t.getCanonical(e);let s=t.getOriginal(e);n&&(s=s.replace(u,\"$1\")),r===a._S?s=g[o.Hi.SEPARATOR]:r===c&&(s=\"\"),i[e]=s;}return i.join(e)}function p(t,e,n){const[i,r,s,l]=e,h=new Array(t.length);for(let e=0;e<t.length;++e){const i=t.getCanonical(e);let l=t.getOriginal(e);i===a._S?l=g[o.Hi.HELM]:(n&&(l=l.replace(u,\"$1\")),l=1===l.length?`${r}${l}${s}`:`${r}[${l}]${s}`),h[e]=l;}return `${i}${h.join(\".\")}${l}`}},1537:(t,e,n)=>{n.d(e,{C4:()=>u});var i,r,s,o,a,l,h,c=function(t,e,n,i){return new(n||(n=Promise))((function(r,s){function o(t){try{l(i.next(t));}catch(t){s(t);}}function a(t){try{l(i.throw(t));}catch(t){s(t);}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e);}))).then(o,a);}l((i=i.apply(t,[])).next());}))};function u(t,e,i){return c(this,void 0,void 0,(function*(){return new Promise((function(r,s){const o=new Worker(new URL(n.p+n.u(705),n.b));o.postMessage({distMatArray:t,n:e,methodCode:i}),o.onmessage=({data:{error:t,clusterMatrix:e}})=>{o.terminate(),t?s(t):r(e);};}))}))}n(5540),(r=i||(i={})).EUCLIDEAN=\"EUCLIDEAN\",r.MANHATTAN=\"MANHATTAN\",i.EUCLIDEAN,i.MANHATTAN,(o=s||(s={})).HAMMING=\"Hamming\",o.EUCLIDEAN=\"Euclidean\",o.MANHATTAN=\"Manhattan\",o.TANIMOTO=\"Tanimoto\",o.LEVENSTEIN=\"Levenshtein\",o.NEEDLEMAN_WUNSCH=\"Needlemann-Wunsch\",o.MONOMER_CHEMICAL_DISTANCE=\"Monomer chemical distance\",o.SOKAL=\"Sokal\",o.COSINE=\"Cosine\",o.ASYMMETRIC=\"Asymmetric\",o.Difference=\"Difference\",o.OneHot=\"One-Hot\",s.HAMMING,s.EUCLIDEAN,s.MANHATTAN,s.TANIMOTO,s.LEVENSTEIN,s.NEEDLEMAN_WUNSCH,s.MONOMER_CHEMICAL_DISTANCE,s.SOKAL,s.COSINE,s.ASYMMETRIC,s.Difference,s.OneHot,s.HAMMING,s.EUCLIDEAN,s.MANHATTAN,s.TANIMOTO,s.SOKAL,s.COSINE,s.ASYMMETRIC,s.LEVENSTEIN,s.NEEDLEMAN_WUNSCH,s.MONOMER_CHEMICAL_DISTANCE,s.Difference,s.OneHot,new Set([s.HAMMING,s.LEVENSTEIN,s.NEEDLEMAN_WUNSCH,s.MONOMER_CHEMICAL_DISTANCE,s.OneHot]),new Set([s.HAMMING,s.EUCLIDEAN,s.MANHATTAN,s.MONOMER_CHEMICAL_DISTANCE,s.LEVENSTEIN,s.NEEDLEMAN_WUNSCH,s.TANIMOTO,s.COSINE,s.SOKAL,s.ASYMMETRIC,s.OneHot,s.Difference]),new Set([s.EUCLIDEAN,s.MANHATTAN,s.OneHot,s.Difference]),new Set([s.EUCLIDEAN,s.MANHATTAN,s.Difference]),new Set([s.EUCLIDEAN,s.MANHATTAN,s.Difference]),new Set([s.TANIMOTO,s.COSINE,s.SOKAL,s.ASYMMETRIC]),function(t){t.ADD=\"ADD\",t.SUB=\"SUB\",t.MULT=\"MULT\";}(a||(a={})),function(t){t.SQUARE=\"SQUARE\",t.INVERSE=\"INVERSE\",t.TRANSPOSE=\"TRANSPOSE\",t.NORM=\"NORM\",t.COLUMN_NORM=\"COLUMN_NORM\";}(l||(l={})),function(t){t.SCALARMULT=\"SCALARMULT\",t.SCALARADD=\"SCALARADD\",t.SCALARPOW=\"SCALARPOW\";}(h||(h={}));},5540:(t,e,n)=>{t=n.hmd(t);var i,r=(i=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(t={}){var e,n,r=void 0!==t?t:{};r.ready=new Promise((function(t,i){e=t,n=i;}));var s,o=Object.assign({},r),a=\"object\"==typeof window,l=\"function\"==typeof importScripts,h=(\"\");(a||l)&&(l?h=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(h=document.currentScript.src),i&&(h=i),h=0!==h.indexOf(\"blob:\")?h.substr(0,h.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",l&&(s=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)})),r.print||console.log.bind(console);var c,u,d=r.printErr||console.warn.bind(console);Object.assign(r,o),o=null,r.arguments&&r.arguments,r.thisProgram&&r.thisProgram,r.quit&&r.quit,r.wasmBinary&&(c=r.wasmBinary),r.noExitRuntime,\"object\"!=typeof WebAssembly&&S(\"no native wasm support detected\");var g,f,m,p=!1;function C(){var t=u.buffer;r.HEAP8=g=new Int8Array(t),r.HEAP16=new Int16Array(t),r.HEAP32=new Int32Array(t),r.HEAPU8=f=new Uint8Array(t),r.HEAPU16=new Uint16Array(t),r.HEAPU32=m=new Uint32Array(t),r.HEAPF32=new Float32Array(t),r.HEAPF64=new Float64Array(t);}var w=[],b=[],_=[],v=0,A=null;function S(t){r.onAbort&&r.onAbort(t),d(t=\"Aborted(\"+t+\")\"),p=!0,t+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(t);throw n(e),e}var T,E;function O(t){return t.startsWith(\"data:application/octet-stream;base64,\")}function N(t){try{if(t==T&&c)return new Uint8Array(c);if(s)return s(t);throw \"both async and sync fetching of the wasm failed\"}catch(t){S(t);}}function L(t,e,n){return function(t){return c||!a&&!l||\"function\"!=typeof fetch?Promise.resolve().then((function(){return N(t)})):fetch(t,{credentials:\"same-origin\"}).then((function(e){if(!e.ok)throw \"failed to load wasm binary file at '\"+t+\"'\";return e.arrayBuffer()})).catch((function(){return N(t)}))}(t).then((function(t){return WebAssembly.instantiate(t,e)})).then((function(t){return t})).then(n,(function(t){d(\"failed to asynchronously prepare wasm: \"+t),S(t);}))}function M(t){for(;t.length>0;)t.shift()(r);}function R(t){this.excPtr=t,this.ptr=t-24,this.set_type=function(t){m[this.ptr+4>>2]=t;},this.get_type=function(){return m[this.ptr+4>>2]},this.set_destructor=function(t){m[this.ptr+8>>2]=t;},this.get_destructor=function(){return m[this.ptr+8>>2]},this.set_caught=function(t){t=t?1:0,g[this.ptr+12|0]=t;},this.get_caught=function(){return 0!=g[this.ptr+12|0]},this.set_rethrown=function(t){t=t?1:0,g[this.ptr+13|0]=t;},this.get_rethrown=function(){return 0!=g[this.ptr+13|0]},this.init=function(t,e){this.set_adjusted_ptr(0),this.set_type(t),this.set_destructor(e);},this.set_adjusted_ptr=function(t){m[this.ptr+16>>2]=t;},this.get_adjusted_ptr=function(){return m[this.ptr+16>>2]},this.get_exception_ptr=function(){if($(this.get_type()))return m[this.excPtr>>2];var t=this.get_adjusted_ptr();return 0!==t?t:this.excPtr};}function I(t){var e=u.buffer;try{return u.grow(t-e.byteLength+65535>>>16),C(),1}catch(t){}}function x(t){return r[\"_\"+t]}O(T=\"wasmDbscan.wasm\")||(E=T,T=r.locateFile?r.locateFile(E,h):h+E);var H=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function D(t,e,n,i,r){var s={string:t=>{var e=0;return null!=t&&0!==t&&(e=function(t){var e=function(t){for(var e=0,n=0;n<t.length;++n){var i=t.charCodeAt(n);i<=127?e++:i<=2047?e+=2:i>=55296&&i<=57343?(e+=4,++n):e+=3;}return e}(t)+1,n=B(e);return function(t,e,n){!function(t,e,n,i){if(!(i>0))return 0;for(var r=n+i-1,s=0;s<t.length;++s){var o=t.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++s)),o<=127){if(n>=r)break;e[n++]=o;}else if(o<=2047){if(n+1>=r)break;e[n++]=192|o>>6,e[n++]=128|63&o;}else if(o<=65535){if(n+2>=r)break;e[n++]=224|o>>12,e[n++]=128|o>>6&63,e[n++]=128|63&o;}else {if(n+3>=r)break;e[n++]=240|o>>18,e[n++]=128|o>>12&63,e[n++]=128|o>>6&63,e[n++]=128|63&o;}}e[n]=0;}(t,f,e,n);}(t,n,e),n}(t)),e},array:t=>{var e,n,i=B(t.length);return e=t,n=i,g.set(e,n),i}},o=x(t),a=[],l=0;if(i)for(var h=0;h<i.length;h++){var c=s[n[h]];c?(0===l&&(l=F()),a[h]=c(i[h])):a[h]=i[h];}var u=o.apply(null,a);return function(t){return 0!==l&&V(l),function(t){return \"string\"===e?(n=t)?function(t,e,n){for(var i=e+n,r=e;t[r]&&!(r>=i);)++r;if(r-e>16&&t.buffer&&H)return H.decode(t.subarray(e,r));for(var s=\"\";e<r;){var o=t[e++];if(128&o){var a=63&t[e++];if(192!=(224&o)){var l=63&t[e++];if((o=224==(240&o)?(15&o)<<12|a<<6|l:(7&o)<<18|a<<12|l<<6|63&t[e++])<65536)s+=String.fromCharCode(o);else {var h=o-65536;s+=String.fromCharCode(55296|h>>10,56320|1023&h);}}else s+=String.fromCharCode((31&o)<<6|a);}else s+=String.fromCharCode(o);}return s}(f,n,i):\"\":\"boolean\"===e?Boolean(t):t;var n,i;}(t)}(u)}var k,P={__cxa_throw:function(t,e,n){throw new R(t).init(e,n),t},abort:function(){S(\"\");},emscripten_memcpy_big:function(t,e,n){f.copyWithin(t,e,e+n);},emscripten_resize_heap:function(t){var e,n=f.length,i=2147483648;if((t>>>=0)>i)return !1;for(var r=1;r<=4;r*=2){var s=n*(1+.2/r);if(s=Math.min(s,t+100663296),I(Math.min(i,(e=Math.max(t,s))+(65536-e%65536)%65536)))return !0}return !1}},F=(function(){var t,e,i,s,o={env:P,wasi_snapshot_preview1:P};function a(t,e){var n,i=t.exports;return r.asm=i,u=r.asm.memory,C(),r.asm.__indirect_function_table,n=r.asm.__wasm_call_ctors,b.unshift(n),function(){if(v--,r.monitorRunDependencies&&r.monitorRunDependencies(v),0==v&&(A)){var t=A;A=null,t();}}(),i}if(v++,r.monitorRunDependencies&&r.monitorRunDependencies(v),r.instantiateWasm)try{return r.instantiateWasm(o,a)}catch(t){d(\"Module.instantiateWasm callback failed with error: \"+t),n(t);}(t=c,e=T,i=o,s=function(t){a(t.instance);},t||\"function\"!=typeof WebAssembly.instantiateStreaming||O(e)||\"function\"!=typeof fetch?L(e,i,s):fetch(e,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(s,(function(t){return d(\"wasm streaming compile failed: \"+t),d(\"falling back to ArrayBuffer instantiation\"),L(e,i,s)}))}))).catch(n);}(),r._dbscan=function(){return (r._dbscan=r.asm.dbscan).apply(null,arguments)},r._malloc=function(){return (r._malloc=r.asm.malloc).apply(null,arguments)},r._free=function(){return (r._free=r.asm.free).apply(null,arguments)},function(){return (F=r.asm.stackSave).apply(null,arguments)}),V=function(){return (V=r.asm.stackRestore).apply(null,arguments)},B=function(){return (B=r.asm.stackAlloc).apply(null,arguments)},$=function(){return ($=r.asm.__cxa_is_pointer_type).apply(null,arguments)};function W(){function t(){k||(k=!0,r.calledRun=!0,p||(M(b),e(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),function(){if(r.postRun)for(\"function\"==typeof r.postRun&&(r.postRun=[r.postRun]);r.postRun.length;)t=r.postRun.shift(),_.unshift(t);var t;M(_);}()));}v>0||(function(){if(r.preRun)for(\"function\"==typeof r.preRun&&(r.preRun=[r.preRun]);r.preRun.length;)t=r.preRun.shift(),w.unshift(t);var t;M(w);}(),v>0||(r.setStatus?(r.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){r.setStatus(\"\");}),1),t();}),1)):t()));}if(r.ccall=D,r.cwrap=function(t,e,n,i){var r=!n||n.every((t=>\"number\"===t||\"boolean\"===t));return \"string\"!==e&&r&&!i?x(t):function(){return D(t,e,n,arguments)}},A=function t(){k||W(),k||(A=t);},r.preInit)for(\"function\"==typeof r.preInit&&(r.preInit=[r.preInit]);r.preInit.length>0;)r.preInit.pop()();return W(),t.ready});t.exports=r;},7120:(t,e,n)=>{var i,r;n.d(e,{Hc:()=>o,AY:()=>a}),(r=i||(i={})).EUCLIDEAN=\"EUCLIDEAN\",r.MANHATTAN=\"MANHATTAN\";const s=t=>null==t;class o{get data(){return this._data}get size(){return this._size}constructor(t,e){if(null==e){if(null==t)throw new Error(\"Arguments error: data or size is required.\");if(this._data=t,this._size=(1+Math.sqrt(1+8*this._data.length))/2,this._size!=Math.floor(this._size))throw new Error(`Invalid data length ${this._data.length} leads to non integer size ${this._size}`)}else {this._size=e;const n=e*(e-1)/2;if(t){if(t.length!=n)throw new Error(`Invalid data length. Observations size ${e} requires data length ${n}.`);this._data=t;}else this._data=new Float32Array(n);}}_linearizeIJ(t,e){if(!(t<e))throw new Error(\"i must be less than j\");return this._size*t+e-Math.floor((t+2)*(t+1)/2)}get(t,e){return t==e?0:t<e?this._data[this._linearizeIJ(t,e)]:this._data[this._linearizeIJ(e,t)]}set(t,e,n){this._data[this._linearizeIJ(t,e)]=n;}static calc(t,e){const n=t.length,i=new o(void 0,n);for(let r=0;r<n;r++)for(let o=r+1;o<n;o++)i.set(r,o,s(t[r])||s(t[o])?1:e(t[r],t[o]));return i}square(){for(let t=0;t<this._data.length;t++)this._data[t]=this._data[t]**2;}add(t){if(this._size!==t._size)throw new Error(`Matrices must have the same size. This size: ${this._size}, other size: ${t._size}`);for(let e=0;e<this._data.length;e++)this._data[e]+=t._data[e];}sqrt(){for(let t=0;t<this._data.length;t++)this._data[t]=Math.sqrt(this._data[t]);}normalize(){let t=0,e=this._data[0];for(let n=0;n<this._data.length;n++)this._data[n]<t&&(t=this._data[n]),this._data[n]>e&&(e=this._data[n]);const n=e-t;for(let i=0;i<this._data.length;i++)this._data[i]=0===n?this._data[i]-t:(this._data[i]-t)/(e-t);}}class a{constructor(t=!0,e=!0){const i=navigator.hardwareConcurrency;this._workerCount=t?Math.max(i-2,1):1,this._workers=new Array(this._workerCount).fill(null).map((()=>new Worker(new URL(n.p+n.u(79),n.b)))),this._terminateOnComplete=e;}async calc(t,e,n=!0,r){return await this.calcMulti([t],[e],n,[r??{}],[1],i.MANHATTAN)}async calcMulti(t,e,n=!0,r=[{}],s=[1],o=i.MANHATTAN){if(t.length<1)throw new Error(\"values must contain at least one array\");if(e.length!==t.length||r.length!==t.length||s.length!==t.length)throw new Error(\"values, fnNames, weights and opts must have the same length\");return new Promise((async(i,a)=>{try{const a=t[0].length,l=new Array(this._workerCount),h=a*(a-1)/2;this._workerCount=Math.min(this._workerCount,h);const c=h/this._workerCount,u=new Float32Array(h);let d=0,g=1,f=0,m=Number.MIN_VALUE;for(let n=0;n<this._workerCount;n++){const i=Math.floor(n*c),p=n===this._workerCount-1?h:Math.floor((n+1)*c),C=d,w=g;n!==this._workerCount-1&&(d=a-2-Math.floor(Math.sqrt(-8*p+4*a*(a-1)-7)/2-.5),g=p-a*d+Math.floor((d+1)*(d+2)/2)),this._workers[n].postMessage({values:t,fnNames:e,startRow:C,startCol:w,chunckSize:p-i,opts:r,weights:s,aggregationMethod:o}),l[n]=new Promise(((t,e)=>{this._workers[n].onmessage=({data:{error:r,distanceMatrixData:s,min:o,max:a}})=>{this._terminateOnComplete&&setTimeout((()=>this._workers[n].terminate())),r?e(r):(u.set(s,i),o<f&&(f=o),a>m&&(m=a),t());};}));}await Promise.all(l),n&&u.forEach(((t,e)=>{u[e]=(t-f)/(m-f);})),i(u);}catch(t){a(t);}}))}terminate(){this._workers.forEach((t=>t.terminate()));}}},6295:(t,e,n)=>{n.d(e,{Hr:()=>y,Ii:()=>g,T6:()=>v,TK:()=>b,a4:()=>u,be:()=>d,gt:()=>p,ij:()=>C,lO:()=>c,lP:()=>m,rR:()=>f,tO:()=>a,v_:()=>l,yK:()=>w,zn:()=>h});var i=n(8774),r=n(8498),s=n(4572);function o(t,e){const n=t.trueCount()+e.trueCount();if(0==n)return 1;const i=t.andWithCountBits(e,!0);return i/(n-i)}function a(t,e){return 1-o(t,e)}function l(t,e){return _(o(new i.A(t,32*t.length),new i.A(e,32*e.length)))}function h(t,e){return 1-function(t,e){const n=t.trueCount()+e.trueCount();return 0==n?0:2*t.andWithCountBits(e,!0)/n}(t,e)}function c(t,e){return 1-function(t,e){const n=t.trueCount()*e.trueCount();return 0==n?0:t.andWithCountBits(e,!0)/Math.sqrt(n)}(t,e)}function u(t,e){return Math.sqrt(t.trueCount()+e.trueCount()-2*t.andWithCountBits(e,!0))}function d(t,e){return t.trueCount()+e.trueCount()-2*t.andWithCountBits(e,!0)}function g(t,e){return 1-function(t,e){const n=t.trueCount()+e.trueCount(),i=t.andWithCountBits(e,!0);return i/(2*n-3*i)}(t,e)}function f(t,e){return _(function(t,e){const n=t.trueCount()+e.trueCount(),i=t.trueCount()*e.trueCount();return 0==i?0:t.andWithCountBits(e,!0)*n/(2*i)}(t,e))}function m(t,e){return _(function(t,e){const n=t.trueCount()+e.trueCount(),i=t.trueCount()*e.trueCount();return 0==i?0:(t.andWithCountBits(e,!0)*n-i)/i}(t,e))}function p(t,e){return 1-function(t,e){const n=Math.min(t.trueCount(),e.trueCount());return 0==n?0:t.andWithCountBits(e,!0)/n}(t,e)}function C(t,e){return _(function(t,e){const n=Math.max(t.trueCount(),e.trueCount());return 0==n?0:t.andWithCountBits(e,!0)/n}(t,e))}function w(t,e){return _(function(t,e){return 0==t.length?0:t.andWithCountBits(e,!0)/t.length}(t,e))}function b(t,e){return _(function(t,e){const n=t.andWithCountBits(e,!0),i=t.countBits(!0)+e.countBits(!0),r=t.length,s=r-i+n;return n==r||s==r?1:n/i+s/(2*r-i)}(t,e))}function _(t){return 0===t?3402823e32:1/t-1}function v(t){if(t&&null!=t.range&&t.range>0){const e=t.range;return (t,n)=>Math.abs(t-n)/e}return (t,e)=>Math.abs(t-e)}function y(t){const e=function(t){const e=t?.mostCommon??new Set;return (t,n)=>{const i=t.length,r=n.length;let s=0,o=0,a=0;for(;o<i&&a<r;)t[o]===n[a]?(e?.has(t[o])||++s,++o,++a):t[o]<n[a]?++o:++a;return s}}(t);return (t,n)=>0===n.length||0===t.length?1e4:Math.min(t.length,n.length)/(e(t,n)+1e-4)}r.aT.Tanimoto,r.aT.Dice,r.aT.Asymmetric,r.aT.BraunBlanquet,r.aT.Cosine,r.aT.Kulczynski,r.aT.McConnaughey,r.aT.RogotGoldberg,r.aT.Russel,r.aT.Sokal,r.aT.Hamming,r.aT.Euclidean,r.aT.Tanimoto,r.aT.Dice,r.aT.Asymmetric,r.aT.BraunBlanquet,r.aT.Cosine,r.aT.Kulczynski,r.aT.McConnaughey,r.aT.RogotGoldberg,r.aT.Russel,r.aT.Sokal,r.aT.Hamming,r.aT.Euclidean,r.aT.Tanimoto,r.aT.Dice,r.aT.Cosine,r.aT.Tanimoto,r.aT.Asymmetric,r.aT.Cosine,r.aT.Sokal,s.Z.HAMMING,s.Z.LEVENSHTEIN,s.Z.MONOMER_CHEMICAL_DISTANCE,s.Z.NEEDLEMANN_WUNSCH;},5395:(t,e,n)=>{function i(t={}){const e=function(){if(!t||!t.scoringMatrix||!t.alphabetIndexes)return (t,e)=>t===e?0:1;if(t.scoringMatrix.length!==Object.keys(t.alphabetIndexes).length)throw new Error(\"Scoring matrix and alphabet indexes should have the same length\");const e=t.alphabetIndexes,n=t.scoringMatrix,i=Math.min(...Object.keys(e).map((t=>t.charCodeAt(0))))+1,r=new Float32Array((n.length+i)*(n.length+i));return Object.entries(e).forEach((([t,i])=>{const s=n[i];Object.entries(e).forEach((([e,i])=>{r[t.charCodeAt(0)*n.length+e.charCodeAt(0)]=s[i];}));})),(t,e)=>1-r[t.charCodeAt(0)*n.length+e.charCodeAt(0)]}(),n=t?.threshold??0;return (t,i)=>{let r=0;const s=t.length,o=i.length,a=Math.ceil(Math.max(s,o)*(1-n));s!==o&&(r=Math.abs(s-o));let l=0;for(let n=0;n<Math.min(s,o);n++)if(t[n]!==i[n]&&(l+=e(t[n],i[n]),l>a))return 1;return l+=r,l/=Math.max(s,o),l}}n.d(e,{k:()=>i});},4572:(t,e,n)=>{n.d(e,{V:()=>i.V,Z:()=>i.Z});var i=n(2362);},3359:(t,e,n)=>{n.d(e,{Q:()=>r});var i=n(2787);function r(){return (t,e)=>(0, i.I)(t,e)/Math.max(t.length,e.length)}},2362:(t,e,n)=>{n.d(e,{V:()=>a,Z:()=>i});var i,r=n(5395),s=n(3359),o=n(250);!function(t){t.HAMMING=\"Hamming\",t.LEVENSHTEIN=\"Levenshtein\",t.NEEDLEMANN_WUNSCH=\"Needlemann-Wunsch\",t.MONOMER_CHEMICAL_DISTANCE=\"Monomer chemical distance\";}(i||(i={}));const a={[i.HAMMING]:r.k,[i.LEVENSHTEIN]:s.Q,[i.NEEDLEMANN_WUNSCH]:o.i,[i.MONOMER_CHEMICAL_DISTANCE]:r.k};},250:(t,e,n)=>{n.d(e,{i:()=>r});const i={gapOpen:1,gapExtend:.6,scoringMatrix:[[4,-1,-2,-2,0,-1,-1,0,-2,-1,-1,-1,-1,-2,-1,1,0,-3,-2,0,-2,-1,0,-4],[-1,5,0,-2,-3,1,0,-2,0,-3,-2,2,-1,-3,-2,-1,-1,-3,-2,-3,-1,0,-1,-4],[-2,0,6,1,-3,0,0,0,1,-3,-3,0,-2,-3,-2,1,0,-4,-2,-3,3,0,-1,-4],[-2,-2,1,6,-3,0,2,-1,-1,-3,-4,-1,-3,-3,-1,0,-1,-4,-3,-3,4,1,-1,-4],[0,-3,-3,-3,9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-3,-3,-2,-4],[-1,1,0,0,-3,5,2,-2,0,-3,-2,1,0,-3,-1,0,-1,-2,-1,-2,0,3,-1,-4],[-1,0,0,2,-4,2,5,-2,0,-3,-3,1,-2,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4],[0,-2,0,-1,-3,-2,-2,6,-2,-4,-4,-2,-3,-3,-2,0,-2,-2,-3,-3,-1,-2,-1,-4],[-2,0,1,-1,-3,0,0,-2,8,-3,-3,-1,-2,-1,-2,-1,-2,-2,2,-3,0,0,-1,-4],[-1,-3,-3,-3,-1,-3,-3,-4,-3,4,2,-3,1,0,-3,-2,-1,-3,-1,3,-3,-3,-1,-4],[-1,-2,-3,-4,-1,-2,-3,-4,-3,2,4,-2,2,0,-3,-2,-1,-2,-1,1,-4,-3,-1,-4],[-1,2,0,-1,-3,1,1,-2,-1,-3,-2,5,-1,-3,-1,0,-1,-3,-2,-2,0,1,-1,-4],[-1,-1,-2,-3,-1,0,-2,-3,-2,1,2,-1,5,0,-2,-1,-1,-1,-1,1,-3,-1,-1,-4],[-2,-3,-3,-3,-2,-3,-3,-3,-1,0,0,-3,0,6,-4,-2,-2,1,3,-1,-3,-3,-1,-4],[-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4,7,-1,-1,-4,-3,-2,-2,-1,-2,-4],[1,-1,1,0,-1,0,0,0,-1,-2,-2,0,-1,-2,-1,4,1,-3,-2,-2,0,0,0,-4],[0,-1,0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1,1,5,-2,-2,0,-1,-1,0,-4],[-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1,1,-4,-3,-2,11,2,-3,-4,-3,-2,-4],[-2,-2,-2,-3,-2,-1,-2,-3,2,-1,-1,-2,-1,3,-3,-2,-2,2,7,-1,-3,-2,-1,-4],[0,-3,-3,-3,-1,-2,-2,-3,-3,3,1,-2,1,-1,-2,-2,0,-3,-1,4,-3,-2,-1,-4],[-2,-1,3,4,-3,0,1,-1,0,-3,-4,0,-3,-3,-2,0,-1,-4,-3,-3,4,1,-1,-4],[-1,0,0,1,-3,3,4,-2,0,-3,-3,1,-1,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4],[0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2,0,0,-2,-1,-1,-1,-1,-1,-4],[-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,1]],alphabetIndexes:{A:0,R:1,N:2,D:3,C:4,Q:5,E:6,G:7,H:8,I:9,L:10,K:11,M:12,F:13,P:14,S:15,T:16,W:17,Y:18,V:19,B:20,Z:21,X:22,\"*\":23}};function r(t){const e=new Uint16Array(65536),{gapOpen:n,gapExtend:r,scoringMatrix:s,alphabetIndexes:o}={...i,...t};Object.entries(o).forEach((([t,n])=>e[t.charCodeAt(0)]=n));const a=[new Float32Array(1e4),new Float32Array(1e4)];return (t,i)=>{const o=new Array(t.length+1).fill(!1),l=new Array(t.length+1).fill(!1);let h=0,c=1;for(let e=1;e<t.length+1;e++)a[0][e]=-r-(e-1)*r,a[1][e]=0;a[0][0]=0;for(let u=1;u<i.length+1;u++){a[c][0]=-r-(u-1)*r;for(let d=1;d<t.length+1;d++){const g=a[h][d-1]+s[e[t.charCodeAt(d-1)]][e[i.charCodeAt(u-1)]],f=a[h][d]-(o[d]||1===u||u===i.length?r:n),m=a[c][d-1]-(l[d-1]||1===d||d===t.length?r:n);a[c][d]=Math.max(g,m,f),a[c][d]===g?(o[d]=!1,l[d]=!1):a[c][d]===m?(o[d]=!1,l[d]=!0):(o[d]=!0,l[d]=!1);}h=c,c=(c+1)%2;}const u=Math.min(t.length,i.length);return (u-a[h][t.length])/u}}},8498:(t,e,n)=>{var i,r,s,o,a,l,h;n.d(e,{EG:()=>a,Pn:()=>r,RR:()=>l,Wn:()=>h,aT:()=>s,m6:()=>o,xL:()=>i}),function(t){t.Levenshtein=\"Levenshtein\",t.JaroWinkler=\"Jaro-Winkler\",t.Manhattan=\"Manhattan\",t.Onehot=\"One-Hot\";}(i||(i={})),function(t){t.Euclidean=\"Euclidean\";}(r||(r={})),function(t){t.Tanimoto=\"Tanimoto\",t.Dice=\"Dice\",t.Asymmetric=\"Asymmetric\",t.BraunBlanquet=\"Braun-Blanquet\",t.Cosine=\"Cosine\",t.Kulczynski=\"Kulczynski\",t.McConnaughey=\"Mc-Connaughey\",t.RogotGoldberg=\"Rogot-Goldberg\",t.Russel=\"Russel\",t.Sokal=\"Sokal\",t.Hamming=\"Hamming\",t.Euclidean=\"Euclidean\";}(s||(s={})),function(t){t.TanimotoIntArray=\"TanimotoIntArray\";}(o||(o={})),function(t){t.Vector=\"Vector\",t.String=\"String\",t.BitArray=\"BitArray\",t.MacroMolecule=\"MacroMolecule\",t.Number=\"Number\",t.IntArray=\"IntArray\",t.NumberArray=\"NumberArray\";}(a||(a={})),function(t){t.Difference=\"Difference\";}(l||(l={})),function(t){t.CommonItems=\"Common Items\";}(h||(h={}));},8774:(t,e,n)=>{n.d(e,{A:()=>i});class i{constructor(t,e=!1){if(this._length=0,this._version=0,this._updateLevel=0,this._selectedCount=0,this._selectedCountVersion=-1,this._selectedIndexesVersion=-1,this._versionedName=\"\",this._versionedNameVersion=-1,this.SHRINK_THRESHOLD=256,\"number\"==typeof t){const n=t,r=i._createBuffer(n);if(e)for(let t=0;t<r.length;t++)r[t]=-1;this._data=r,this._length=n;}else {if(!(t instanceof Uint32Array))throw new Error(\"Invalid constructor\");this._data=t,this._length=e;}}getRawData(){return this._data}assureGoez(t,e){if(t<0)throw new Error(`${e} should be greater than zero`)}assureInRange(t,e,n,i){if(t<e||t>n)throw new Error(`Argument ${i} (${t}) out of range (${e}, ${n})`)}copy(t,e,n){for(let i=0;i<n;i++)e[i]=t[i];}copyFrom(t){if(this._length!=t._length)throw new Error(`Lengths differ (${this._length} != ${t._length})`);this.copy(t._data,this._data,this.lengthInInts),this._version++;}get length(){return this._length}get buffer(){return this._data}set buffer(t){this._data=t,this._version++;}get version(){return this._version}set version(t){this._version=t;}incrementVersion(t=!0){this._version++;}get lengthInInts(){return Math.floor((this._length+31)/32)}get versionedName(){return this._version==this._versionedNameVersion?this._versionedName:\"\"}set versionedName(t){this._versionedName=t,this._versionedNameVersion=this._version;}get self(){return this}setLength(t){if(t<0)throw new Error(\"should be >= 0\");if(t==this._length)return;const e=Math.floor((t+31)/32);if(e>this._data.length||e+this.SHRINK_THRESHOLD<this._data.length){const t=new Uint32Array(e);this.copy(this._data,t,e>this._data.length?this._data.length:e),this._data=t;}t>this._length&&(this._length%32>0&&(this._data[this.lengthInInts-1]&=(1<<(this._length%32&31))-1),this._data.fill(0,this.lengthInInts,e)),this._length=t,this._version++;}static fromAnd(t,e){if(t._length!=e._length)throw new Error(`Lengths differ (${t._length} != ${e._length})`);const n=new i(t._length);n._length=t._length,n._data=i._createBuffer(n._length),n._version=0;const r=t.lengthInInts;for(let i=0;i<r;i++)n._data[i]=t._data[i]&e._data[i];return n}static _createBuffer(t){return new Uint32Array(Math.floor((t+31)/32))}static fromValues(t){const e=new i(t.length);e._version=0;for(let n=0;n<e._length;n++)t[n]&&(e._data[Math.floor(n/32)]|=1<<(n%32&31));return e}static fromSeq(t,e){const n=new i(t);for(let i=0;i<t;++i)n.setBit(i,e(i));return n._version=0,n}static fromString(t){return i.fromSeq(t.length,(e=>\"1\"==t.charAt(e)))}static fromUint32Array(t,e){const n=new i(t);return n._data=e,n}static fromBytes(t){const e=t.length,n=new i(8*e);n._data=new Uint32Array(Math.floor((e+3)/4)),n._length=8*e;let r=0,s=0;for(;e-s>=4;)n._data[r++]=255&t[s]|(255&t[s+1])<<8|(255&t[s+2])<<16|(255&t[s+3])<<24,s+=4;return e-s==3&&(n._data[r]=(255&t[s+2])<<16),e-s==2&&(n._data[r]|=(255&t[s+1])<<8),e-s==1&&(n._data[r]|=255&t[s]),n._version=0,n}toString(){return `${this._length} bits, ${this.countBits(!0)} set`}equals(t){if(this==t)return !0;if(null==t)return !1;if(this._length!=t._length)return !1;if(0==this._length)return !0;for(let e=0;e<this._data.length-1;e++)if(this._data[e]!=t._data[e])return !1;for(let e=8*(this._data.length-1);e<this._length;e++)if(this.getBit(e)!=t.getBit(e))return !1;return !0}clone(){const t=new i(0,!1);return t._data=Uint32Array.from(this._data),t._length=this._length,t._version=this._version,t}init(t,e){this.setAll(!1,!1);for(let e=0;e<this._length;e++)t(e)&&(this._data[Math.floor(e/32)]|=1<<(e%32&31));return this.incrementVersion(e),this}invert(t=!0){for(let t=0;t<this._data.length;t++)this._data[t]^=-1;this.incrementVersion(t);}setAll(t,e=!1){const n=t?-1:0,i=this.lengthInInts;for(let t=0;t<i;t++)this._data[t]=n;this.incrementVersion(e);}setIndexes(t,e=!0,n=!0,i=!0){n&&this.setAll(!e,!1);for(const n of t)this.setFast(n,e);this.incrementVersion(i);}everyIndex(t,e=!0){for(const n of t)if(this.getBit(n)!=e)return !1;return !0}anyIndex(t,e=!0){for(const n of t)if(this.getBit(n)==e)return !0;return !1}setWhere(t,e=!0,n=!0,i=!0,r=!0){if(n&&r&&this.setAll(!e,!1),r)for(let n=0;n<this._length;n++)t(n)&&this.setFast(n,e);else for(let n=0;n<this._length;n++)this.setFast(n,t(n)?e:!e);this.incrementVersion(i);}getRange(t,e){this.assureInRange(t,0,this._length-1,\"from\"),this.assureInRange(e,0,this._length,\"to\");const n=[];for(let i=t;i<e;++i)n.push(this.getBit(i));return i.fromValues(n)}getRangeAsList(t,e){this.assureInRange(t,0,this._length-1,\"from\"),this.assureInRange(e,0,this._length,\"to\");const n=[];for(let i=t;i<e;++i)n.push(this.getBit(i));return n}setRange(t,e,n,i=!0){this.assureInRange(t,0,this._length-1,\"from\"),this.assureInRange(e,0,this._length-1,\"to\");const r=Math.min(t,e),s=Math.max(t,e);if(n)for(let t=r;t<=s;t++)this.setTrue(t);else for(let t=r;t<=s;t++)this.setFalse(t);return this.incrementVersion(i),this}setRandom(t,e,n=!0){if(t<0||t>this._length)throw new Error(\"n must be >= 0 && <= Count\");t>this._length/2&&this.setRandom(this._length-t,!e),this.setAll(!e);for(let n=0;n<t;){const t=Math.floor(Math.random()*this._length);this.getBit(t)!=e&&(this.setFast(t,e),n++);}this.incrementVersion(n);}and(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]&=t._data[e];return this.incrementVersion(e),this}andNot(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");const n=this.lengthInInts;for(let e=0;e<n;e++)this._data[e]&=~t._data[e];return this.incrementVersion(e),this}notAnd(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]=~this._data[e]&t._data[e];return this.incrementVersion(e),this}not(t=!0){for(let t=0,e=this.lengthInInts;t<e;t++)this._data[t]=~this._data[t];return this.incrementVersion(t),this}or(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]|=t._data[e];return this.incrementVersion(e),this}xor(t,e=!0){if(this._length!=t._length)throw new Error(\"Array lengths differ.\");for(let e=0,n=this.lengthInInts;e<n;e++)this._data[e]^=t._data[e];return this.incrementVersion(e),this}insertAt(t,e,n=!1){if(this.assureInRange(t,0,this._length,\"pos\"),0==e)return;const i=this._length;this.setLength(this._length+e);for(let n=i-1;n>=t;n--)this.setBit(n+e,this.getBit(n));for(let i=t;i<t+e;i++)this.setBit(i,n);}removeAt(t,e=1){if(e<0)throw new Error(\"n cannot be negative\");if(this.assureInRange(t,0,this._length-e,\"pos\"),this.contains(!0))for(let n=t;n<this._length-e;n++)this.setBit(n,this.getBit(n+e));this.setLength(this._length-e);}removeByMask(t,e=!0){if(this._length!=t.length)throw new Error(\"length != mask.length\");if(t==this)this.setLength(t.countBits(!e)),this.setAll(!e);else {let n=0;for(let i=-1;-1!=(i=t.findNext(i,!e));)this.setFast(n++,this.getBit(i));this._length=n,this._version++;}return this}getBit(t){return !!(this._data[Math.floor(t/32)]&1<<(31&t))}setBit(t,e,n=!0){this.setFast(t,e),this._version++;}setFast(t,e){e?this._data[Math.floor(t/32)]|=1<<(31&t):this._data[Math.floor(t/32)]&=~(1<<(31&t));}setTrue(t){this._data[Math.floor(t/32)]|=1<<(31&t);}setFalse(t){this._data[Math.floor(t/32)]&=~(1<<(31&t));}trueCount(){return this.countBits(!0)}falseCount(){return this.countBits(!1)}countBits(t){if(0==this._length)return 0;if(this._selectedCountVersion!=this._version){this._selectedCount=0;const t=this.lengthInInts;let e=0;for(;e<t-1;e++)for(let t=this._data[e];0!=t;t>>>=8)this._selectedCount+=i._onBitCount[255&t];let n=this._data[e];const r=31&this._length;for(0!=r&&(n&=~(4294967295<<r));0!=n;n>>>=8)this._selectedCount+=i._onBitCount[255&n];this._selectedCountVersion=this._version;}return t?this._selectedCount:this._length-this._selectedCount}countWhere(t){let e=0;if(this.trueCount()==this._length)for(let n=0;n<this._length;n++)e+=t(n)?1:0;else for(let n=-1;-1!=(n=this.findNext(n,!0));)e+=t(n)?1:0;return e}andWithCountBits(t,e){if(0==this._length)return 0;let n=0;const r=this.lengthInInts;let s=0;for(;s<r-1;s++)for(let e=this._data[s]&t._data[s];0!=e;e>>>=8)n+=i._onBitCount[255&e];let o=this._data[s]&t._data[s];const a=31&this._length;for(0!=a&&(o&=~(4294967295<<a));0!=o;o>>>=8)n+=i._onBitCount[255&o];return e?n:this._length-n}clear(){this.setLength(0);}contains(t){return this.findNext(-1,t)>=0}get allTrue(){return this.countBits(!0)==this._length}get allFalse(){return this.countBits(!1)==this._length}get anyTrue(){return this.countBits(!0)>0}get anyFalse(){return this.countBits(!1)>0}findNext(t,e=!0){if(this.assureInRange(t,-1,this._length,\"index\"),t>=this._length-1)return -1;let n=31&(t=t<0?0:t+1);const r=this.lengthInInts;for(let s=Math.floor(t/32);s<r;s++){let r=e?this._data[s]:~this._data[s];if(0!=n)r&=4294967295<<n&4294967295,n=0;else if(!e&&-4294967296==r)continue;for(let e=0;0!=r;e+=8,r>>>=8){const n=i._firstOnBit[255&r];if(n>=0)return (t=n+32*s+e)>=this._length?-1:t}}return -1}findPrev(t,e=!0){if(0==t)return -1;this.assureInRange(t,-1,this._length,\"index\");let n=1+(t=t<0?this._length-1:t-1)&31;for(let r=Math.floor(t/32);r>=0;r--){let t=e?this._data[r]:~this._data[r];0!=n&&(t&=~(4294967295<<n),n=0);for(let e=24;0!=t;e-=8,t<<=8){const n=i._lastOnBit[t>>>24];if(n>=0)return n+32*r+e}}return -1}}i._onBitCount=Int8Array.from([0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8]),i._firstOnBit=Int8Array.from([-1,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]),i._lastOnBit=Int8Array.from([-1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]);},342:(t,e,n)=>{n.d(e,{P1:()=>s,X9:()=>r});var i=n(6082);function r(t,e){return Math.round(i.Color.a(t)*e)<<24|i.Color.r(t)<<16|i.Color.g(t)<<8|i.Color.b(t)}function s(t){const e=i.Color.a(t);return `#${(16777215&t).toString(16).padStart(6,\"0\")}`+e.toString(16).padStart(2,\"0\")}},3629:(t,e,n)=>{function i(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n]*t[n];return Math.sqrt(e)}function r(t,e){if(t.length!=e.length)throw new Error(\"The dimensionality of the vectors must match\");let n=0;for(let i=0;i<t.length;i++)n+=t[i]*e[i];return n}function s(t,e){let n=0;const i=t.length;if(i!==e.length)throw new Error(\"The dimensionality of the vectors must match\");for(let r=0;r<i;++r)n+=Math.pow(t[r]-e[r],2);return Math.sqrt(n)}n.d(e,{KE:()=>r,ou:()=>s,wQ:()=>i});},6397:(t,e,n)=>{n.d(e,{A:()=>a});var i=n(1354),r=n.n(i),s=n(6314),o=n.n(s)()(r());o.push([t.id,\".dendrogram-close-bttn{\\n    position: absolute;\\n    top: 0px;\\n    color: #9497a0;\\n    right: 0px;\\n    font-size: 18px;\\n    z-index: 1000;\\n    background-color: white;\\n    padding-top: 3px;\\n}\\n\\n.dendrogram-overlay{\\n    position: absolute;\\n    background-color: white;\\n    overflow-y: hidden;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.dendrogram-loader{\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\",\"\",{version:3,sources:[\"webpack://./src/css/injected-dendrogram.css\"],names:[],mappings:\"AAAA;IACI,kBAAkB;IAClB,QAAQ;IACR,cAAc;IACd,UAAU;IACV,eAAe;IACf,aAAa;IACb,uBAAuB;IACvB,gBAAgB;AACpB;;AAEA;IACI,kBAAkB;IAClB,uBAAuB;IACvB,kBAAkB;IAClB,aAAa;IACb,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;AACvB\",sourcesContent:[\".dendrogram-close-bttn{\\n    position: absolute;\\n    top: 0px;\\n    color: #9497a0;\\n    right: 0px;\\n    font-size: 18px;\\n    z-index: 1000;\\n    background-color: white;\\n    padding-top: 3px;\\n}\\n\\n.dendrogram-overlay{\\n    position: absolute;\\n    background-color: white;\\n    overflow-y: hidden;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.dendrogram-loader{\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\"],sourceRoot:\"\"}]);const a=o;},6314:t=>{t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var n=\"\",i=void 0!==e[5];return e[4]&&(n+=\"@supports (\".concat(e[4],\") {\")),e[2]&&(n+=\"@media \".concat(e[2],\" {\")),i&&(n+=\"@layer\".concat(e[5].length>0?\" \".concat(e[5]):\"\",\" {\")),n+=t(e),i&&(n+=\"}\"),e[2]&&(n+=\"}\"),e[4]&&(n+=\"}\"),n})).join(\"\")},e.i=function(t,n,i,r,s){\"string\"==typeof t&&(t=[[null,t,void 0]]);var o={};if(i)for(var a=0;a<this.length;a++){var l=this[a][0];null!=l&&(o[l]=!0);}for(var h=0;h<t.length;h++){var c=[].concat(t[h]);i&&o[c[0]]||(void 0!==s&&(void 0===c[5]||(c[1]=\"@layer\".concat(c[5].length>0?\" \".concat(c[5]):\"\",\" {\").concat(c[1],\"}\")),c[5]=s),n&&(c[2]?(c[1]=\"@media \".concat(c[2],\" {\").concat(c[1],\"}\"),c[2]=n):c[2]=n),r&&(c[4]?(c[1]=\"@supports (\".concat(c[4],\") {\").concat(c[1],\"}\"),c[4]=r):c[4]=\"\".concat(r)),e.push(c));}},e};},1354:t=>{t.exports=function(t){var e=t[1],n=t[3];if(!n)return e;if(\"function\"==typeof btoa){var i=btoa(unescape(encodeURIComponent(JSON.stringify(n)))),r=\"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(i),s=\"/*# \".concat(r,\" */\");return [e].concat([s]).join(\"\\n\")}return [e].join(\"\\n\")};},2787:(t,e,n)=>{n.d(e,{I:()=>r});const i=new Uint32Array(65536),r=(t,e)=>{if(t.length<e.length){const n=e;e=t,t=n;}return 0===e.length?t.length:t.length<=32?((t,e)=>{const n=t.length,r=e.length,s=1<<n-1;let o=-1,a=0,l=n,h=n;for(;h--;)i[t.charCodeAt(h)]|=1<<h;for(h=0;h<r;h++){let t=i[e.charCodeAt(h)];const n=t|a;t|=(t&o)+o^o,a|=~(t|o),o&=t,a&s&&l++,o&s&&l--,a=a<<1|1,o=o<<1|~(n|a),a&=n;}for(h=n;h--;)i[t.charCodeAt(h)]=0;return l})(t,e):((t,e)=>{const n=e.length,r=t.length,s=[],o=[],a=Math.ceil(n/32),l=Math.ceil(r/32);for(let t=0;t<a;t++)o[t]=-1,s[t]=0;let h=0;for(;h<l-1;h++){let a=0,l=-1;const c=32*h,u=Math.min(32,r)+c;for(let e=c;e<u;e++)i[t.charCodeAt(e)]|=1<<e;for(let t=0;t<n;t++){const n=i[e.charCodeAt(t)],r=o[t/32|0]>>>t&1,h=s[t/32|0]>>>t&1,c=n|a,u=((n|h)&l)+l^l|n|h;let d=a|~(u|l),g=l&u;d>>>31^r&&(o[t/32|0]^=1<<t),g>>>31^h&&(s[t/32|0]^=1<<t),d=d<<1|r,g=g<<1|h,l=g|~(c|d),a=d&c;}for(let e=c;e<u;e++)i[t.charCodeAt(e)]=0;}let c=0,u=-1;const d=32*h,g=Math.min(32,r-d)+d;for(let e=d;e<g;e++)i[t.charCodeAt(e)]|=1<<e;let f=r;for(let t=0;t<n;t++){const n=i[e.charCodeAt(t)],a=o[t/32|0]>>>t&1,l=s[t/32|0]>>>t&1,h=n|c,d=((n|l)&u)+u^u|n|l;let g=c|~(d|u),m=u&d;f+=g>>>r-1&1,f-=m>>>r-1&1,g>>>31^a&&(o[t/32|0]^=1<<t),m>>>31^l&&(s[t/32|0]^=1<<t),g=g<<1|a,m=m<<1|l,u=m|~(h|g),c=g&h;}for(let e=d;e<g;e++)i[t.charCodeAt(e)]=0;return f})(t,e)};},944:(t,e)=>{e.Vb=void 0,e.Vb=function(t,e,n){var i=function(t,e,n){if(0===t.length||0===e.length)return 0;if(n&&!n.caseSensitive&&(t=t.toUpperCase(),e=e.toUpperCase()),t===e)return 1;for(var i=0,r=t.length,s=e.length,o=Math.floor(Math.max(r,s)/2)-1,a=new Array(r),l=new Array(s),h=0;h<r;h++)for(var c=Math.max(0,h-o);c<=Math.min(s,h+o+1);c++)if(!a[h]&&!l[c]&&t[h]===e[c]){++i,a[h]=l[c]=!0;break}if(0===i)return 0;var u=0,d=0;for(h=0;h<r;h++)if(a[h]){for(;!l[d];)d++;t.charAt(h)!==e.charAt(d++)&&u++;}return (i/r+i/s+(i-(u/=2))/i)/3}(t,e,n),r=0;if(i>.7){for(var s=Math.min(t.length,e.length),o=0;t[o]===e[o]&&o<4&&o<s;)++r,o++;i+=.1*r*(1-i);}return i};},9778:(t,e,n)=>{var i=n(5072),r=n.n(i),s=n(7825),o=n.n(s),a=n(7659),l=n.n(a),h=n(5056),c=n.n(h),u=n(540),d=n.n(u),g=n(1113),f=n.n(g),m=n(6397),p={};p.styleTagTransform=f(),p.setAttributes=c(),p.insert=l().bind(null,\"head\"),p.domAPI=o(),p.insertStyleElement=d(),r()(m.A,p),m.A&&m.A.locals&&m.A.locals;},5072:t=>{var e=[];function n(t){for(var n=-1,i=0;i<e.length;i++)if(e[i].identifier===t){n=i;break}return n}function i(t,i){for(var s={},o=[],a=0;a<t.length;a++){var l=t[a],h=i.base?l[0]+i.base:l[0],c=s[h]||0,u=\"\".concat(h,\" \").concat(c);s[h]=c+1;var d=n(u),g={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==d)e[d].references++,e[d].updater(g);else {var f=r(g,i);i.byIndex=a,e.splice(a,0,{identifier:u,updater:f,references:1});}o.push(u);}return o}function r(t,e){var n=e.domAPI(e);return n.update(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap&&e.supports===t.supports&&e.layer===t.layer)return;n.update(t=e);}else n.remove();}}t.exports=function(t,r){var s=i(t=t||[],r=r||{});return function(t){t=t||[];for(var o=0;o<s.length;o++){var a=n(s[o]);e[a].references--;}for(var l=i(t,r),h=0;h<s.length;h++){var c=n(s[h]);0===e[c].references&&(e[c].updater(),e.splice(c,1));}s=l;}};},7659:t=>{var e={};t.exports=function(t,n){var i=function(t){if(void 0===e[t]){var n=document.querySelector(t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head;}catch(t){n=null;}e[t]=n;}return e[t]}(t);if(!i)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");i.appendChild(n);};},540:t=>{t.exports=function(t){var e=document.createElement(\"style\");return t.setAttributes(e,t.attributes),t.insert(e,t.options),e};},5056:(t,e,n)=>{t.exports=function(t){var e=n.nc;e&&t.setAttribute(\"nonce\",e);};},7825:t=>{t.exports=function(t){if(\"undefined\"==typeof document)return {update:function(){},remove:function(){}};var e=t.insertStyleElement(t);return {update:function(n){!function(t,e,n){var i=\"\";n.supports&&(i+=\"@supports (\".concat(n.supports,\") {\")),n.media&&(i+=\"@media \".concat(n.media,\" {\"));var r=void 0!==n.layer;r&&(i+=\"@layer\".concat(n.layer.length>0?\" \".concat(n.layer):\"\",\" {\")),i+=n.css,r&&(i+=\"}\"),n.media&&(i+=\"}\"),n.supports&&(i+=\"}\");var s=n.sourceMap;s&&\"undefined\"!=typeof btoa&&(i+=\"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))),\" */\")),e.styleTagTransform(i,t,e.options);}(e,t,n);},remove:function(){!function(t){if(null===t.parentNode)return !1;t.parentNode.removeChild(t);}(e);}}};},1113:t=>{t.exports=function(t,e){if(e.styleSheet)e.styleSheet.cssText=t;else {for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t));}};},4664:(t,e,n)=>{n.r(e),n.d(e,{_heatMapDemo:()=>$,_package:()=>y,dendrogram:()=>S,dendrogramApp:()=>N,dendrogramLargeApp:()=>L,generateTreeDialog:()=>O,getDendrogramService:()=>E,getTreeHelper:()=>T,hierarchicalClustering:()=>D,hierarchicalClustering2:()=>B,hierarchicalClusteringApp:()=>x,hierarchicalClusteringMolecules:()=>V,hierarchicalClusteringSequences:()=>F,hierarchicalClusteringSequencesApp:()=>H,importNewick:()=>k,info:()=>A,previewNewick:()=>P,treeForGridApp:()=>M,treeForGridCutApp:()=>I,treeForGridFilterApp:()=>R});var i=n(4328),r=n(7389),s=n(6082),o=n(9689),a=n(5819);class l{get treeDf(){return this._treeDf}constructor(){this.viewed=!1,this._funcName=\"\",this.viewSubs=[];}async init(t,e=\"dendrogramApp\"){this._funcName=e,await this.loadData(t);}async loadData(t){if(!t){const e=new a.h,n=await y.files.readAsText(\"data/tree95.nwk\");t=e.newickToDf(n,\"tree95\");}await this.setData(t);}async setData(t){this.viewed&&(await this.destroyView(),this.viewed=!1),this._treeDf=t,this.viewed||(await this.buildView(),this.viewed=!0);}async destroyView(){this.viewSubs.forEach((t=>t.unsubscribe())),this.viewSubs=[],this.treeViewer&&(this.treeViewer.close(),this.treeViewer.removeFromView(),this.treeViewer=null),this.treeHost&&(this.treeHost.remove(),this.treeHost=null),this.treeDn&&(this.treeDn.detachFromParent(),this.treeDn=null);}async buildView(){this.tv||(this.tv=i.shell.addTableView(this.treeDf,s.DOCK_TYPE.FILL),this.tv.path=this.tv.basePath=`/func/${y.name}.${this._funcName}`),this.treeViewer||(this.treeViewer=await this.treeDf.plot.fromType(\"Dendrogram\",{nodeColumnName:\"node\"}),this.treeDn=this.tv.dockManager.dock(this.treeViewer,s.DOCK_TYPE.RIGHT));}}var h=n(5836),c=n(4622);class u{get df(){return this._df}constructor(){this.viewed=!1;}async init(t){await this.loadData(t);}async loadData(t){if(!t){const e=await y.files.readAsText(\"data/demog-short.csv\");t=s.DataFrame.fromCsv(e);}await this.setData(t);}async setData(t){this.viewed&&(await this.destroyView(),this.viewed=!1),this._df=t,this.viewed||(await this.buildView(),this.viewed=!0);}async destroyView(){this.tv&&(this.tv.close(),delete this.tv);}async buildView(){this.tv||(this.tv=i.shell.addTableView(this.df,s.DOCK_TYPE.FILL)),this.tv.path=this.tv.basePath=`/func/${y.name}.hierarchicalClusteringApp`,await(0, h.o1)(this.df,[\"HEIGHT\"],c.uf.Euclidean,\"ward\");}}var d=n(3797),g=n(6806);class f{constructor(){this.viewed=!1,this.tableView=null,this.gridN=null;}get dataDf(){return this._dataDf}get leafCol(){return this._leafCol}get newickRoot(){return this._newickRoot}async init(){await this.loadData();}async loadData(){const t=await y.files.readAsText(\"data/tree95df.csv\"),e=await y.files.readAsText(\"data/tree95.nwk\"),n=s.DataFrame.fromCsv(t);n.setTag(\".newick\",e),n.setTag(\".newickLeafColumn\",\"id\"),n.columns.addNewVirtual(\"[index]\",(t=>t),s.TYPE.INT),await this.setData(n,e);}async setData(t,e){this.viewed&&(await this.destroyView(),this.viewed=!1),this._dataDf=t;const n=t.getTag(\".newickLeafColumn\");if(!n)throw new Error(\"Specify leaf column name in DataFrame tag '.newickLeafColumn'.\");this._leafCol=t.getCol(n),this._newickStr=e,this._newickRoot=(0, g.Z$)(e),this.viewed||(await this.buildView(),this.viewed=!0);}async destroyView(){this.gridN&&(this.gridN.close(),this.gridN=null),this.tableView&&(this.tableView.close(),this.tableView=null);}async buildView(){if(!this.tableView){const t=this.dataDf;t.columns.addNewInt(\"Cluster\").init((t=>null));const e=\"Cluster\",n=s.DataFrame.create(0);n.columns.addNewInt(e),n.columns.addNewString(this.leafCol.name),n.columns.addNewInt(`${this.leafCol.name}_Count`),this.tableView=i.shell.addTableView(t),this.tableView.path=this.tableView.basePath=`/func/${y.name}.treeForGridApp`,this.gridN=(0, d.J)(this.tableView.grid,this.newickRoot,this.leafCol.name,250);}}}class m{constructor(){this.viewed=!1,this.tableView=null,this.gridN=null;}get dataDf(){return this._dataDf}get leafCol(){return this._leafCol}get newickRoot(){return this._newickRoot}async init(){this.th=new a.h,await this.loadData();}async loadData(){const t=this.th.generateTree(5e3),e=this.th.toNewick(t),n=\"Leaf\",i=this.th.getLeafList(t),r=s.Column.fromList(s.COLUMN_TYPE.STRING,n,i.map((t=>t.name))),o=s.Column.fromList(s.COLUMN_TYPE.FLOAT,\"Activity\",i.map((t=>Math.random()))),a=s.DataFrame.fromColumns([r,o]);a.setTag(\".newick\",e),a.setTag(\".newickLeafColumn\",n),await this.setData(a,e);}async setData(t,e){this.viewed&&(await this.destroyView(),this.viewed=!1),this._dataDf=t;const n=t.getTag(\".newickLeafColumn\");if(!n)throw new Error(\"Specify leaf column name in DataFrame tag '.newickLeafColumn'.\");this._leafCol=t.getCol(n),this._newickStr=e,this._newickRoot=(0, g.Z$)(e),this.viewed||(await this.buildView(),this.viewed=!0);}async destroyView(){this.gridN&&(this.gridN.close(),this.gridN=null),this.tableView&&(this.tableView.close(),this.tableView=null);}async buildView(){if(!this.tableView){const t=this.dataDf;t.columns.addNewInt(\"Cluster\").init((t=>null)),this.tableView=i.shell.addTableView(t),this.tableView.path=this.tableView.basePath=`/func/${y.name}.treeForGridFilterApp`,this.gridN=(0, d.J)(this.tableView.grid,this.newickRoot,this.leafCol.name,300);}}}var p=n(9666);class C{constructor(){this.viewed=!1,this.tableView=null,this.gridN=null;}get dataDf(){return this._dataDf}get leafCol(){return this._leafCol}get newickRoot(){return this._newickRoot}async init(){this.th=new a.h,await this.loadData();}async loadData(){const t=await y.files.readAsText(\"data/tree95df.csv\"),e=await y.files.readAsText(\"data/tree95.nwk\"),n=s.DataFrame.fromCsv(t);n.setTag(\".newick\",e),n.setTag(\".newickLeafColumn\",\"id\"),await this.setData(n,e);}async setData(t,e){this.viewed&&(await this.destroyView(),this.viewed=!1),this._dataDf=t;const n=t.getTag(\".newickLeafColumn\");if(!n)throw new Error(\"Specify leaf column name in DataFrame tag '.newickLeafColumn'.\");this._leafCol=t.getCol(n),this._newickStr=e,this._newickRoot=(0, g.Z$)(e),this.viewed||(await this.buildView(),this.viewed=!0);}async destroyView(){this.gridN&&(this.gridN.close(),this.gridN=null),this.tableView&&(this.tableView.close(),this.tableView=null);}async buildView(){if(!this.tableView){const t=this.dataDf;t.columns.addNewInt(\"Cluster\").init((t=>null)),(0, p.vV)(this.newickRoot);const e=\"Cluster\",n=s.DataFrame.create(0);n.columns.addNewInt(e),n.columns.addNewString(this.leafCol.name),n.columns.addNewInt(`${this.leafCol.name}_Count`),this.tableView=i.shell.addTableView(n),this.tableView.path=this.tableView.basePath=`/func/${y.name}.treeForGridCutApp`,this.gridN=(0, d.J)(this.tableView.grid,this.newickRoot,this.leafCol.name,300,{dataDf:t,clusterDf:n,clusterColName:e});}}}class w{injectTreeForGrid(t,e,n,i,r){const s=i??100;return (0, d.J)(t,e,n,s,r)}}class b{get df(){return this._df}constructor(){this.viewed=!1;}async init(t){await this.loadData(t);}async loadData(t){if(!t){const e=await y.files.readAsText(\"data/Prots.csv\");t=s.DataFrame.fromCsv(e);}await this.setData(t);}async setData(t){this.viewed&&(await this.destroyView(),this.viewed=!1),this._df=t,await this.buildView(),this.viewed=!0;}async destroyView(){this.tv&&(this.tv.close(),delete this.tv);}async buildView(){this.tv||(this.tv=i.shell.addTableView(this.df,s.DOCK_TYPE.FILL)),this.tv.path=this.tv.basePath=`/func/${y.name}.hierarchicalClusteringSequencesApp`,this.tv.dataFrame.onSemanticTypeDetected.subscribe((async()=>{await(0, h.o1)(this.df,[\"AlignedSequence\"],c.uf.Euclidean,\"ward\");}));}}class _{constructor(t,e,n=\"\"){this.target=t,this.debugEnabled=e,this.prefix=n;}error(t,e,n){return this.target.error(this.prefix+t,e,n)}warning(t,e){return this.target.warning(this.prefix+t,e)}info(t,e){return this.target.info(this.prefix+t,e)}debug(t,e){if(this.debugEnabled)return this.target.debug(this.prefix+t,e)}}class v extends s.Package{constructor(t={debug:!1}){super(),super._logger=new _(super.logger,t.debug,\"Dendrogram: \");}}const y=new v;function A(){i.shell.info(y.webRoot);}function S(){return new o.Uj}function T(){return new a.h}function E(){if(!window.$dendrogramService){const t=new w;window.$dendrogramService=t;}return window.$dendrogramService}function O(){const t=r.input.int(\"Tree size (node count)\",{value:1e4}),e=r.input.string(\"File name\",{value:\"tree-gen-10000\"});return r.dialog(\"Generate tree\").add(r.divV([t,e])).onOK((async()=>{const n=new a.h,i=n.generateTree(t.value),r=n.toNewick(i),o=n.getLeafList(i),l=s.Column.fromList(s.COLUMN_TYPE.STRING,\"Leaf\",o.map((t=>t.name))),h=s.Column.fromList(s.COLUMN_TYPE.FLOAT,\"Activity\",o.map((t=>Math.random()))),c=s.DataFrame.fromColumns([l,h]);await y.files.writeAsText(e.value+\".nwk\",r),await y.files.writeAsText(e.value+\".csv\",c.toCsv());})).show()}async function N(){const t=s.TaskBarProgressIndicator.create(\"open Dendrogram app\");try{const t=new l;await t.init();}catch(t){const e=`Dendrogram: dendrogramApp() error: ${t instanceof Error?t.message:t.toString()}`;i.shell.error(e),console.error(e);}finally{t.close();}}async function L(){const t=\"data/tree-gen-100000.nwk\",e=s.TaskBarProgressIndicator.create(\"open Dendrogram Large app\");try{const e=new a.h;let n;await y.files.exists(t)?n=await y.files.readAsText(\"data/tree-gen-100000.nwk\"):(i.shell.warning(`File '${t}' does not exist, generating data...`),n=e.toNewick(e.generateTree(1e5)));const r=e.newickToDf(n,\"large\"),s=new l;await s.init(r,\"dendrogramLargeApp\");}catch(t){const e=`Dendrogram: dendrogramLargeApp() error: ${t instanceof Error?t.message:t.toString()}`;i.shell.error(e),console.error(e);}finally{e.close();}}async function M(){const t=s.TaskBarProgressIndicator.create(\"open treeForGridFilter app\");try{const t=new f;await t.init();}finally{t.close();}}async function R(){const t=s.TaskBarProgressIndicator.create(\"open treeForGrid large app\");try{const t=new m;await t.init();}finally{t.close();}}async function I(){const t=s.TaskBarProgressIndicator.create(\"open treeForGridCut large app\");try{const t=new C;await t.init();}finally{t.close();}}async function x(){const t=s.TaskBarProgressIndicator.create(\"opem Hierarchical Clustering app\");try{const t=new u;await t.init();}catch(t){const e=`Dendrogram: hierarchicalClusteringApp() error: ${t instanceof Error?t.message:t.toString()}`;i.shell.error(e),console.error(e);}finally{t.close();}}async function H(){const t=s.TaskBarProgressIndicator.create(\"opem Hierarchical Clustering app for sequences\");try{const t=new b;await t.init();}catch(t){const e=`Dendrogram: hierarchicalClusteringApp() error: ${t instanceof Error?t.message:t.toString()}`;i.shell.error(e),console.error(e);}finally{t.close();}}async function D(t,e,n=c.uf.Euclidean,i){await(0, h.o1)(t,e.names(),n,i);}async function k(t){const e=(new a.h).newickToDf(t,\"\"),n=new l;return await n.init(e),[]}async function P(t){const e=await t.readAsString(),n=(await T()).newickToDf(e,t.fileName.slice(0,-4)),o=s.View.create(),a=r.divH([r.button(\"Load dataframe\",(()=>{const t=i.shell.addTableView(n),e=s.Viewer.fromType(\"PhyloTree\",n);return t.addViewer(e),t.dockManager.dock(e,s.DOCK_TYPE.RIGHT),t}),\"View in a dataframe\"),s.Viewer.fromType(\"Dendrogram\",n).root],\"d4-ngl-viewer\");return o.append(a),o}async function F(){(0, h._R)();}async function V(){(0, h._R)();}async function B(){(0, h._R)();}async function $(){await async function(){try{const t=await y.files.readAsText(\"data/demog-short.csv\"),e=s.DataFrame.fromCsv(t),n=i.shell.addTableView(e,s.DOCK_TYPE.FILL);await(0,h.o1)(e,[\"AGE\"],c.uf.Euclidean,\"ward\",300,{tableView:n});const r=()=>{const t=n.dataFrame.filter.trueCount,e=n.grid.root.clientHeight-n.grid.colHeaderHeight;n.grid.props.rowHeight=e/(t+1);},o=n.dockManager.rootNode,a=n.dockManager.dock(n.addViewer(s.VIEWER.SCATTER_PLOT),s.DOCK_TYPE.DOWN,o,s.VIEWER.SCATTER_PLOT,.25);n.dockManager.dock(n.addViewer(s.VIEWER.HISTOGRAM),s.DOCK_TYPE.RIGHT,a,s.VIEWER.HISTOGRAM,.5),n.dockManager.dock(n.filters(),s.DOCK_TYPE.LEFT,o,s.VIEWER.FILTERS,.2),i.shell.windows.showHelp=!0,i.shell.windows.help.showHelp(\"/help/visualize/viewers/heat-map.md\"),n.grid.onBeforeDrawContent.subscribe((()=>{r();})),r(),n.grid.props.isGrid=!1,n.grid.props.isHeatmap=!0,n.grid.props.showRowHeader=!1,setTimeout((()=>{r(),n.grid.invalidate();}),100);}catch(t){console.error(t);}}();}},5836:(t,e,n)=>{n.d(e,{_R:()=>u,o1:()=>d});var i=n(4328),r=n(7389),s=n(6082),o=n(3797),a=n(4622),l=n(5819),h=n(1537),c=n(9226);async function u(){let t=i.shell.tv.table,e=[];const n=t=>t.columns.toList().filter((t=>t.type===s.TYPE.FLOAT||t.type===s.TYPE.INT||t.semType===s.SEMTYPE.MACROMOLECULE||t.semType===s.SEMTYPE.MOLECULE)).map((t=>t.name)),o=t=>{e=t.map((t=>t.name));},l=r.input.table(\"Table\",{value:t,items:i.shell.tables,onValueChanged:i=>(i=>{const s=r.input.columns(\"Features\",{table:i,onValueChanged:t=>o(t),available:n(i)});r.empty(c),c.appendChild(s.root),t=i,e=[];})(i)}),h=r.input.columns(\"Features\",{table:t,onValueChanged:t=>o(t),available:n(t)}),c=r.div([h]),u=r.input.choice(\"Distance\",{value:a.uf.Euclidean,items:Object.values(a.uf)}),g=r.input.choice(\"Linkage\",{value:a.h_.Ward,items:Object.values(a.h_)}),f=r.divV([l.root,c,u.root,g.root]);r.dialog(\"Hierarchical Clustering\").add(f).show().onOK((async()=>{const n=s.TaskBarProgressIndicator.create(\"Creating dendrogram ...\");try{await d(t,e,u.value,g.value);}finally{n.close();}}));}async function d(t,e,n=a.uf.Euclidean,r,u=300,d){const g=Object.values(a.h_).findIndex((t=>t===r)),f=new Set(e),[m,p]=function(t,e){const n=t.columns.toList().filter((t=>e.has(t.name))),i=s.BitSet.create(t.rowCount,(t=>n.every((e=>!e.isNone(t)))));return [t.clone(i),i.getSelectedIndexes()]}(t,f),C=new l.h;let w=d?d.tableView??i.shell.getTableView(t.name):i.shell.getTableView(t.name);m.rowCount!=t.rowCount&&(i.shell.warning(\"Hierarchical clustering analysis on data filtered out for nulls.\"),w=i.shell.addTableView(m));const b=(0, c.P)(w.grid,u),_=s.DataFrame.fromColumns(m.columns.toList().filter((t=>f.has(t.name))).map((t=>{let e;if(t.type===s.COLUMN_TYPE.DATE_TIME){const n=t.getRawData();e=s.Column.float(t.name,t.length).init((e=>t.isNone(e)?null:n[e]));}else e=t;return e})));try{const t=await C.calcDistanceMatrix(_,_.columns.toList().map((t=>t.name)),n),e=(0,h.C4)(t.data,_.rowCount,g),r=await e,s={},l=m.rowCount;for(let t=0;t<l;t++)s[t]=p[t];const c=C.parseClusterMatrix(r);c.branch_length=0,function t(e,n){if(!(0,a.xe)(e))for(const i of e.children)t(i,n);}(c,s),b.close(),(0,o.J)(w.grid,c,void 0,u);const d=i.events.onViewRemoved.subscribe((t=>{if(t===w)try{d.unsubscribe(),b.close();}catch{}}));w.grid.invalidate();}catch(t){console.error(t),w.grid.invalidate(),b.close();}}},9226:(t,e,n)=>{n.d(e,{S:()=>h,P:()=>c});var i=n(7389),r=n(6082),s=n(4328),o=n(1858);class a{constructor(t,e,n,i){var l,h;this.logger=i,this.objId=++a.objCounter,this.m_onClosed=new o.Subject;const c=`${this.toLog()}.ctor()`;null===(l=this.logger)||void 0===l||l.debug(`${c}, start`),this.m_root=t,this.m_grid=e;const u=n,d=e.canvas.height,g=e.canvas.getAttribute(\"tabIndex\");if(null!==g&&t.setAttribute(\"tabIndex\",g),e.canvas.style.left=(e.canvas.offsetLeft+u).toString()+\"px\",e.overlay.style.left=(e.overlay.offsetLeft+u).toString()+\"px\",e.canvas.style.width=(e.canvas.offsetWidth-u).toString()+\"px\",e.overlay.style.width=(e.overlay.offsetWidth-u).toString()+\"px\",t.style.position=\"absolute\",t.style.left=\"0px\",t.style.top=e.canvas.offsetTop+\"px\",t.style.width=u.toString()+\"px\",t.style.height=Math.round(d/window.devicePixelRatio)+\"px\",null===e.canvas.parentNode)throw new Error(\"Parent node for canvas cannot be null.\");e.canvas.parentNode.insertBefore(t,e.canvas);const f=this,m=t;this.m_observerResizeGrid=new ResizeObserver((function(t){requestAnimationFrame((()=>{const t=e.view;r.toDart(s.shell.v)===r.toDart(t)&&(e.canvas.height!==m.offsetHeight&&(m.style.top=e.canvas.offsetTop+\"px\",m.style.width=u+\"px\",m.style.height=Math.round(e.canvas.height/window.devicePixelRatio)+\"px\"),f.onSizeChanged());}));})),null===(h=this.m_observerResizeGrid)||void 0===h||h.observe(e.canvas);}toLog(){return `GridNeighbor<${this.objId}>`}get root(){return this.m_root}get onClosed(){return this.m_onClosed}onSizeChanged(){}close(){var t,e,n;const i=`${this.toLog()}.close()`;if(null===(t=this.logger)||void 0===t||t.debug(`${i}, start`),null===this.m_grid||null===this.m_root)throw new Error(\"Grid or Root cannot be null.\");null===(e=this.m_observerResizeGrid)||void 0===e||e.disconnect(),this.m_observerResizeGrid=null,this.m_grid.canvas.style.left=(this.m_grid.canvas.offsetLeft-this.m_root.offsetWidth).toString()+\"px\",this.m_grid.overlay.style.left=(this.m_grid.overlay.offsetLeft-this.m_root.offsetWidth).toString()+\"px\",this.m_grid.canvas.style.width=(this.m_grid.canvas.offsetWidth+this.m_root.offsetWidth).toString()+\"px\",this.m_grid.overlay.style.width=(this.m_grid.overlay.offsetWidth+this.m_root.offsetWidth).toString()+\"px\",null!==this.m_root.parentNode&&this.m_root.parentNode.removeChild(this.m_root),this.m_onClosed.next(),this.m_root=null,this.m_grid=null,null===(n=this.logger)||void 0===n||n.debug(`${i}, end`);}}a.objCounter=-1,n(9778);var l=n(4664);function h(t,e=100){const n=i.div(),r=i.icons.close((()=>{s.close(),t.invalidate();}),\"Remove Dendrogram\");r.classList.add(\"dendrogram-close-bttn\"),n.appendChild(r);const s=new a(n,t,e,l._package.logger);return s.root&&(s.root.style.zIndex=\"1\"),s}function c(t,e=100){const n=i.div();n.classList.add(\"dendrogram-loader\");const r=i.waitBox((async()=>new Promise((()=>{}))));n.appendChild(r),i.icons.close((()=>{s.close(),t.invalidate();}),\"Remove Dendrogram\").classList.add(\"dendrogram-close-bttn\"),r.style.width=\"40px\";const s=new a(n,t,e,l._package.logger);return t.invalidate(),s}},5819:(t,e,n)=>{n.d(e,{h:()=>T});var i=n(4328),r=n(6082),s=n(1991),o=n.n(s),a=n(4622),l=n(6806),h=n(1058),c=n(7120),u=n(7493),d=n(4572),g=n(8498),f=n(2787),m=n(944),p=n(6295),C=n(3629);const w={[g.Pn.Euclidean]:C.ou},b={[g.xL.Levenshtein]:f.I,[g.xL.JaroWinkler]:m.Vb,[g.xL.Manhattan]:function(t,e){if(t.length!==e.length)return 1;{let n=0;for(let i=1;i<t.length;i++)n+=t[i]==e[i]?0:1;return n/t.length}},[g.xL.Onehot]:function(t,e){return t===e?0:1}},_={[g.aT.Tanimoto]:p.tO,[g.aT.Dice]:p.zn,[g.aT.Asymmetric]:p.gt,[g.aT.BraunBlanquet]:p.ij,[g.aT.Cosine]:p.lO,[g.aT.Kulczynski]:p.rR,[g.aT.McConnaughey]:p.lP,[g.aT.RogotGoldberg]:p.TK,[g.aT.Russel]:p.yK,[g.aT.Sokal]:p.Ii,[g.aT.Hamming]:p.be,[g.aT.Euclidean]:p.a4},v={[g.m6.TanimotoIntArray]:p.v_},y={[g.RR.Difference]:p.T6},A={[g.Wn.CommonItems]:p.Hr},S={[g.EG.Vector]:{[g.Pn.Euclidean]:w[g.Pn.Euclidean]},[g.EG.String]:{[g.xL.Levenshtein]:b[g.xL.Levenshtein],[g.xL.JaroWinkler]:b[g.xL.JaroWinkler],[g.xL.Manhattan]:b[g.xL.Manhattan],[g.xL.Onehot]:b[g.xL.Onehot]},[g.EG.BitArray]:{[g.aT.Tanimoto]:_[g.aT.Tanimoto],[g.aT.Dice]:_[g.aT.Dice],[g.aT.Asymmetric]:_[g.aT.Asymmetric],[g.aT.BraunBlanquet]:_[g.aT.BraunBlanquet],[g.aT.Cosine]:_[g.aT.Cosine],[g.aT.Kulczynski]:_[g.aT.Kulczynski],[g.aT.McConnaughey]:_[g.aT.McConnaughey],[g.aT.RogotGoldberg]:_[g.aT.RogotGoldberg],[g.aT.Russel]:_[g.aT.Russel],[g.aT.Sokal]:_[g.aT.Sokal]},[g.EG.MacroMolecule]:{[d.Z.HAMMING]:d.V[d.Z.HAMMING],[d.Z.LEVENSHTEIN]:d.V[d.Z.LEVENSHTEIN],[d.Z.NEEDLEMANN_WUNSCH]:d.V[d.Z.NEEDLEMANN_WUNSCH],[d.Z.MONOMER_CHEMICAL_DISTANCE]:d.V[d.Z.MONOMER_CHEMICAL_DISTANCE]},[g.EG.Number]:{[g.RR.Difference]:y[g.RR.Difference]},[g.EG.IntArray]:{[g.m6.TanimotoIntArray]:v[g.m6.TanimotoIntArray]},[g.EG.NumberArray]:{[g.Wn.CommonItems]:A[g.Wn.CommonItems]}};Object.keys(S).reduce(((t,e)=>{for(const n of Object.keys(S[e]))t[n]=e;return t}),{});class T{newickToDf(t,e,n){const i=n??\"\";let s=0;const o=(0, l.Z$)(t);o.name==l.TX&&(o.name=`${i}${l.TX}`);const a=[],h=[],c=[],u=[],d=[];!function t(e,n){if(null===e||\"object\"!=typeof e)return;const r=null==n;let o=e.name;if(o?r&&e.name==l.TX&&(o=`${i}${l.TX}`):(o=e.name=`${i}node-${s}`,++s),e.children){const n=e.children.length;for(let i=0;i<n;i++)t(e.children[i],e);}a.push(o),u.push(e.branch_length?e.branch_length:null),h.push(n?n.name:null),c.push(!e.children||0==e.children.length);}(o,null);const g=r.Column.fromList(r.COLUMN_TYPE.STRING,\"node\",a),f=r.Column.fromList(r.COLUMN_TYPE.STRING,\"parent\",h),m=r.Column.fromList(r.COLUMN_TYPE.BOOL,\"leaf\",c);g.semType=\"id\",f.semType=\"id\";const p=[g,f,m];u.some((t=>null!==t))&&p.push(r.Column.fromList(\"double\",\"distance\",u)),d.some((t=>!!t))&&p.push(r.Column.fromList(\"string\",\"annotation\",d));const C=r.DataFrame.fromColumns(p);return e&&(C.name=`df-${e}`),C.setTag(\".newick\",t),C.setTag(\".newickJson\",JSON.stringify(o)),C}toNewick(t){return t?`${function t(e){if(!e.children||0==e.children.length)return [].concat(e.name,e.hasOwnProperty(\"branch_length\")?`:${e.branch_length}`:[]).join(\"\");{const n=e.children.map((e=>t(e))).join(\",\");return [].concat(`(${n})`,e.name,e.hasOwnProperty(\"branch_length\")?`:${e.branch_length}`:[]).join(\"\")}}(t)};`:h.Et}getLeafList(t,e){if(!t)return [];if(e||(e=[]),(0, a.xe)(t))return e.push(t),[t];for(const n of t.children??[])this.getLeafList(n,e);return e}getNodeList(t,e){if(!t)return [];if(e||(e=[]),(0, a.xe)(t))return e.push(t),[t];for(const n of t.children)this.getNodeList(n,e);return e.push(t),e}includes(t,e){if(t==e)return !0;let n=!1;for(const i of t.children??[])if(this.includes(i,e)){n=!0;break}return n}filterTreeByLeaves(t,e){if(!t)return null;const n=Object.assign({},t);if((0, a.xe)(n))return n.name in e?n:null;n.children=[];for(const i of t.children){const t=this.filterTreeByLeaves(i,e);t&&n.children.push(t);}return n.children.length>0?n:null}getNodesByLeaves(t,e){if(!t)return [];if((0, a.xe)(t))return t.name in e?[t]:[];{const n=t.children??[],i=[];for(const t of n){const n=this.getNodesByLeaves(t,e);i.push(...n);}return i.length==n.length&&n.every(((t,e)=>t==i[e]))?[t]:i}}treeCutAsLeaves(t,e,n=0){let i;const r=t.branch_length??0;return i=n+r<e?[].concat(...(t.children??[]).map((t=>this.treeCutAsLeaves(t,e,n+r)))):[t],i}treeCutAsTree(t,e,n,i){const r=t.branch_length??0,s=i??0,o=n??!1;if(s+r<e){if((0, a.xe)(t))return o?t:null;{const n=Object.assign({},t);return n.children=t.children.map((t=>this.treeCutAsTree(t,e,o,s+r))).filter((t=>null!=t)),n}}{const n=Object.assign({},t);return n.branch_length=e-s,n.children=[],n.cuttedChildren=[{name:`${t.name}.cutted`,branch_length:r+s-e,children:t.children?[...t.children]:[]}],n.cuttedLeafNameList=this.getLeafList(t).map((t=>t.name)),n}}setGridOrder(t,e,n,i=!1){console.debug(\"Dendrogram.setGridOrder() start\");const s=e.dataFrame,a=[],l=[],h=this.getLeafList(t),c={};for(const t of h){if(t.name in c)throw new Error(\"Non unique key tree leaf name\");c[t.name]=t;}const u=n?s.getCol(n):r.Column.fromList(r.COLUMN_TYPE.INT,\"<index>\",o().count(0).take(s.rowCount).toArray());if(i)for(let t=u.length-1;t>=0;t--){const e=u.get(t);e in c||(a.push(e),s.rows.removeAt(t,1,!1));}const d={};for(let t=0;t<u.length;t++){const e=u.get(t),n=s.filter.get(t);if(e in c&&n){if(e in d)throw new Error(\"Non unique key data node name\");d[e]=t;}else l.push(e),n&&s.filter.set(t,!1,!1);}const g=this.filterTreeByLeaves(t,d),f=this.getLeafList(g),m=new Array(f.length);for(let t=0;t<f.length;++t){const e=f[t].name;e in d?m[t]=d[e]:a.push(e);}return e.setRowOrder(m),console.debug(`Dendrogram.setGridOrder() resTreeLeafList.length = ${f.length}`),console.debug(\"Dendrogram.setGridOrder() end\"),[g,[].concat(a,l)]}markClusters(t,e,n,i,s){const a=s??null,l=e.getCol(i);l.init((t=>a));const h=n?e.getCol(n):r.Column.fromList(r.COLUMN_TYPE.INT,\"<index>\",o().count(0).take(e.rowCount).toArray()),c={};for(let t=0;t<e.rowCount;t++)c[h.get(t)]=t;const u=this.getLeafList(t);for(let t=1;t<u.length+1;t++){const e=u[t-1];for(const n of e.cuttedLeafNameList??[]){const e=c[n];l.set(e,t,!1);}}}buildClusters(t,e,n,i){for(let t=e.rowCount-1;t>=0;t--)e.rows.removeAt(t);const r=this.getLeafList(t);for(let t=1;t<r.length+1;t++){const n=r[t-1].cuttedLeafNameList??[],i=n.join(\", \");e.rows.addNew([t,i,n.length],!1);}}cutTreeToGrid(t,e,n,i,r,s){const o=this.treeCutAsLeaves(t,e,0),l=s??null;n.getCol(r).init((t=>l));const h={};for(let t=0;t<n.rowCount;t++){const e=n.get(i,t);h[e]=t;}function c(t,e){if((0, a.xe)(t)){const i=t.name,s=h[i];n.set(r,s,e);}else for(const n of t.children)c(n,e);}for(let t=1;t<=o.length;t++)c(o[t-1],t);}generateTree(t){function e(t,n){if(t.children.length<2)t.children.push(n);else {const i=Math.random(),r=Math.floor(i/(1/t.children.length));e(t.children[r],n);}}const n={name:\"node-0\",branch_length:Math.random(),children:[]};for(let i=1;i<t;i++)e(n,{name:`node-${i}`,branch_length:Math.random(),children:[]});return n}async hierarchicalClustering(t,e,n){const r=await i.functions.call(\"Dendrogram:hierarchicalClusteringScript\",{data:t,distance_name:e,linkage_name:n}),s=(0, l.Z$)(r);return s.branch_length||(s.branch_length=0),s}async hierarchicalClusteringByDistance(t,e){const n=r.Column.fromFloat32Array(\"distance\",t.data),s=r.DataFrame.fromColumns([n]),o=await i.functions.call(\"Dendrogram:hierarchicalClusteringByDistanceScript\",{data:s,size:t.size,linkage_name:e}),a=(0, l.Z$)(o);return a.branch_length||(a.branch_length=0),a}async encodeSequences(t){const e=u.GO.forColumn(t),n=t.toList(),i=n.length;let r=36;const s=new Map;for(let o=0;o<i;o++){if(n[o],null===n[o]||t.isNone(o)){n[o]=null;continue}n[o]=\"\";const i=e.getSplitted(o);for(let t=0;t<i.length;t++){const e=i.getCanonical(t);s.has(e)||(s.set(e,String.fromCharCode(r)),r++),n[o]+=s.get(e);}}return n}async calcDistanceMatrix(t,e,n=a.uf.Euclidean){let s=null;const o=new c.AY(!0,!1),l=e.map((e=>t.getCol(e)));for(const t of l){let e;if(t.type===r.TYPE.FLOAT||t.type===r.TYPE.INT)e=await o.calc(t.getRawData(),g.RR.Difference,!1);else if(t.semType===r.SEMTYPE.MACROMOLECULE){const n=d.Z.LEVENSHTEIN,i=await this.encodeSequences(t);e=await o.calc(i,n,!1);}else {if(t.semType!==r.SEMTYPE.MOLECULE)throw new TypeError(\"Unsupported column type\");{const n=(await i.functions.call(\"Chem:getMorganFingerprints\",{molColumn:t})).toList().map((t=>t?t.getBuffer():null));e=await o.calc(n,g.m6.TanimotoIntArray,!1);}}if(s){let t=new c.Hc(e);t.normalize(),n===a.uf.Manhattan||t.square(),s.add(t),t=null;}else s=new c.Hc(e),l.length>1&&(s.normalize(),n===a.uf.Euclidean&&s.square());}return o.terminate(),n===a.uf.Euclidean&&l.length>1&&s?.sqrt(),s}parseClusterMatrix(t){function e(t){return (0, a.xe)(t)?0:function t(e){return e&&e.length?(e[0].branch_length??0)+t(e[0].children):0}(t.children)}const{mergeRow1:n,mergeRow2:i,heightsResult:r}=t,s=new Array(r.length);for(let t=0;t<r.length;t++){const o=n[t]<0?{name:(-1*n[t]-1).toString(),branch_length:r[t]}:s[n[t]-1],a=i[t]<0?{name:(-1*i[t]-1).toString(),branch_length:r[t]}:s[i[t]-1],l=e(o),h=e(a);o.branch_length=r[t]-l,a.branch_length=r[t]-h,s[t]={name:\"\",children:[o,a],branch_length:0};}return s[s.length-1]}}},9689:(t,e,n)=>{n.d(e,{Uj:()=>T,MX:()=>_,hD:()=>v});var i=n(7389),r=n(6082),s=n(1757),o=n.n(s),a=n(1991),l=n.n(a),h=n(342),c=n(4622),u=n(6806),d=n(1058),g=n(9666);class f extends g.Bq{get lineWidth(){return this._lineWidth}set lineWidth(t){this._lineWidth=t,this._onStylingChanged.next();}get nodeSize(){return this._nodeSize}set nodeSize(t){this._nodeSize=t,this._onStylingChanged.next();}get showGrid(){return this._showGrid}set showGrid(t){this._showGrid=t,this._onStylingChanged.next();}get strokeColor(){return this._strokeColor}set strokeColor(t){this._strokeColor=t,this._onStylingChanged.next();}getStrokeColor(t){return this._strokeColor}get fillColor(){return this._fillColor}set fillColor(t){this._fillColor=t,this._onStylingChanged.next();}getFillColor(t){return this._fillColor}constructor(t,e,n,i,r,s){super(t,e,n,i,r,s);}}class m extends f{constructor(t,e,n,i,r,s,o,a,l){super(t,e,n,i,a,l),this._nodeCol=r,this._colorCol=s,this._colorAggrType=o,this._rowByNameDict={};const h=this._colorCol.length;for(let t=0;t<h;t++){const e=this._nodeCol.get(t);this._rowByNameDict[e]=t;}}getStrokeColor(t){let e;if(this._colorCol.meta.colors.getType()!=r.COLOR_CODING_TYPE.OFF){const n=t.name,i=this._rowByNameDict[n],s=this._colorCol.meta.colors.getColor(i);e=r.Color.toRgb(s);}else e=this._strokeColor;return e}getFillColor(t){let e;if(this._colorCol.meta.colors.getType()!=r.COLOR_CODING_TYPE.OFF){const n=t.name,i=this._rowByNameDict[n],s=this._colorCol.meta.colors.getColor(i);e=r.Color.toRgb(s);}else e=this._fillColor;return e}}var p=n(5819),C=n(818),w=n(2908),b=n(4664);const _=2,v=4,y=.5;var A,S;!function(t){t.STYLE=\"Style\",t.BEHAVIOR=\"Behavior\",t.LAYOUT=\"Layout\",t.DATA=\"Data\";}(A||(A={})),function(t){t.newick=\"newick\",t.newickTag=\"newickTag\",t.nodeColumnName=\"nodeColumnName\",t.colorColumnName=\"colorColumnName\",t.colorAggrType=\"colorAggrType\",t.lineWidth=\"lineWidth\",t.nodeSize=\"nodeSize\",t.mainColor=\"mainColor\",t.lightColor=\"lightColor\",t.currentColor=\"currentColor\",t.mouseOverColor=\"mouseOverColor\",t.selectionsColor=\"selectionsColor\",t.font=\"font\",t.showGrid=\"showGrid\",t.showLabels=\"showLabels\",t.firstLeaf=\"firstLeaf\",t.step=\"step\",t.stepZoom=\"stepZoom\",t.showTooltip=\"showTooltip\";}(S||(S={}));class T extends r.JsViewer{constructor(){super(),this.viewed=!1,this.viewerId=++T.viewerCounter,this._newick=\"\",this.treeNewick=null,this.viewSubs=[],this.newick=this.string(S.newick,d.Et,{category:A.DATA}),this.newickTag=this.string(S.newickTag,null,{category:A.DATA,choices:[]}),this.nodeColumnName=this.string(S.nodeColumnName,null,{category:A.DATA}),this.colorColumnName=this.string(S.colorColumnName,null,{category:A.DATA}),this.colorAggrType=this.string(S.colorAggrType,null,{category:A.DATA,choices:[r.AGG.AVG,r.AGG.MIN,r.AGG.MAX,r.AGG.MED,r.AGG.TOTAL_COUNT]}),this.lineWidth=this.float(S.lineWidth,_,{category:A.STYLE,editor:\"slider\",min:0,max:16,step:.1}),this.nodeSize=this.float(S.nodeSize,v,{category:A.STYLE,editor:\"slider\",min:0,max:16,step:.1}),this.showGrid=this.bool(S.showGrid,!1,{category:A.STYLE}),this.mainColor=this.int(S.mainColor,c.LX[c.u_.Main],{category:A.STYLE}),this.lightColor=this.int(S.lightColor,c.LX[c.u_.Light],{category:A.STYLE}),this.currentColor=this.int(S.currentColor,c.LX[c.u_.Current],{category:A.STYLE}),this.mouseOverColor=this.int(S.mouseOverColor,c.LX[c.u_.MouseOver],{category:A.STYLE}),this.selectionsColor=this.int(S.selectionsColor,c.LX[c.u_.Selection],{category:A.STYLE}),this.showLabels=this.bool(S.showLabels,!1,{category:A.STYLE}),this.font=this.string(S.font,\"monospace 10pt\",{category:A.STYLE}),this.stepZoom=this.float(S.stepZoom,0,{category:A.BEHAVIOR,editor:\"slider\",min:-4,max:4,step:.1}),this.showTooltip=this.bool(S.showTooltip,!1,{category:A.BEHAVIOR}),this.logger=b._package.logger,this.step=this.float(S.step,28,{category:A.STYLE,editor:\"slider\",min:0,max:64,step:.1}),this.mainStyler=this.getMainStyler(),this.lightStyler=new f(\"light\",this.lineWidth,this.nodeSize,!1,(0, h.P1)((0, h.X9)(this.lightColor,y)),(0, h.P1)((0, h.X9)(this.lightColor,y))),this.currentStyler=new f(\"current\",this.lineWidth,this.nodeSize,!1,(0, h.P1)((0, h.X9)(this.currentColor,y)),(0, h.P1)((0, h.X9)(this.currentColor,y))),this.mouseOverStyler=new f(\"mouseOver\",this.lineWidth,this.nodeSize,!1,(0, h.P1)((0, h.X9)(this.mouseOverColor,y)),(0, h.P1)((0, h.X9)(this.mouseOverColor,y))),this.selectionsStyler=new f(\"selections\",this.lineWidth,this.nodeSize,!1,(0, h.P1)((0, h.X9)(this.selectionsColor,y)),(0, h.P1)((0, h.X9)(this.selectionsColor,y)));}toLog(){return `Dendrogram<${this.viewerId}>`}onTableAttached(){super.onTableAttached(),this.logger.debug(`Dendrogram: PhylocanvasGlViewer.onTableAttached() this.dataFrame = ${this.dataFrame?\"value\":\"null\"} )`);const t=l()(this.dataFrame.tags.keys()).filter((t=>t.startsWith(\".\"))).toArray();this.props.getProperty(S.newickTag).choices=[\"\",...t],this.setData();}detach(){this.viewed&&(this.destroyView(),this.viewed=!1),super.detach();}onPropertyChanged(t){if(super.onPropertyChanged(t),t){switch(t.name){case S.lineWidth:this.mainStyler.lineWidth=this.lineWidth,this.lightStyler.lineWidth=this.lineWidth,this.currentStyler.lineWidth=this.lineWidth,this.mouseOverStyler.lineWidth=this.lineWidth,this.selectionsStyler.lineWidth=this.lineWidth;break;case S.nodeSize:this.mainStyler.nodeSize=this.nodeSize,this.lightStyler.nodeSize=this.nodeSize,this.currentStyler.nodeSize=this.nodeSize,this.mouseOverStyler.nodeSize=this.nodeSize,this.selectionsStyler.nodeSize=this.nodeSize;break;case S.showGrid:this.mainStyler.showGrid=this.showGrid;break;case S.mainColor:this.mainStyler.strokeColor=(0, h.P1)((0, h.X9)(this.mainColor,y)),this.mainStyler.fillColor=(0, h.P1)((0, h.X9)(this.mainColor,y));break;case S.lightColor:this.lightStyler.strokeColor=(0, h.P1)((0, h.X9)(this.lightColor,y)),this.lightStyler.fillColor=(0, h.P1)((0, h.X9)(this.lightColor,y));break;case S.currentColor:this.currentStyler.strokeColor=(0, h.P1)((0, h.X9)(this.currentColor,y)),this.currentStyler.fillColor=(0, h.P1)((0, h.X9)(this.currentColor,y));break;case S.selectionsColor:this.selectionsStyler.strokeColor=(0, h.P1)((0, h.X9)(this.selectionsColor,y)),this.selectionsStyler.fillColor=(0, h.P1)((0, h.X9)(this.selectionsColor,y));break;case S.font:break;case S.colorColumnName:case S.colorAggrType:this.viewed&&this.mainStylerOnTooltipShowSub.unsubscribe(),this._renderer.mainStyler=this.mainStyler=this.getMainStyler(),this.viewed&&(this.mainStylerOnTooltipShowSub=this.mainStyler.onTooltipShow.subscribe(this.stylerOnTooltipShow.bind(this)));}switch(t.name){case S.newick:case S.newickTag:this.setData();}}else console.warn(\"Dendrogram: PhylocanvasGlViewer.onPropertyChanged() property is null\");}setData(){this.viewed&&(this.destroyView(),this.viewed=!1);let t=c.gp.NEWICK;this.newickTag&&(t=this.newickTag),this.treeNewick=this.dataFrame.getTag(t)??d.Et,this.newick&&this.newick!=d.Et&&(this.treeNewick=this.newick),this.viewed||(this.buildView(),this.viewed=!0);}get placer(){return this._placer}get renderer(){return this._renderer}destroyView(){this.logger.debug(\"Dendrogram: Dendrogram.destroyView()\");try{this.mainStylerOnTooltipShowSub.unsubscribe();for(const t of this.viewSubs)t.unsubscribe();this.viewSubs=[],this._renderer.detach(),delete this._renderer,delete this._placer,o()(this.treeDiv).empty(),delete this.treeDiv;}finally{o()(this.root).empty();}}buildView(){this.logger.debug(\"Dendrogram: Dendrogram.buildView()\"),this.treeDiv=i.div([],{style:{width:`${this.root.clientWidth}px`,height:`${this.root.clientHeight}px`}}),this.treeDiv.style.setProperty(\"overflow\",\"hidden\",\"important\"),this.root.appendChild(this.treeDiv);const t=(0, u.Z$)(this.treeNewick);t&&(0, g.vV)(t);const e=t.subtreeLength;this.mainStylerOnTooltipShowSub=this.mainStyler.onTooltipShow.subscribe(this.stylerOnTooltipShow.bind(this)),this._placer=new w.R(t.minIndex-.5,t.maxIndex+.5,e),this._renderer=new C.a(t,this._placer,this.mainStyler,this.lightStyler,this.currentStyler,this.mouseOverStyler,this.selectionsStyler),this.viewSubs.push(this._renderer.onCurrentChanged.subscribe(this.rendererOnCurrentChanged.bind(this))),this.viewSubs.push(this._renderer.onMouseOverChanged.subscribe(this.rendererOnMouseOverChanged.bind(this))),this.viewSubs.push(this._renderer.onSelectionChanged.subscribe(this.rendererOnSelectionChanged.bind(this))),this._renderer.attach(this.treeDiv),this.viewSubs.push(i.onSizeChanged(this.root).subscribe(this.rootOnSizeChanged.bind(this))),this.viewSubs.push(this.mainStyler.onTooltipShow.subscribe(this.stylerOnTooltipShow.bind(this))),this.viewSubs.push(this.dataFrame.onSelectionChanged.subscribe(this.dataFrameOnSelectionChanged.bind(this))),this.viewSubs.push(this.dataFrame.onCurrentRowChanged.subscribe(this.dataFrameOnCurrentRowChanged.bind(this))),this.viewSubs.push(this.dataFrame.onMouseOverRowChanged.subscribe(this.dataFrameOnMouseOverRowChanged.bind(this))),this.viewSubs.push(this.onContextMenu.subscribe(this.onContextMenuHandler.bind(this)));}onContextMenuHandler(t){t.item(\"Reset view\",(()=>{this._renderer?.onResetZoom();}));}rootOnSizeChanged(){this.logger.debug(\"Dendrogram: Dendrogram.rootOnSizeChanged()\"),this.treeDiv.style.width=`${this.root.clientWidth}px`,this.treeDiv.style.height=`${this.root.clientHeight}px`;}rendererOnCurrentChanged(){window.setTimeout((()=>{if(!this._renderer)return;const t=this.dataFrame.currentRowIdx;if(this._renderer.currentNode){if(this.nodeColumnName){const e=this.dataFrame.rowCount,n=this.dataFrame.getCol(this.nodeColumnName),i=this._renderer.currentNode.name,r=l().count(0).take(e).find((t=>n.get(t)==i))??-1;r!=t&&(this.dataFrame.currentRowIdx=r);}}else this.dataFrame.currentRowIdx=-1;}));}rendererOnMouseOverChanged(){window.setTimeout((()=>{if(!this._renderer)return;const t=this.dataFrame.mouseOverRowIdx;if(this._renderer.mouseOverNode){if(this.nodeColumnName){const e=this.dataFrame.rowCount,n=this.dataFrame.getCol(this.nodeColumnName),i=this._renderer.mouseOverNode.name,r=l().count(0).take(e).find((t=>n.get(t)==i))??-1;r!=t&&(this.dataFrame.mouseOverRowIdx=r);}}else this.dataFrame.mouseOverRowIdx=-1;}));}rendererOnSelectionChanged(){window.setTimeout((()=>{if(!this._renderer)return;const t=this.dataFrame.selection.clone();if(0==this._renderer.selectedNodes.length)this.dataFrame.selection.init((t=>!1),!1);else if(this.nodeColumnName){const t=this.dataFrame.getCol(this.nodeColumnName),e=new p.h,n=new Set(this._renderer.selectedNodes.map((t=>e.getNodeList(t).map((t=>t.name)))).flat());this.logger.debug(`Dendrogram: Dendrogram.rendererOnSelectionChanged(), nodeNameSet = ${JSON.stringify([...n])}`),this.dataFrame.selection.init((e=>{const i=t.get(e);return n.has(i)}),!1);}const e=this.dataFrame.selection;let n=t.length!==e.length||t.trueCount!==e.trueCount;if(!n)for(let i=0;i<t.length;i++)if(t.get(i)!==e.get(i)){n=!0;break}n&&this.dataFrame.selection.fireChanged();}),0);}dataFrameOnSelectionChanged(t){if(!this._renderer||!this._placer)return;const e=new p.h;if(this.nodeColumnName){const n=e.getNodeList(this._renderer.treeRoot),i={};for(const h of n){if(h.name in i)throw new Error(\"Non unique key tree node name\");i[h.name]=h;}const r={},s=this.dataFrame.getCol(this.nodeColumnName);for(let c=0;c<s.length;c++)r[s.get(c)]=c;const o=[],a=this.dataFrame.selection.getSelectedIndexes();for(const u of a){const d=i[s.get(u)],g=[];let f=!1;for(let m=0;m<o.length;m++){const C=o[m].node;(C.minIndex??C.index)<=(d.minIndex??d.index)&&(d.maxIndex??d.index)<=(C.maxIndex??C.index)?f=!0:(d.minIndex??d.index)<=(C.minIndex??C.index)&&(C.maxIndex??C.index)<=(d.maxIndex??d.index)&&g.push(m);}for(let w=g.length-1;w>=0;w--)o.splice(g[w]);f||o.push({node:d,nodeHeight:this._placer.getNodeHeight(this._renderer.treeRoot,d)});}function l(t,e,n){const i=e[n.name];t.selection.set(i,!0,!1);for(const i of n.children??[])l(t,e,i);}for(const b of o)l(this.dataFrame,r,b.node);this._renderer.selections=o;}}dataFrameOnCurrentRowChanged(t){const e=`${this.toLog()}.dataFrameOnCurrentRowChanged()`;if(!this._renderer)return;this.logger.debug(`${e}, nodeColumnName: ${this.nodeColumnName}, currentRowIdx: ${this.dataFrame.currentRowIdx}`);let n=null;if(this.nodeColumnName&&this.dataFrame.currentRowIdx>=0){const t=this.dataFrame.getCol(this.nodeColumnName).get(this.dataFrame.currentRowIdx),e=(new p.h).getNodeList(this._renderer.treeRoot).find((e=>t==e.name))??null;n=e?{node:e,nodeHeight:this._placer.getNodeHeight(this._renderer.treeRoot,e)}:null;}this._renderer.current=n;}dataFrameOnMouseOverRowChanged(t){const e=`${this.toLog()}.dataFrameOnMouseOverRowChanged()`;if(!this._renderer)return;this.logger.debug(`${e}, nodeColumnName: ${this.nodeColumnName}, mouseOverRowIdx: ${this.dataFrame.mouseOverRowIdx}`);let n=null;if(this.nodeColumnName&&this.dataFrame.mouseOverRowIdx>=0){const t=this.dataFrame.getCol(this.nodeColumnName).get(this.dataFrame.mouseOverRowIdx),e=(new p.h).getNodeList(this._renderer.treeRoot).find((e=>t==e.name))??null;n=e?{node:e,nodeHeight:this._placer.getNodeHeight(this._renderer.treeRoot,e)}:null;}this._renderer.mouseOver=n;}stylerOnTooltipShow({node:t,e}){if(this.showTooltip&&t){const n=(0, c.xe)(t)?\"\":` (min: ${t.minIndex}, max: ${t.maxIndex})`,r=i.divV([i.div(`${t.name}`),i.div(`index: ${t.index}${n}`),i.div(`desc: ${t.desc}`)]);i.tooltip.show(r,e.clientX+16,e.clientY+16);}else i.tooltip.hide();}getMainStyler(){let t;if(this.colorColumnName){const e=this.dataFrame.getCol(this.colorColumnName),n=this.dataFrame.getCol(this.nodeColumnName);t=new m(\"main-color-coding\",this.lineWidth,this.nodeSize,this.showGrid,n,e,this.colorAggrType,(0, h.P1)((0, h.X9)(this.mainColor,y)),(0, h.P1)((0, h.X9)(this.mainColor,y)));}else t=new f(\"main\",this.lineWidth,this.nodeSize,this.showGrid,(0, h.P1)((0, h.X9)(this.mainColor,y)),(0, h.P1)((0, h.X9)(this.mainColor,y)));return t}}S.newick,S.newickTag,S.nodeColumnName,S.colorColumnName,S.colorAggrType,S.lineWidth,S.nodeSize,S.showGrid,S.mainColor,S.lightColor,S.currentColor,S.mouseOverColor,S.selectionsColor,S.font,S.showLabels,S.step,S.stepZoom,S.showTooltip,T.viewerCounter=-1,r.JsViewer;},3797:(t,e,n)=>{n.d(e,{J:()=>w});var i=n(7389),r=n(1757),s=n.n(r),o=n(5819),a=n(9666),l=n(342),h=n(818);class c extends h.a{get leftPadding(){return this._leftPadding}get rightPadding(){return this._rightPadding}constructor(t,e,n,r,s,a,l,h){super(e,n,r,s,a,l,h),this._leftPadding=6,this._rightPadding=6,this.th=new o.h,this.grid=t,this.subs.push(this.grid.onBeforeDrawContent.subscribe(this.gridOnChanged.bind(this))),this.subs.push(i.onSizeChanged(this.grid.root).subscribe(this.gridOnChanged.bind(this))),this.gridOnChanged();}viewOnSizeChanged(){}gridOnChanged(){if(!this.view||!this.canvas)return;const t=this.view.clientWidth,e=this.view.clientHeight-this.grid.colHeaderHeight;this.canvas.width=t*window.devicePixelRatio,this.canvas.height=e*window.devicePixelRatio,this.canvas.style.position=\"absolute\",this.canvas.style.left=\"0px\",this.canvas.style.top=`${this.grid.colHeaderHeight}px`,this.canvas.style.height=`${e}px`,this.canvas.style.width=`${t}px`,this.render(\"gridOnChanged\");}canvasOnWheel(t){if(t.preventDefault(),!this.canvas)return;const e=5*t.wheelDelta/-168;this.grid.vertScroll.scrollTo(this.grid.vertScroll.min+e);}canvasOnMouseDown(t){t.preventDefault();}canvasOnMouseUp(t){t.preventDefault();}canvasOnMouseMove(t){super.canvasOnMouseMove(t);}}var u=n(9689),d=n(4622);const g=.7;class f extends c{constructor(t,e,n,i,r,s,o,a){super(t,e,n,i,r,s,o,a);}attach(t){super.attach(t),this.view.style.setProperty(\"overflow-y\",\"hidden\",\"important\"),this.canvas.style.position=\"absolute\";}static create(t,e,n){const i=new a.Bq(\"main\",u.MX,u.hD,!0,(0, l.P1)((0, l.X9)(d.LX[d.u_.Main],g)),(0, l.P1)((0, l.X9)(d.LX[d.u_.Main],g))),r=new a.Bq(\"light\",u.MX,u.hD,!1,(0, l.P1)((0, l.X9)(d.LX[d.u_.Light],.5)),(0, l.P1)((0, l.X9)(d.LX[d.u_.Light],.5))),s=new a.Bq(\"current\",u.MX,u.hD,!1,(0, l.P1)((0, l.X9)(d.LX[d.u_.Current],g)),(0, l.P1)((0, l.X9)(d.LX[d.u_.Current],g))),o=new a.Bq(\"mouseOver\",u.MX,u.hD,!1,(0, l.P1)((0, l.X9)(d.LX[d.u_.MouseOver],g)),(0, l.P1)((0, l.X9)(d.LX[d.u_.MouseOver],g))),h=new a.Bq(\"selection\",u.MX,u.hD,!1,(0, l.P1)((0, l.X9)(d.LX[d.u_.Selection],g)),(0, l.P1)((0, l.X9)(d.LX[d.u_.Selection],g)));return new f(t,e,n,i,r,s,o,h)}}var m=n(9226),p=n(2908);class C extends p.R{constructor(t,e){const n=Math.floor(t.vertScroll.min)-.5;super(n,n+(t.root.clientHeight-t.colHeaderHeight)/t.props.rowHeight,e),this.grid=t,this.grid.onBeforeDrawContent.subscribe(this.gridOnChanged.bind(this)),t.subs.push(i.onSizeChanged(this.grid.root).subscribe(this.gridOnChanged.bind(this)));}gridOnChanged(){const t=Math.floor(this.grid.vertScroll.min)-.5,e=t+(this.grid.root.clientHeight-this.grid.colHeaderHeight)/this.grid.props.rowHeight;this.update({top:t,bottom:e});}}function w(t,e,n,r=100,l){const h=new o.h,c=(0, m.S)(t,r);e&&(0, a.vV)(e);const u=e?e.subtreeLength:1;if(Number.isNaN(u))throw new Error(\"Can not calculate totalLength for the tree.\");const d=new C(t,u),g=f.create(t,e,d);g.attach(c.root),g.onAfterRender.subscribe((({target:e,context:n,lengthRatio:i})=>{if(p){const r=e;p.root.style.left=\"0px\",p.root.style.width=`${r.view.clientWidth}px`,p.root.style.height=`${t.colHeaderHeight}px`;const s=p.value*i+r.leftPadding*window.devicePixelRatio;n.strokeStyle=\"#A00000\",n.moveTo(s,0),n.lineTo(s,n.canvas.height),n.stroke();}}));let p=null;if(l){const t=e.subtreeLength;p=i.input.slider(\"\",{value:0,min:0,max:t}),s()(p.root).find(\"input\").each(((t,e)=>{e.setAttribute(\"step\",\"0.01\"),e.style.width=\"100%\",e.style.height=\"100%\";})),p.root.style.position=\"absolute\",p.root.style.top=\"0px\",p.root.style.backgroundColor=\"#FFF0F0\",c.root.appendChild(p.root),p.onChanged.subscribe((t=>{const i=Date.now();h.treeCutAsTree(e,t,!0);const r=Date.now();console.debug(`Dendrogram: injectTreeForGrid() cutSlider.onChanged() treeCutAsTree() ET: ${((r-i)/1e3).toString()}`);const s=JSON.parse(JSON.stringify(e)),o=h.treeCutAsTree(s,t);h.markClusters(o,l.dataDf,n??null,l.clusterColName),h.buildClusters(o,l.clusterDf,l.clusterColName,n),(0, a.vV)(o),g.treeRoot=o;}));}function w(){const[i]=h.setGridOrder(e,t,n);i&&(0, a.vV)(i),g.treeRoot=i;}w();let b=0;function _(t){console.debug(\"Dendrogram: injectTreeForGridUI2() grid.dataFrame.onFilterChanged()\"),b+=1,window.setTimeout((()=>{w();}),0);}const v=[];v.push(c.onClosed.subscribe((function(){for(const t of v)t.unsubscribe();}))),v.push(g.onCurrentChanged.subscribe((function(){window.setTimeout((()=>{if(!g||!d)return;const e=new Set,i=g.current?h.getLeafList(g.current.node):null;if(i&&i.length>0){const r=new Set(i.map((t=>t.name)));if(n){const i=t.dataFrame.getCol(n),s=t.dataFrame.rowCount;for(let t=0;t<s;t++){const n=i.get(t);if(r.has(n)){e.add(t);break}}}else i.forEach((t=>{e.add(parseInt(t.name));}));}1===e.size?t.dataFrame.currentRowIdx=e.values().next().value:(t.dataFrame.selection.init((t=>e.has(t))),t.dataFrame.selection.fireChanged()),t.invalidate();}));}))),v.push(g.onMouseOverChanged.subscribe((function(){window.setTimeout((()=>{if(!g||!d)return;const e=t.dataFrame.mouseOverRowIdx,i=g.mouseOver?h.getLeafList(g.mouseOver.node)[0]:null;let r=-1;if(i)if(n){const e=t.dataFrame.getCol(n),s=t.dataFrame.rowCount;for(let t=0;t<s;t++)if(e.get(t)==i.name){r=t;break}}else r=parseInt(i.name);r!=e&&(t.dataFrame.mouseOverRowIdx=r);}));}))),v.push(g.onSelectionChanged.subscribe((function(){window.setTimeout((()=>{if(!g||!d)return;const e=t.dataFrame.selection.clone();if(0==g.selections.length)t.dataFrame.selection.init((t=>!1),!1);else {const e=n?t.dataFrame.getCol(n):null,i=new Set(g.selectedNodes.map((t=>h.getNodeList(t).map((t=>t.name)))).flat());t.dataFrame.selection.init((t=>{const n=e?e.get(t):`${t}`;return i.has(n)}),!1);}const i=t.dataFrame.selection;let r=e.length!==i.length||e.trueCount!==i.trueCount;if(!r)for(let t=0;t<e.length;t++)if(e.get(t)!==i.get(t)){r=!0;break}r&&t.dataFrame.selection.fireChanged();}),0);})));let y=t.onRowsSorted.subscribe((function e(n){if(b>0)return void(b-=1);const r=i.div();r.style.width=c.root.style.width,r.style.height=c.root.style.height,r.classList.add(\"dendrogram-overlay\");const s=i.div(\"Revert columns sort order to see Dendrogram Tree\"),o=i.button(\"Revert sort\",(()=>{w(),c?.root?.removeChild(r),y=t.onRowsSorted.subscribe(e);})),a=i.divV([s,o]);r.appendChild(a),c.root?.appendChild(r),y.unsubscribe();}));return v.push(y),v.push(t.onRowsResized.subscribe(_)),v.push(t.dataFrame.onCurrentRowChanged.subscribe((function(e){const i=n?t.dataFrame.getCol(n):null,r=t.dataFrame.currentRowIdx,s=-1==r?null:i?i.get(r):`${r}`,a=new o.h,l=g.treeRoot?a.getNodeList(g.treeRoot).find((t=>s==t.name))??null:null,h=l?{node:l,nodeHeight:d.getNodeHeight(g.treeRoot,l)}:null;g.current=h;}))),v.push(t.dataFrame.onMouseOverRowChanged.subscribe((function(e){if(!g||!d)return;const i=n?t.dataFrame.getCol(n):null,r=t.dataFrame.mouseOverRowIdx,s=-1==r?null:i?i.get(r):`${r}`,a=(new o.h).getLeafList(g.treeRoot).find((t=>s==t.name))??null,l=a?{node:a,nodeHeight:d.getNodeHeight(g.treeRoot,a)}:null;g.mouseOver=l;}))),v.push(t.dataFrame.onSelectionChanged.subscribe((function(e){if(!g||!d)return;const i=h.getLeafList(g.treeRoot),r={};for(const t of i){if(t.name in r)throw new Error(\"Non unique key tree node name\");r[t.name]=t;}const s={},o=n?t.dataFrame.getCol(n):null,a=t.dataFrame.rowCount;for(let t=0;t<a;t++)s[o?o.get(t):`${t}`]=t;const l={},c=t.dataFrame.selection.getSelectedIndexes();for(const t of c)l[o?o.get(t):`${t}`]=t;const u=h.getNodesByLeaves(g.treeRoot,l),f=[];for(const t of u)f.push({node:t,nodeHeight:d.getNodeHeight(g.treeRoot,t)});g.selections=f;}))),v.push(t.dataFrame.onFilterChanged.subscribe(_)),c}n(9778);},818:(t,e,n)=>{n.d(e,{a:()=>u});var i=n(6082),r=n(7389),s=n(1858);class o{get treeRoot(){return this._treeRoot}set treeRoot(t){this._treeRoot=t,this._current=null,this._mouseOver=null,this._selections=[],this.render(\"set treeRoot()\");}get currentNode(){return this._current?this._current.node:null}get onCurrentChanged(){return this._onCurrentChanged}get current(){return this._current}set current(t){(null!=t&&null==this._current||null==t&&null!=this._current||null!=t&&null!=this._current&&t.node!=this._current.node)&&(this._current=t,this.render(\"set current()\"),this._onCurrentChanged.next());}get mouseOverNode(){return this._mouseOver?this._mouseOver.node:null}get onMouseOverChanged(){return this._onMouseOverChanged}get mouseOver(){return this._mouseOver}set mouseOver(t){if(null!=t&&null==this._mouseOver||null==t&&null!=this._mouseOver||null!=t&&null!=this._mouseOver&&t.node!=this._mouseOver.node){const e=`this._mouseOver.node.name = '${this._mouseOver?this._mouseOver.node.name:\"<null>\"}', value.node.name = '${t?t.node.name:\"<null>\"}'`;this._mouseOver=t,this.render(\"set mouseOver() \"+e),this._onMouseOverChanged.next();}}get selectedNodes(){return this._selectedNodes}get onSelectionChanged(){return this._onSelectionChanged}get selections(){return this._selections}set selections(t){(t.length!=this.selections.length||t.some(((t,e)=>t.node!=this.selections[e].node)))&&(this._selections=t,this._selectedNodes=this._selections.map((t=>t.node)),this.render(\"set selections()\"),this._onSelectionChanged.next());}constructor(t){this._onCurrentChanged=new s.Subject,this._current=null,this._onMouseOverChanged=new s.Subject,this._mouseOver=null,this._selectedNodes=[],this._onSelectionChanged=new s.Subject,this._selections=[],this.subs=[],this._treeRoot=t,this._onAfterRender=new s.Subject;}attach(t){this.view=t,this.subs.push(r.onSizeChanged(this.view).subscribe(this.viewOnSizeChanged.bind(this))),window.setTimeout((()=>{this.viewOnSizeChanged();}),0);}detach(){for(const t of this.subs)t.unsubscribe();delete this.view;}get onAfterRender(){return this._onAfterRender}viewOnSizeChanged(){console.debug(\"Dendrogram: TreeRendererBase.viewOnSizeChanged()\"),this.render(\"viewOnSizeChanged\");}}var a=n(9666),l=n(5819);function h(t){var e;return \"string\"==typeof t||t instanceof String?t:(\"object\"==typeof t||t instanceof Object)&&\"$thrownJsError\"in t?h(t.$thrownJsError):t instanceof Error?null!==(e=t.stack)&&void 0!==e?e:t.message:t.toString()}function c(t,e,n){const r=e.clientWidth-n.padding.left-n.padding.right;return new i.Point((t.x-n.padding.left)*n.totalLength/r,n.top+t.y*n.height/e.clientHeight)}class u extends o{get mainStyler(){return this._mainStyler}set mainStyler(t){this.view&&this._mainStylerOnChangedSub.unsubscribe(),this._mainStyler=t,this.view&&(this._mainStylerOnChangedSub=this._mainStyler.onStylingChanged.subscribe(this.stylerOnChanged.bind(this)),this.render(\"mainStyler\"));}constructor(t,e,n,i,r,s,o){super(t),this.renderCounter=0,this.mouseDragging=null,this.placer=e,this.placer.onPlacingChanged.subscribe(this.placerOnChanged.bind(this)),this.initialPos={top:e.top,bottom:e.bottom},this._mainStyler=n,this.lightStyler=i,this.currentStyler=r,this.mouseOverStyler=s,this.selectionStyler=o;}render(t){if(!this.view||!this.canvas)return;const e=this.canvas.getContext(\"2d\"),n=window.devicePixelRatio,i=this.canvas.width-n*(this.placer.padding.left+this.placer.padding.right),r=this.canvas.height,s=this.placer.bottom-this.placer.top,o=i/this.placer.totalLength,l=r/s;e.save();try{this.treeRoot&&function t(e){if(e){e.desc=\"\";for(const n of e.children??[])t(n);}}(this.treeRoot),e.fillStyle=\"#FFFFFF\",e.fillRect(0,0,e.canvas.width,e.canvas.height);const t=new a.Bq(\"invisible\",0,0,!1,\"#00000000\",\"#00000000\");if(this.renderCounter++,this.treeRoot){const n=this.mouseOver?this.lightStyler:this._mainStyler,i=this.selections.map((t=>({target:t.node,styler:this.selectionStyler})));(0,a.VO)({ctx:e,firstRowIndex:this.placer.top,lastRowIndex:this.placer.bottom,leftPadding:this.placer.padding.left,lengthRatio:o,stepRatio:l,totalLength:this.placer.totalLength,styler:n},this.treeRoot,0,[...i]);for(const t of this.selections)(0,a.VO)({ctx:e,firstRowIndex:this.placer.top,lastRowIndex:this.placer.bottom,leftPadding:this.placer.padding.left,lengthRatio:o,stepRatio:l,styler:this.selectionStyler,totalLength:this.placer.totalLength},t.node,t.nodeHeight,[]);if(this.current){const n=[{target:this.current.node,styler:this.currentStyler}];(0,a.VO)({ctx:e,firstRowIndex:this.placer.top,lastRowIndex:this.placer.bottom,leftPadding:this.placer.padding.left,lengthRatio:o,stepRatio:l,totalLength:this.placer.totalLength,styler:t},this.treeRoot,0,[...n]);}if(this.mouseOver){const n=[{target:this.mouseOver.node,styler:this.mouseOverStyler}];(0,a.VO)({ctx:e,firstRowIndex:this.placer.top,lastRowIndex:this.placer.bottom,leftPadding:this.placer.padding.left,lengthRatio:o,stepRatio:l,totalLength:this.placer.totalLength,styler:t},this.treeRoot,0,[...n]),(0,a.VO)({ctx:e,firstRowIndex:this.placer.top,lastRowIndex:this.placer.bottom,leftPadding:this.placer.padding.left,lengthRatio:o,stepRatio:l,totalLength:this.placer.totalLength,styler:this.mouseOverStyler},this.mouseOver.node,this.mouseOver.nodeHeight,[]);}}}catch(t){const e=h(t);throw console.error(\"Dendrogram: CanvasTreeRenderer.render() error:\\n\"+e),t}finally{e.restore(),this._onAfterRender.next({target:this,context:e,lengthRatio:o});}}attach(t){super.attach(t),this.canvas=r.canvas(),this.view.appendChild(this.canvas),this._mainStylerOnChangedSub=this._mainStyler.onStylingChanged.subscribe(this.stylerOnChanged.bind(this)),this.subs.push(this.lightStyler.onStylingChanged.subscribe(this.stylerOnChanged.bind(this))),this.subs.push(this.currentStyler.onStylingChanged.subscribe(this.stylerOnChanged.bind(this))),this.subs.push(this.mouseOverStyler.onStylingChanged.subscribe(this.stylerOnChanged.bind(this))),this.subs.push(this.selectionStyler.onStylingChanged.subscribe(this.stylerOnChanged.bind(this))),this.subs.push(s.fromEvent(this.canvas,\"wheel\").subscribe(this.canvasOnWheel.bind(this))),this.subs.push(s.fromEvent(this.canvas,\"mousedown\").subscribe(this.canvasOnMouseDown.bind(this))),this.subs.push(s.fromEvent(this.canvas,\"mouseup\").subscribe(this.canvasOnMouseUp.bind(this))),this.subs.push(s.fromEvent(this.canvas,\"mousemove\").subscribe(this.canvasOnMouseMove.bind(this))),this.subs.push(s.fromEvent(this.canvas,\"click\").subscribe(this.canvasOnClick.bind(this))),this.subs.push(s.fromEvent(this.canvas,\"dblclick\").subscribe(this.onCanvasDoubleClick.bind(this)));}detach(){this.canvas.remove(),delete this.canvas,this._mainStylerOnChangedSub.unsubscribe(),super.detach();}viewOnSizeChanged(){if(!this.view||!this.canvas)return;const t=window.devicePixelRatio,e=this.view.clientWidth,n=this.view.clientHeight;this.canvas.width=t*e,this.canvas.height=t*n,this.canvas.style.left=\"{0}px\",this.canvas.style.top=\"{0}px\",this.canvas.style.width=`${e}px`,this.canvas.style.height=`${n}px`,super.viewOnSizeChanged();}placerOnChanged(){this.render(\"placerOnChanged()\");}stylerOnChanged(){this.render(\"stylerOnChanged()\");}onCanvasDoubleClick(){this.current||this.onResetZoom();}onResetZoom(){this.placer.update(this.initialPos),this.render(\"onResetZoom()\");}canvasOnWheel(t){if(!this.canvas||this.mouseDragging)return;t.preventDefault();const e=c(new i.Point(t.offsetX,t.offsetY),this.canvas,this.placer),n=t.wheelDelta/-168,r=e.y-(e.y-this.placer.top)*(1+.2*n),s=e.y+(this.placer.bottom-e.y)*(1+.2*n);this.placer.update({top:r,bottom:s});}canvasOnMouseDown(t){if(!this.view||!this.canvas)return;const e=c(new i.Point(t.offsetX,t.offsetY),this.canvas,this.placer);this.mouseDragging={pos:e,top:this.placer.top,bottom:this.placer.bottom};}canvasOnMouseUp(t){this.mouseDragging=null;}canvasOnMouseMove(t){if(!this.view||!this.canvas)return;const e=new i.Point(t.offsetX,t.offsetY),n=this.mouseDragging;if(n){const e=n.top+t.offsetY*this.placer.height/this.canvas.clientHeight,i=n.pos.y-e;this.placer.update({top:n.top+i,bottom:n.bottom+i});}else this.mouseOver=this.treeRoot?this.placer.getNode(this.treeRoot,e,this._mainStyler.lineWidth,this._mainStyler.nodeSize,(t=>function(t,e,n){const r=e.clientWidth-n.padding.left-n.padding.right;return new i.Point(n.padding.left+r*t.x/n.totalLength,e.clientHeight*(t.y-n.top)/n.height)}(t,this.canvas,this.placer))):null,this._mainStyler.fireTooltipShow(this.mouseOver?this.mouseOver.node:null,t);}canvasOnClick(t){if(0==t.button)if(t.ctrlKey){if(this.mouseOver){const t=[...this.selections];let e=-1,n=-1;const i=new l.h;for(let t=0;t<this.selections.length;t++){const r=this.selections[t];r.node==this.mouseOver.node&&(e=t),i.includes(r.node,this.mouseOver.node),i.includes(this.mouseOver.node,r.node)&&(n=t);}-1!=e?t.splice(e,1):-1!=n?t[n]=this.mouseOver:t.push(this.mouseOver),this.selections=t;}}else this.mouseOver&&this.mouseOver.node&&this.mouseOver.node.children&&0!=this.mouseOver.node.children.length?this.selections=[this.mouseOver]:this.current=this.mouseOver;}}},9666:(t,e,n)=>{n.d(e,{Bq:()=>o,VO:()=>a,vV:()=>s});var i=n(1858),r=n(4622);function s(t,e=0){const n=Date.now();!function t(e,n){if((0, r.xe)(e))return e.index=n,e.subtreeLength=e.branch_length,n+1;{let i=0,r=n;e.minIndex=r;for(const n of e.children)r=t(n,r),i<n.subtreeLength&&(i=n.subtreeLength);return e.maxIndex=r-1,e.index=e.children.map((t=>t.index)).reduce(((t,e)=>t+e))/e.children.length,e.subtreeLength=i+e.branch_length,r}}(t,e);const i=Date.now();console.debug(`Dendrogram: markupNode() ET: ${((i-n)/1e3).toString()} s`);}class o{get name(){return this._name}get lineWidth(){return this._lineWidth}get nodeSize(){return this._nodeSize}get showGrid(){return this._showGrid}getStrokeColor(t){return this._strokeColor}getFillColor(t){return this._fillColor}get onStylingChanged(){return this._onStylingChanged}get onTooltipShow(){return this._onTooltipShow}constructor(t,e,n,r,s,o){this._onStylingChanged=new i.Subject,this._onTooltipShow=new i.Subject,this._name=t??\"\",this._lineWidth=e??1,this._nodeSize=n??3,this._showGrid=r??!1,this._strokeColor=s??\"#000000\",this._fillColor=o??\"#000000\";}fireTooltipShow(t,e){this._onTooltipShow.next({node:t,e});}}function a(t,e,n=0,i){const s=window.devicePixelRatio,o=t.ctx,a=function(t,e=0,n){const i=[{node:t,currentLength:e,traceList:n,parent:void 0}],r=[];for(;i.length>0;){const t=i.shift();if(t.traceList=n.filter((e=>e.target==t.node)),r.push(t),t.node.children)for(const e of t.node.children){const n=t.traceList.filter((t=>(e.minIndex??e.index)<=t.target.index&&t.target.index<=(e.maxIndex??e.index)));i.push({node:e,currentLength:t.currentLength+(t.node.branch_length??0),traceList:n,parent:t});}}r[0]&&(r[0].traceList=[]);for(let t=r.length-1;t>=0;t--){const e=r[t];if(e.parent)for(const t of e.traceList)e.parent.traceList.includes(t)||e.parent.traceList.push(t);}return r}(e,n,i);for(const e of a)try{const n=e.node,i=e.currentLength,a=i*t.lengthRatio+t.leftPadding*s,l=(i+n.branch_length)*t.lengthRatio+t.leftPadding*s,h=(n.index-t.firstRowIndex)*t.stepRatio,c=n.maxIndex??n.index,u=n.minIndex??n.index,d=t.firstRowIndex<=c&&u<=t.lastRowIndex;if(!d)continue;if(!(0,r.xe)(n)&&d){const r=n.children[0].index,d=n.children[n.children.length-1].index,g=(i+n.branch_length)*t.lengthRatio+t.leftPadding*s,f=Math.max((r-t.firstRowIndex)*t.stepRatio,0),m=Math.min((d-t.firstRowIndex)*t.stepRatio,t.ctx.canvas.height);if(o.beginPath(),o.strokeStyle=t.styler.getStrokeColor(n),o.lineWidth=t.styler.lineWidth*s,o.lineCap=\"round\",o.moveTo(g,f),o.lineTo(g,m),o.stroke(),u==c||(c-u)*t.stepRatio>1||e.traceList&&e.traceList.length>0)for(const i of n.children??[])for(const r of e.traceList){const e=(i.index-t.firstRowIndex)*t.stepRatio;o.beginPath(),o.strokeStyle=r.styler.getStrokeColor(n),o.lineWidth=r.styler.lineWidth*s,o.lineCap=\"round\",o.moveTo(l,e),o.lineTo(l,h),o.stroke();}else {const e=(i+n.subtreeLength)*t.lengthRatio+t.leftPadding*s;o.beginPath(),o.strokeStyle=t.styler.getStrokeColor(n),o.lineWidth=t.styler.lineWidth*s,o.lineCap=\"round\",o.moveTo(a,h),o.lineTo(e,h),o.stroke();}}if(d)for(const i of [t.styler,...e.traceList.map((t=>t.styler))])o.beginPath(),o.strokeStyle=i.getStrokeColor(n),o.lineWidth=i.lineWidth*s,o.lineCap=\"round\",o.moveTo(l,h),o.lineTo(a,h),o.stroke(),o.beginPath(),o.strokeStyle=i.getStrokeColor(n),o.lineWidth=i.lineWidth*s,o.lineCap=\"round\",o.moveTo(l,h),o.lineTo(a,h),o.stroke(),(0,r.xe)(n)&&(i.showGrid&&(o.beginPath(),o.strokeStyle=\"#C0C0C0\",o.lineWidth=1,o.lineCap=\"round\",o.moveTo(l,h),o.lineTo(o.canvas.width,h),o.stroke()),o.beginPath(),o.strokeStyle=i.getStrokeColor(n),o.fillStyle=i.getFillColor(n),o.beginPath(),o.ellipse(l,h,i.nodeSize*s/2,i.nodeSize*s/2,0,0,2*Math.PI),o.fill(),o.beginPath(),o.ellipse(l,h,i.nodeSize*s/2,i.nodeSize*s/2,0,0,2*Math.PI),o.stroke()),n.desc+=i.name+\", \";}catch(t){console.error(t);}return {traceback:a[0].traceList.map((t=>t.styler))}}},2908:(t,e,n)=>{n.d(e,{R:()=>o});var i=n(6082),r=n(1858),s=n(4622);class o{get top(){return this._top}get bottom(){return this._bottom}get height(){return this._bottom-this._top}get totalLength(){return this._totalLength}get padding(){return {left:8,right:8}}get onPlacingChanged(){return this._onChanged}constructor(t,e,n){this._top=t,this._bottom=e,this._totalLength=n,this._onChanged=new r.Subject;}update(t){let e=!1;t.top&&t.top!=this.top&&(this._top=t.top,e=!0),t.bottom&&t.bottom!=this.bottom&&(this._bottom=t.bottom,e=!0),t.totalLength&&t.totalLength!=this.totalLength&&(this._totalLength=t.totalLength,e=!0),e&&this._onChanged.next();}getNode(t,e,n,r,o){const a=function t(e,n,a){const l=window.devicePixelRatio,h=(e.minIndex??e.index)-.25,c=(e.maxIndex??e.index)+.25,u=o(new i.Point(a,h)),d=o(new i.Point(a+e.branch_length,c));if(u.y<=n.y&&n.y<=d.y){let h=null;const c=o(new i.Point(a+e.branch_length,e.index)),g=r*l/2;if((0, s.xe)(e)&&Math.pow((c.x-n.x)/g,2)+Math.pow((c.y-n.y)/g,2)<1&&(h={nodeHeight:a,node:e}),!h)for(const i of e.children??[])if(h=t(i,n,a+e.branch_length),h)break;return !h&&u.x<=n.x&&n.x<=d.x&&(h={nodeHeight:a,node:e}),h}return null}(t,e,0);return a}getNodeHeight(t,e){const n=t?function t(e,n,i){let r;if(e==n)r=i;else for(const s of e.children??[])if(r=t(s,n,i+e.branch_length),void 0!==r)break;return r}(t,e,0):void 0;return n}}},1757:t=>{t.exports=$;},6082:t=>{t.exports=DG;},4328:t=>{t.exports=grok;},1858:t=>{t.exports=rxjs;},7389:t=>{t.exports=ui;},1991:t=>{t.exports=wu;}},e={};function n(i){var r=e[i];if(void 0!==r)return r.exports;var s=e[i]={id:i,loaded:!1,exports:{}};return t[i](s,s.exports,n),s.loaded=!0,s.exports}n.m=t,n.amdO={},n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var i in e)n.o(e,i)&&!n.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]});},n.u=t=>t+\".js\",n.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),n.hmd=t=>((t=Object.create(t)).children||(t.children=[]),Object.defineProperty(t,\"exports\",{enumerable:!0,set:()=>{throw new Error(\"ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: \"+t.id)}}),t),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},(()=>{var t;n.g.importScripts&&(t=n.g.location+\"\");var e=n.g.document;if(!t&&e&&(e.currentScript&&(t=e.currentScript.src),!t)){var i=e.getElementsByTagName(\"script\");if(i.length)for(var r=i.length-1;r>-1&&(!t||!/^http(s?):/.test(t));)t=i[r--].src;}if(!t)throw new Error(\"Automatic publicPath is not supported in this browser\");t=t.replace(/#.*$/,\"\").replace(/\\?.*$/,\"\").replace(/\\/[^\\/]+$/,\"/\"),n.p=t;})(),n.b=document.baseURI||self.location.href,n.nc=void 0;n(4664);})();\n\t\t\n\t} ());\n\n\tlet exp = _package?.default || _package || { __emptyModule: true };try { Object.defineProperty(exp, \"__\" + \"esModule\", { value: true }); exp.default = exp; } catch (ex) {}\n\n\treturn exp;\n\n}));\n"
    }
  ]
}